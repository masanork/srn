var v8=Object.create;var{getPrototypeOf:A8,defineProperty:DJ,getOwnPropertyNames:x8}=Object;var g8=Object.prototype.hasOwnProperty;var f8=($,J,Q)=>{Q=$!=null?v8(A8($)):{};let q=J||!$||!$.__esModule?DJ(Q,"default",{value:$,enumerable:!0}):Q;for(let X of x8($))if(!g8.call(q,X))DJ(q,X,{get:()=>$[X],enumerable:!0});return q};var F8=($,J)=>()=>(J||$((J={exports:{}}).exports,J),J.exports);var KJ=F8((AQ,zJ)=>{zJ.exports=function $(J){if(typeof J==="number"&&isNaN(J))throw new Error("NaN is not allowed");if(typeof J==="number"&&!isFinite(J))throw new Error("Infinity is not allowed");if(J===null||typeof J!=="object")return JSON.stringify(J);if(J.toJSON instanceof Function)return $(J.toJSON());if(Array.isArray(J))return`[${J.reduce((X,Y,Z)=>{return`${X}${Z===0?"":","}${$(Y===void 0||typeof Y==="symbol"?null:Y)}`},"")}]`;return`{${Object.keys(J).sort().reduce((q,X)=>{if(J[X]===void 0||typeof J[X]==="symbol")return q;let Y=q.length===0?"":",";return`${q}${Y}${$(X)}:${$(J[X])}`},"")}}`}});var w8=f8(KJ(),1);/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function l$($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function H$($,J=""){if(!Number.isSafeInteger($)||$<0){let Q=J&&`"${J}" `;throw new Error(`${Q}expected integer >= 0, got ${$}`)}}function v($,J,Q=""){let q=l$($),X=$?.length,Y=J!==void 0;if(!q||Y&&X!==J){let Z=Q&&`"${Q}" `,G=Y?` of length ${J}`:"",U=q?`length=${X}`:`type=${typeof $}`;throw new Error(Z+"expected Uint8Array"+G+", got "+U)}return $}function r$($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function W0($,J){v($,void 0,"digestInto() output");let Q=J.outputLen;if($.length<Q)throw new Error('"digestInto() output" expected to be of length >='+Q)}function NJ($){return new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4))}function I$(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function N0($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function W$($,J){return $<<32-J|$>>>J}var _8=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function y8($){return $<<24&4278190080|$<<8&16711680|$>>>8&65280|$>>>24&255}function m8($){for(let J=0;J<$.length;J++)$[J]=y8($[J]);return $}var A0=_8?($)=>$:m8,VJ=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),b8=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0"));function a$($){if(v($),VJ)return $.toHex();let J="";for(let Q=0;Q<$.length;Q++)J+=b8[$[Q]];return J}var k$={_0:48,_9:57,A:65,F:70,a:97,f:102};function WJ($){if($>=k$._0&&$<=k$._9)return $-k$._0;if($>=k$.A&&$<=k$.F)return $-(k$.A-10);if($>=k$.a&&$<=k$.f)return $-(k$.a-10);return}function e$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(VJ)return Uint8Array.fromHex($);let J=$.length,Q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);let q=new Uint8Array(Q);for(let X=0,Y=0;X<Q;X++,Y+=2){let Z=WJ($.charCodeAt(Y)),G=WJ($.charCodeAt(Y+1));if(Z===void 0||G===void 0){let U=$[Y]+$[Y+1];throw new Error('hex string expected, got non-hex character "'+U+'" at index '+Y)}q[X]=Z*16+G}return q}function w$(...$){let J=0;for(let q=0;q<$.length;q++){let X=$[q];v(X),J+=X.length}let Q=new Uint8Array(J);for(let q=0,X=0;q<$.length;q++){let Y=$[q];Q.set(Y,X),X+=Y.length}return Q}function V0($,J={}){let Q=(X,Y)=>$(Y).update(X).digest(),q=$(void 0);return Q.outputLen=q.outputLen,Q.blockLen=q.blockLen,Q.create=(X)=>$(X),Object.assign(Q,J),Object.freeze(Q)}function $0($=32){let J=typeof globalThis==="object"?globalThis.crypto:null;if(typeof J?.getRandomValues!=="function")throw new Error("crypto.getRandomValues must be defined");return J.getRandomValues(new Uint8Array($))}var J0=($)=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,$])});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var MJ=BigInt(0),OJ=BigInt(1);function n$($,J=""){if(typeof $!=="boolean"){let Q=J&&`"${J}" `;throw new Error(Q+"expected boolean, got type="+typeof $)}return $}function u8($){if(typeof $==="bigint"){if(!O0($))throw new Error("positive bigint expected, got "+$)}else H$($);return $}function IJ($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?MJ:BigInt("0x"+$)}function RJ($){return IJ(a$($))}function i$($){return IJ(a$(M0(v($)).reverse()))}function x0($,J){H$(J),$=u8($);let Q=e$($.toString(16).padStart(J*2,"0"));if(Q.length!==J)throw new Error("number too large");return Q}function jJ($,J){return x0($,J).reverse()}function M0($){return Uint8Array.from($)}var O0=($)=>typeof $==="bigint"&&MJ<=$;function h8($,J,Q){return O0($)&&O0(J)&&O0(Q)&&J<=$&&$<Q}function g0($,J,Q,q){if(!h8(J,Q,q))throw new Error("expected valid "+$+": "+Q+" <= n < "+q+", got "+J)}var CJ=($)=>(OJ<<BigInt($))-OJ;function Q0($,J={},Q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function q(Y,Z,G){let U=$[Y];if(G&&U===void 0)return;let K=typeof U;if(K!==Z||U===null)throw new Error(`param "${Y}" is invalid: expected ${Z}, got ${K}`)}let X=(Y,Z)=>Object.entries(Y).forEach(([G,U])=>q(G,U,Z));X(J,!1),X(Q,!0)}function f0($){let J=new WeakMap;return(Q,...q)=>{let X=J.get(Q);if(X!==void 0)return X;let Y=$(Q,...q);return J.set(Q,Y),Y}}var I0=BigInt(4294967295),EJ=BigInt(32);function c8($,J=!1){if(J)return{h:Number($&I0),l:Number($>>EJ&I0)};return{h:Number($>>EJ&I0)|0,l:Number($&I0)|0}}function R0($,J=!1){let Q=$.length,q=new Uint32Array(Q),X=new Uint32Array(Q);for(let Y=0;Y<Q;Y++){let{h:Z,l:G}=c8($[Y],J);[q[Y],X[Y]]=[Z,G]}return[q,X]}var F0=($,J,Q)=>$>>>Q,_0=($,J,Q)=>$<<32-Q|J>>>Q,_$=($,J,Q)=>$>>>Q|J<<32-Q,y$=($,J,Q)=>$<<32-Q|J>>>Q,q0=($,J,Q)=>$<<64-Q|J>>>Q-32,X0=($,J,Q)=>$>>>Q-32|J<<64-Q;var kJ=($,J,Q)=>$<<Q|J>>>32-Q,HJ=($,J,Q)=>J<<Q|$>>>32-Q,TJ=($,J,Q)=>J<<Q-32|$>>>64-Q,BJ=($,J,Q)=>$<<Q-32|J>>>64-Q;function R$($,J,Q,q){let X=(J>>>0)+(q>>>0);return{h:$+Q+(X/4294967296|0)|0,l:X|0}}var SJ=($,J,Q)=>($>>>0)+(J>>>0)+(Q>>>0),wJ=($,J,Q,q)=>J+Q+q+($/4294967296|0)|0,LJ=($,J,Q,q)=>($>>>0)+(J>>>0)+(Q>>>0)+(q>>>0),PJ=($,J,Q,q,X)=>J+Q+q+X+($/4294967296|0)|0,vJ=($,J,Q,q,X)=>($>>>0)+(J>>>0)+(Q>>>0)+(q>>>0)+(X>>>0),AJ=($,J,Q,q,X,Y)=>J+Q+q+X+Y+($/4294967296|0)|0;var p8=BigInt(0),Y0=BigInt(1),l8=BigInt(2),r8=BigInt(7),a8=BigInt(256),n8=BigInt(113),fJ=[],FJ=[],_J=[];for(let $=0,J=Y0,Q=1,q=0;$<24;$++){[Q,q]=[q,(2*Q+3*q)%5],fJ.push(2*(5*q+Q)),FJ.push(($+1)*($+2)/2%64);let X=p8;for(let Y=0;Y<7;Y++)if(J=(J<<Y0^(J>>r8)*n8)%a8,J&l8)X^=Y0<<(Y0<<BigInt(Y))-Y0;_J.push(X)}var yJ=R0(_J,!0),i8=yJ[0],o8=yJ[1],xJ=($,J,Q)=>Q>32?TJ($,J,Q):kJ($,J,Q),gJ=($,J,Q)=>Q>32?BJ($,J,Q):HJ($,J,Q);function t8($,J=24){let Q=new Uint32Array(10);for(let q=24-J;q<24;q++){for(let Z=0;Z<10;Z++)Q[Z]=$[Z]^$[Z+10]^$[Z+20]^$[Z+30]^$[Z+40];for(let Z=0;Z<10;Z+=2){let G=(Z+8)%10,U=(Z+2)%10,K=Q[U],D=Q[U+1],I=xJ(K,D,1)^Q[G],H=gJ(K,D,1)^Q[G+1];for(let S=0;S<50;S+=10)$[Z+S]^=I,$[Z+S+1]^=H}let X=$[2],Y=$[3];for(let Z=0;Z<24;Z++){let G=FJ[Z],U=xJ(X,Y,G),K=gJ(X,Y,G),D=fJ[Z];X=$[D],Y=$[D+1],$[D]=U,$[D+1]=K}for(let Z=0;Z<50;Z+=10){for(let G=0;G<10;G++)Q[G]=$[Z+G];for(let G=0;G<10;G++)$[Z+G]^=~Q[(G+2)%10]&Q[(G+4)%10]}$[0]^=i8[q],$[1]^=o8[q]}I$(Q)}class y0{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor($,J,Q,q=!1,X=24){if(this.blockLen=$,this.suffix=J,this.outputLen=Q,this.enableXOF=q,this.rounds=X,H$(Q,"outputLen"),!(0<$&&$<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=NJ(this.state)}clone(){return this._cloneInto()}keccak(){A0(this.state32),t8(this.state32,this.rounds),A0(this.state32),this.posOut=0,this.pos=0}update($){r$(this),v($);let{blockLen:J,state:Q}=this,q=$.length;for(let X=0;X<q;){let Y=Math.min(J-this.pos,q-X);for(let Z=0;Z<Y;Z++)Q[this.pos++]^=$[X++];if(this.pos===J)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:$,suffix:J,pos:Q,blockLen:q}=this;if($[Q]^=J,(J&128)!==0&&Q===q-1)this.keccak();$[q-1]^=128,this.keccak()}writeInto($){r$(this,!1),v($),this.finish();let J=this.state,{blockLen:Q}=this;for(let q=0,X=$.length;q<X;){if(this.posOut>=Q)this.keccak();let Y=Math.min(Q-this.posOut,X-q);$.set(J.subarray(this.posOut,this.posOut+Y),q),this.posOut+=Y,q+=Y}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return H$($),this.xofInto(new Uint8Array($))}digestInto($){if(W0($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,I$(this.state)}_cloneInto($){let{blockLen:J,suffix:Q,outputLen:q,rounds:X,enableXOF:Y}=this;return $||=new y0(J,Q,q,Y,X),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=X,$.suffix=Q,$.outputLen=q,$.enableXOF=Y,$.destroyed=this.destroyed,$}}var mJ=($,J,Q,q={})=>V0((X={})=>new y0(J,$,X.dkLen===void 0?Q:X.dkLen,!0),q),bJ=mJ(31,168,16,J0(11)),X$=mJ(31,136,32,J0(12));function m0($){if(!Number.isSafeInteger($)||$<0||$>4294967295)throw new Error("wrong u32 integer:"+$);return $}function hJ($){return m0($),($&$-1)===0&&$!==0}function b0($,J){m0($);let Q=0;for(let q=0;q<J;q++,$>>>=1)Q=Q<<1|$&1;return Q}function cJ($){return m0($),31-Math.clz32($)}function uJ($){let J=$.length;if(J<2||!hJ(J))throw new Error("n must be a power of 2 and greater than 1. Got "+J);let Q=cJ(J);for(let q=0;q<J;q++){let X=b0(q,Q);if(q<X){let Y=$[q];$[q]=$[X],$[X]=Y}}return $}var u0=($,J)=>{let{N:Q,roots:q,dit:X,invertButterflies:Y=!1,skipStages:Z=0,brp:G=!0}=J,U=cJ(Q);if(!hJ(Q))throw new Error("FFT: Polynomial size should be power of two");let K=X!==Y;return(D)=>{if(D.length!==Q)throw new Error("FFT: wrong Polynomial length");if(X&&G)uJ(D);for(let I=0,H=1;I<U-Z;I++){let S=X?I+1+Z:U-I,E=1<<S,x=E>>1,O=Q>>S;for(let C=0;C<Q;C+=E)for(let z=0,V=H++;z<x;z++){let w=Y?X?Q-V:V:z*O,A=C+z,f=C+z+x,P=q[w],W=D[f],M=D[A];if(K){let T=$.mul(W,P);D[A]=$.add(M,T),D[f]=$.sub(M,T)}else if(Y)D[A]=$.add(W,M),D[f]=$.mul($.sub(W,M),P);else D[A]=$.add(M,W),D[f]=$.mul($.sub(M,W),P)}}if(!X&&G)uJ(D);return D}};/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */var h0=$0;function c0($,J){if($.length!==J.length)return!1;let Q=0;for(let q=0;q<$.length;q++)Q|=$[q]^J[q];return Q===0}function d0($){if(typeof $!=="object"||$===null||l$($))throw new Error("expected opts to be an object")}function j0($){if(d0($),$.context!==void 0)v($.context,void 0,"opts.context")}function C0($){if(j0($),$.extraEntropy!==!1&&$.extraEntropy!==void 0)v($.extraEntropy,void 0,"opts.extraEntropy")}function Z0($,...J){let Q=(X)=>typeof X==="number"?X:X.bytesLen,q=J.reduce((X,Y)=>X+Q(Y),0);return{bytesLen:q,encode:(X)=>{let Y=new Uint8Array(q);for(let Z=0,G=0;Z<J.length;Z++){let U=J[Z],K=Q(U),D=typeof U==="number"?X[Z]:U.encode(X[Z]);if(v(D,K,$),Y.set(D,G),typeof U!=="number")D.fill(0);G+=K}return Y},decode:(X)=>{v(X,q,$);let Y=[];for(let Z of J){let G=Q(Z),U=X.subarray(0,G);Y.push(typeof Z==="number"?U:Z.decode(U)),X=X.subarray(G)}return Y}}}function m$($,J){let Q=J*$.bytesLen;return{bytesLen:Q,encode:(q)=>{if(q.length!==J)throw new Error(`vecCoder.encode: wrong length=${q.length}. Expected: ${J}`);let X=new Uint8Array(Q);for(let Y=0,Z=0;Y<q.length;Y++){let G=$.encode(q[Y]);X.set(G,Z),G.fill(0),Z+=G.length}return X},decode:(q)=>{v(q,Q);let X=[];for(let Y=0;Y<q.length;Y+=$.bytesLen)X.push($.decode(q.subarray(Y,Y+$.bytesLen)));return X}}}function j$(...$){for(let J of $)if(Array.isArray(J))for(let Q of J)Q.fill(0);else J.fill(0)}function p0($){return(1<<$)-1}var dJ=Uint8Array.of();function l0($,J=dJ){if(v($),v(J),J.length>255)throw new Error("context should be less than 255 bytes");return w$(new Uint8Array([0,J.length]),J,$)}var s8=Uint8Array.from([6,9,96,134,72,1,101,3,4,2]);function pJ($,J=0){if(!$.oid||!c0($.oid.subarray(0,10),s8))throw new Error("hash.oid is invalid: expected NIST hash");let Q=$.outputLen*8/2;if(J>Q)throw new Error("Pre-hash security strength too low: "+Q+", required: "+J)}function r0($,J,Q=dJ){if(v(J),v(Q),Q.length>255)throw new Error("context should be less than 255 bytes");let q=$(J);return w$(new Uint8Array([1,Q.length]),Q,$.oid,q)}/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */var lJ=($)=>{let{newPoly:J,N:Q,Q:q,F:X,ROOT_OF_UNITY:Y,brvBits:Z,isKyber:G}=$,U=(z,V=q)=>{let w=z%V|0;return(w>=0?w|0:V+w|0)|0},K=(z,V=q)=>{let w=U(z,V)|0;return(w>V>>1?w-V|0:w)|0};function D(){let z=J(Q);for(let V=0;V<Q;V++){let w=b0(V,Z),A=BigInt(Y)**BigInt(w)%BigInt(q);z[V]=Number(A)|0}return z}let I=D(),H={add:(z,V)=>U((z|0)+(V|0))|0,sub:(z,V)=>U((z|0)-(V|0))|0,mul:(z,V)=>U((z|0)*(V|0))|0,inv:(z)=>{throw new Error("not implemented")}},S={N:Q,roots:I,invertButterflies:!0,skipStages:G?1:0,brp:!1},E=u0(H,{dit:!1,...S}),x=u0(H,{dit:!0,...S});return{mod:U,smod:K,nttZetas:I,NTT:{encode:(z)=>{return E(z)},decode:(z)=>{x(z);for(let V=0;V<z.length;V++)z[V]=U(X*z[V]);return z}},bitsCoder:(z,V)=>{let w=p0(z),A=z*(Q/8);return{bytesLen:A,encode:(f)=>{let P=new Uint8Array(A);for(let W=0,M=0,T=0,g=0;W<f.length;W++){M|=(V.encode(f[W])&w)<<T,T+=z;for(;T>=8;T-=8,M>>=8)P[g++]=M&p0(T)}return P},decode:(f)=>{let P=J(Q);for(let W=0,M=0,T=0,g=0;W<f.length;W++){M|=f[W]<<T,T+=8;for(;T>=z;T-=z,M>>=z)P[g++]=V.decode(M&w)}return P}}}}},rJ=($)=>(J,Q)=>{if(!Q)Q=$.blockLen;let q=new Uint8Array(J.length+2);q.set(J);let X=J.length,Y=new Uint8Array(Q),Z=$.create({}),G=0,U=0;return{stats:()=>({calls:G,xofs:U}),get:(K,D)=>{return q[X+0]=K,q[X+1]=D,Z.destroy(),Z=$.create({}).update(q),G++,()=>{return U++,Z.xofInto(Y)}},clean:()=>{Z.destroy(),j$(Y,q)}}},E0=rJ(bJ),k0=rJ(X$);/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */function aJ($){if(d0($),$.externalMu!==void 0)n$($.externalMu,"opts.externalMu")}var b=256,v$=8380417,e8=1753,$Q=8347681,u$=13,a0=Math.floor((v$-1)/88)|0,n0=Math.floor((v$-1)/32)|0,i0={2:{K:4,L:4,D:u$,GAMMA1:131072,GAMMA2:a0,TAU:39,ETA:2,OMEGA:80},3:{K:6,L:5,D:u$,GAMMA1:524288,GAMMA2:n0,TAU:49,ETA:4,OMEGA:55},5:{K:8,L:7,D:u$,GAMMA1:524288,GAMMA2:n0,TAU:60,ETA:2,OMEGA:75}},U$=($)=>new Int32Array($),{mod:b$,smod:T0,NTT:n,bitsCoder:JQ}=lJ({N:b,Q:v$,F:$Q,ROOT_OF_UNITY:e8,newPoly:U$,isKyber:!1,brvBits:8}),nJ=($)=>$,U0=($,J=nJ,Q=nJ)=>JQ($,{encode:(q)=>J(Q(q)),decode:(q)=>Q(J(q))}),L$=($,J)=>{for(let Q=0;Q<$.length;Q++)$[Q]=b$($[Q]+J[Q]);return $},iJ=($,J)=>{for(let Q=0;Q<$.length;Q++)$[Q]=b$($[Q]-J[Q]);return $},QQ=($)=>{for(let J=0;J<b;J++)$[J]<<=u$;return $},G0=($,J)=>{for(let Q=0;Q<b;Q++)if(Math.abs(T0($[Q]))>=J)return!0;return!1},P$=($,J)=>{let Q=U$(b);for(let q=0;q<$.length;q++)Q[q]=b$($[q]*J[q]);return Q};function H0($){let J=U$(b);for(let Q=0;Q<b;){let q=$();if(q.length%3)throw new Error("RejNTTPoly: unaligned block");for(let X=0;Q<b&&X<=q.length-3;X+=3){let Y=(q[X+0]|q[X+1]<<8|q[X+2]<<16)&8388607;if(Y<v$)J[Q++]=Y}}return J}function o0($){let{K:J,L:Q,GAMMA1:q,GAMMA2:X,TAU:Y,ETA:Z,OMEGA:G}=$,{CRH_BYTES:U,TR_BYTES:K,C_TILDE_BYTES:D,XOF128:I,XOF256:H,securityLevel:S}=$;if(![2,4].includes(Z))throw new Error("Wrong ETA");if(![131072,524288].includes(q))throw new Error("Wrong GAMMA1");if(![a0,n0].includes(X))throw new Error("Wrong GAMMA2");let E=Y*Z,x=(N)=>{let k=b$(N),R=T0(k,2*X)|0;if(k-R===v$-1)return{r1:0,r0:R-1|0};return{r1:Math.floor((k-R)/(2*X))|0,r0:R}},O=(N)=>x(N).r1,C=(N)=>x(N).r0,z=(N,k)=>{return N<=X||N>v$-X||N===v$-X&&k===0?0:1},V=(N,k)=>{let R=Math.floor((v$-1)/(2*X)),{r1:j,r0:L}=x(k);if(N===1)return L>0?b$(j+1,R)|0:b$(j-1,R)|0;return j|0},w=(N)=>{let k=b$(N),R=T0(k,2**u$)|0;return{r1:Math.floor((k-R)/2**u$)|0,r0:R}},A={bytesLen:G+J,encode:(N)=>{if(N===!1)throw new Error("hint.encode: hint is false");let k=new Uint8Array(G+J);for(let R=0,j=0;R<J;R++){for(let L=0;L<b;L++)if(N[R][L]!==0)k[j++]=L;k[G+R]=j}return k},decode:(N)=>{let k=[],R=0;for(let j=0;j<J;j++){let L=U$(b);if(N[G+j]<R||N[G+j]>G)return!1;for(let F=R;F<N[G+j];F++){if(F>R&&N[F]<=N[F-1])return!1;L[N[F]]=1}R=N[G+j],k.push(L)}for(let j=R;j<G;j++)if(N[j]!==0)return!1;return k}},f=U0(Z===2?3:4,(N)=>Z-N,(N)=>{if(!(-Z<=N&&N<=Z))throw new Error(`malformed key s1/s3 ${N} outside of ETA range [${-Z}, ${Z}]`);return N}),P=U0(13,(N)=>(1<<u$-1)-N),W=U0(10),M=U0(q===131072?18:20,(N)=>T0(q-N)),T=U0(X===a0?6:4),g=m$(T,J),y=Z0("publicKey",32,m$(W,J)),_=Z0("secretKey",32,32,K,m$(f,Q),m$(f,J),m$(P,J)),u=Z0("signature",D,m$(M,Q),A),c=Z===2?(N)=>N<15?2-N%5:!1:(N)=>N<9?4-N:!1;function K$(N){let k=U$(b);for(let R=0;R<b;){let j=N();for(let L=0;R<b&&L<j.length;L+=1){let F=c(j[L]&15),t=c(j[L]>>4&15);if(F!==!1)k[R++]=F;if(R<b&&t!==!1)k[R++]=t}}return k}let V$=(N)=>{let k=U$(b),R=X$.create({}).update(N),j=new Uint8Array(X$.blockLen);R.xofInto(j);let L=j.slice(0,8);for(let F=b-Y,t=8,q$=0,d=0;F<b;F++){let p=F+1;for(;p>F;){if(p=j[t++],t<X$.blockLen)continue;R.xofInto(j),t=0}if(k[F]=k[p],k[p]=1-((L[q$]>>d++&1)<<1),d>=8)q$++,d=0}return k},G$=(N)=>{let k=U$(b),R=U$(b);for(let j=0;j<N.length;j++){let{r0:L,r1:F}=w(N[j]);k[j]=L,R[j]=F}return{r0:k,r1:R}},F$=(N,k)=>{for(let R=0;R<b;R++)N[R]=V(k[R],N[R]);return N},c$=(N,k)=>{let R=U$(b),j=0;for(let L=0;L<b;L++){let F=z(N[L],k[L]);R[L]=F,j+=F}return{v:R,cnt:j}},d$=32,o$=Z0("seed",32,64,32),D$={info:{type:"internal-ml-dsa"},lengths:{secretKey:_.bytesLen,publicKey:y.bytesLen,seed:32,signature:u.bytesLen,signRand:d$},keygen:(N)=>{let k=new Uint8Array(34),R=N===void 0;if(R)N=h0(32);if(v(N,32,"seed"),k.set(N),R)j$(N);k[32]=J,k[33]=Q;let[j,L,F]=o$.decode(X$(k,{dkLen:o$.bytesLen})),t=H(L),q$=[];for(let B=0;B<Q;B++)q$.push(K$(t.get(B&255,B>>8&255)));let d=[];for(let B=Q;B<Q+J;B++)d.push(K$(t.get(B&255,B>>8&255)));let p=q$.map((B)=>n.encode(B.slice())),l=[],s=[],C$=I(j),a=U$(b);for(let B=0;B<J;B++){j$(a);for(let Z$=0;Z$<Q;Z$++){let M$=H0(C$.get(Z$,B));L$(a,P$(M$,p[Z$]))}n.decode(a);let{r0:z$,r1:Y$}=G$(L$(a,d[B]));l.push(z$),s.push(Y$)}let O$=y.encode([j,s]),E$=X$(O$,{dkLen:K}),p$=_.encode([j,F,E$,q$,d,l]);return C$.clean(),t.clean(),j$(j,L,F,q$,d,p,a,l,s,E$,k),{publicKey:O$,secretKey:p$}},getPublicKey:(N)=>{let[k,R,j,L,F,t]=_.decode(N),q$=I(k),d=L.map((s)=>n.encode(s.slice())),p=[],l=U$(b);for(let s=0;s<J;s++){l.fill(0);for(let a=0;a<Q;a++){let O$=H0(q$.get(a,s));L$(l,P$(O$,d[a]))}n.decode(l),L$(l,F[s]);let{r1:C$}=G$(l);p.push(C$)}return q$.clean(),j$(l,d,t,L,F),y.encode([k,p])},sign:(N,k,R={})=>{C0(R),aJ(R);let{extraEntropy:j,externalMu:L=!1}=R,[F,t,q$,d,p,l]=_.decode(k),s=[],C$=I(F);for(let B=0;B<J;B++){let z$=[];for(let Y$=0;Y$<Q;Y$++)z$.push(H0(C$.get(Y$,B)));s.push(z$)}C$.clean();for(let B=0;B<Q;B++)n.encode(d[B]);for(let B=0;B<J;B++)n.encode(p[B]),n.encode(l[B]);let a=L?N:X$.create({dkLen:U}).update(q$).update(N).digest(),O$=j===!1?new Uint8Array(32):j===void 0?h0(d$):j;v(O$,32,"extraEntropy");let E$=X$.create({dkLen:U}).update(t).update(O$).update(a).digest();v(E$,U);let p$=H(E$,M.bytesLen);$:for(let B=0;;){let z$=[];for(let m=0;m<Q;m++,B++)z$.push(M.decode(p$.get(B&255,B>>8)()));let Y$=z$.map((m)=>n.encode(m.slice())),Z$=[];for(let m=0;m<J;m++){let s$=U$(b);for(let S$=0;S$<Q;S$++)L$(s$,P$(s[m][S$],Y$[S$]));n.decode(s$),Z$.push(s$)}let M$=Z$.map((m)=>m.map(O)),t$=X$.create({dkLen:D}).update(a).update(g.encode(M$)).digest(),z0=n.encode(V$(t$)),K0=d.map((m)=>P$(m,z0));for(let m=0;m<Q;m++)if(L$(n.decode(K0[m]),z$[m]),G0(K0[m],q-E))continue $;let ZJ=0,v0=[];for(let m=0;m<J;m++){let s$=n.decode(P$(p[m],z0)),S$=iJ(Z$[m],s$).map(C);if(G0(S$,X-E))continue $;let UJ=n.decode(P$(l[m],z0));if(G0(UJ,X))continue $;L$(S$,UJ);let GJ=c$(S$,M$[m]);v0.push(GJ.v),ZJ+=GJ.cnt}if(ZJ>G)continue;p$.clean();let P8=u.encode([t$,K0,v0]);return j$(t$,K0,v0,z0,M$,Z$,Y$,z$,E$,a,d,p,l,...s),P8}throw new Error("Unreachable code path reached, report this error")},verify:(N,k,R,j={})=>{aJ(j);let{externalMu:L=!1}=j,[F,t]=y.decode(R),q$=X$(R,{dkLen:K});if(N.length!==u.bytesLen)return!1;let[d,p,l]=u.decode(N);if(l===!1)return!1;for(let B=0;B<Q;B++)if(G0(p[B],q-E))return!1;let s=L?k:X$.create({dkLen:U}).update(q$).update(k).digest(),C$=n.encode(V$(d)),a=p.map((B)=>B.slice());for(let B=0;B<Q;B++)n.encode(a[B]);let O$=[],E$=I(F);for(let B=0;B<J;B++){let z$=P$(n.encode(QQ(t[B])),C$),Y$=U$(b);for(let M$=0;M$<Q;M$++){let t$=H0(E$.get(M$,B));L$(Y$,P$(t$,a[M$]))}let Z$=n.decode(iJ(Y$,z$));O$.push(F$(Z$,l[B]))}E$.clean();let p$=X$.create({dkLen:D}).update(s).update(g.encode(O$)).digest();for(let B of l)if(!(B.reduce((Y$,Z$)=>Y$+Z$,0)<=G))return!1;for(let B of p)if(G0(B,q-E))return!1;return c0(d,p$)}};return{info:{type:"ml-dsa"},internal:D$,securityLevel:S,keygen:D$.keygen,lengths:D$.lengths,getPublicKey:D$.getPublicKey,sign:(N,k,R={})=>{C0(R);let j=l0(N,R.context),L=D$.sign(j,k,R);return j$(j),L},verify:(N,k,R,j={})=>{return j0(j),D$.verify(N,l0(k,j.context),R)},prehash:(N)=>{return pJ(N,S),{info:{type:"hashml-dsa"},securityLevel:S,lengths:D$.lengths,keygen:D$.keygen,getPublicKey:D$.getPublicKey,sign:(k,R,j={})=>{C0(j);let L=r0(N,k,j.context),F=D$.sign(L,R,j);return j$(L),F},verify:(k,R,j,L={})=>{return j0(L),D$.verify(k,r0(N,R,L.context),j)}}}}}var oJ=o0({...i0[2],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:32,XOF128:E0,XOF256:k0,securityLevel:128}),tQ=o0({...i0[3],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:48,XOF128:E0,XOF256:k0,securityLevel:192}),sQ=o0({...i0[5],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:64,XOF128:E0,XOF256:k0,securityLevel:256});function tJ($,J,Q){return $&J^~$&Q}function sJ($,J,Q){return $&J^$&Q^J&Q}class B0{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor($,J,Q,q){this.blockLen=$,this.outputLen=J,this.padOffset=Q,this.isLE=q,this.buffer=new Uint8Array($),this.view=N0(this.buffer)}update($){r$(this),v($);let{view:J,buffer:Q,blockLen:q}=this,X=$.length;for(let Y=0;Y<X;){let Z=Math.min(q-this.pos,X-Y);if(Z===q){let G=N0($);for(;q<=X-Y;Y+=q)this.process(G,Y);continue}if(Q.set($.subarray(Y,Y+Z),this.pos),this.pos+=Z,Y+=Z,this.pos===q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){r$(this),W0($,this),this.finished=!0;let{buffer:J,view:Q,blockLen:q,isLE:X}=this,{pos:Y}=this;if(J[Y++]=128,I$(this.buffer.subarray(Y)),this.padOffset>q-Y)this.process(Q,0),Y=0;for(let D=Y;D<q;D++)J[D]=0;Q.setBigUint64(q-8,BigInt(this.length*8),X),this.process(Q,0);let Z=N0($),G=this.outputLen;if(G%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let U=G/4,K=this.get();if(U>K.length)throw new Error("_sha2: outputLen bigger than state");for(let D=0;D<U;D++)Z.setUint32(4*D,K[D],X)}digest(){let{buffer:$,outputLen:J}=this;this.digestInto($);let Q=$.slice(0,J);return this.destroy(),Q}_cloneInto($){$||=new this.constructor,$.set(...this.get());let{blockLen:J,buffer:Q,length:q,finished:X,destroyed:Y,pos:Z}=this;if($.destroyed=Y,$.finished=X,$.length=q,$.pos=Z,q%J)$.buffer.set(Q);return $}clone(){return this._cloneInto()}}var T$=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),B$=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),i=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),o=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]);var qQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),A$=new Uint32Array(64);class t0 extends B0{constructor($){super(64,$,8,!1)}get(){let{A:$,B:J,C:Q,D:q,E:X,F:Y,G:Z,H:G}=this;return[$,J,Q,q,X,Y,Z,G]}set($,J,Q,q,X,Y,Z,G){this.A=$|0,this.B=J|0,this.C=Q|0,this.D=q|0,this.E=X|0,this.F=Y|0,this.G=Z|0,this.H=G|0}process($,J){for(let D=0;D<16;D++,J+=4)A$[D]=$.getUint32(J,!1);for(let D=16;D<64;D++){let I=A$[D-15],H=A$[D-2],S=W$(I,7)^W$(I,18)^I>>>3,E=W$(H,17)^W$(H,19)^H>>>10;A$[D]=E+A$[D-7]+S+A$[D-16]|0}let{A:Q,B:q,C:X,D:Y,E:Z,F:G,G:U,H:K}=this;for(let D=0;D<64;D++){let I=W$(Z,6)^W$(Z,11)^W$(Z,25),H=K+I+tJ(Z,G,U)+qQ[D]+A$[D]|0,E=(W$(Q,2)^W$(Q,13)^W$(Q,22))+sJ(Q,q,X)|0;K=U,U=G,G=Z,Z=Y+H|0,Y=X,X=q,q=Q,Q=H+E|0}Q=Q+this.A|0,q=q+this.B|0,X=X+this.C|0,Y=Y+this.D|0,Z=Z+this.E|0,G=G+this.F|0,U=U+this.G|0,K=K+this.H|0,this.set(Q,q,X,Y,Z,G,U,K)}roundClean(){I$(A$)}destroy(){this.set(0,0,0,0,0,0,0,0),I$(this.buffer)}}class XQ extends t0{A=T$[0]|0;B=T$[1]|0;C=T$[2]|0;D=T$[3]|0;E=T$[4]|0;F=T$[5]|0;G=T$[6]|0;H=T$[7]|0;constructor(){super(32)}}class YQ extends t0{A=B$[0]|0;B=B$[1]|0;C=B$[2]|0;D=B$[3]|0;E=B$[4]|0;F=B$[5]|0;G=B$[6]|0;H=B$[7]|0;constructor(){super(28)}}var eJ=(()=>R0(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(($)=>BigInt($))))(),ZQ=(()=>eJ[0])(),UQ=(()=>eJ[1])(),x$=new Uint32Array(80),g$=new Uint32Array(80);class D0 extends B0{constructor($){super(128,$,16,!1)}get(){let{Ah:$,Al:J,Bh:Q,Bl:q,Ch:X,Cl:Y,Dh:Z,Dl:G,Eh:U,El:K,Fh:D,Fl:I,Gh:H,Gl:S,Hh:E,Hl:x}=this;return[$,J,Q,q,X,Y,Z,G,U,K,D,I,H,S,E,x]}set($,J,Q,q,X,Y,Z,G,U,K,D,I,H,S,E,x){this.Ah=$|0,this.Al=J|0,this.Bh=Q|0,this.Bl=q|0,this.Ch=X|0,this.Cl=Y|0,this.Dh=Z|0,this.Dl=G|0,this.Eh=U|0,this.El=K|0,this.Fh=D|0,this.Fl=I|0,this.Gh=H|0,this.Gl=S|0,this.Hh=E|0,this.Hl=x|0}process($,J){for(let z=0;z<16;z++,J+=4)x$[z]=$.getUint32(J),g$[z]=$.getUint32(J+=4);for(let z=16;z<80;z++){let V=x$[z-15]|0,w=g$[z-15]|0,A=_$(V,w,1)^_$(V,w,8)^F0(V,w,7),f=y$(V,w,1)^y$(V,w,8)^_0(V,w,7),P=x$[z-2]|0,W=g$[z-2]|0,M=_$(P,W,19)^q0(P,W,61)^F0(P,W,6),T=y$(P,W,19)^X0(P,W,61)^_0(P,W,6),g=LJ(f,T,g$[z-7],g$[z-16]),y=PJ(g,A,M,x$[z-7],x$[z-16]);x$[z]=y|0,g$[z]=g|0}let{Ah:Q,Al:q,Bh:X,Bl:Y,Ch:Z,Cl:G,Dh:U,Dl:K,Eh:D,El:I,Fh:H,Fl:S,Gh:E,Gl:x,Hh:O,Hl:C}=this;for(let z=0;z<80;z++){let V=_$(D,I,14)^_$(D,I,18)^q0(D,I,41),w=y$(D,I,14)^y$(D,I,18)^X0(D,I,41),A=D&H^~D&E,f=I&S^~I&x,P=vJ(C,w,f,UQ[z],g$[z]),W=AJ(P,O,V,A,ZQ[z],x$[z]),M=P|0,T=_$(Q,q,28)^q0(Q,q,34)^q0(Q,q,39),g=y$(Q,q,28)^X0(Q,q,34)^X0(Q,q,39),y=Q&X^Q&Z^X&Z,_=q&Y^q&G^Y&G;O=E|0,C=x|0,E=H|0,x=S|0,H=D|0,S=I|0,{h:D,l:I}=R$(U|0,K|0,W|0,M|0),U=Z|0,K=G|0,Z=X|0,G=Y|0,X=Q|0,Y=q|0;let u=SJ(M,g,_);Q=wJ(u,W,T,y),q=u|0}({h:Q,l:q}=R$(this.Ah|0,this.Al|0,Q|0,q|0)),{h:X,l:Y}=R$(this.Bh|0,this.Bl|0,X|0,Y|0),{h:Z,l:G}=R$(this.Ch|0,this.Cl|0,Z|0,G|0),{h:U,l:K}=R$(this.Dh|0,this.Dl|0,U|0,K|0),{h:D,l:I}=R$(this.Eh|0,this.El|0,D|0,I|0),{h:H,l:S}=R$(this.Fh|0,this.Fl|0,H|0,S|0),{h:E,l:x}=R$(this.Gh|0,this.Gl|0,E|0,x|0),{h:O,l:C}=R$(this.Hh|0,this.Hl|0,O|0,C|0),this.set(Q,q,X,Y,Z,G,U,K,D,I,H,S,E,x,O,C)}roundClean(){I$(x$,g$)}destroy(){I$(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class $8 extends D0{Ah=o[0]|0;Al=o[1]|0;Bh=o[2]|0;Bl=o[3]|0;Ch=o[4]|0;Cl=o[5]|0;Dh=o[6]|0;Dl=o[7]|0;Eh=o[8]|0;El=o[9]|0;Fh=o[10]|0;Fl=o[11]|0;Gh=o[12]|0;Gl=o[13]|0;Hh=o[14]|0;Hl=o[15]|0;constructor(){super(64)}}class GQ extends D0{Ah=i[0]|0;Al=i[1]|0;Bh=i[2]|0;Bl=i[3]|0;Ch=i[4]|0;Cl=i[5]|0;Dh=i[6]|0;Dl=i[7]|0;Eh=i[8]|0;El=i[9]|0;Fh=i[10]|0;Fl=i[11]|0;Gh=i[12]|0;Gl=i[13]|0;Hh=i[14]|0;Hl=i[15]|0;constructor(){super(48)}}var e=Uint32Array.from([2352822216,424955298,1944164710,2312950998,502970286,855612546,1738396948,1479516111,258812777,2077511080,2011393907,79989058,1067287976,1780299464,286451373,2446758561]),$$=Uint32Array.from([573645204,4230739756,2673172387,3360449730,596883563,1867755857,2520282905,1497426621,2519219938,2827943907,3193839141,1401305490,721525244,746961066,246885852,2177182882]);class DQ extends D0{Ah=e[0]|0;Al=e[1]|0;Bh=e[2]|0;Bl=e[3]|0;Ch=e[4]|0;Cl=e[5]|0;Dh=e[6]|0;Dl=e[7]|0;Eh=e[8]|0;El=e[9]|0;Fh=e[10]|0;Fl=e[11]|0;Gh=e[12]|0;Gl=e[13]|0;Hh=e[14]|0;Hl=e[15]|0;constructor(){super(28)}}class zQ extends D0{Ah=$$[0]|0;Al=$$[1]|0;Bh=$$[2]|0;Bl=$$[3]|0;Ch=$$[4]|0;Cl=$$[5]|0;Dh=$$[6]|0;Dl=$$[7]|0;Eh=$$[8]|0;El=$$[9]|0;Fh=$$[10]|0;Fl=$$[11]|0;Gh=$$[12]|0;Gl=$$[13]|0;Hh=$$[14]|0;Hl=$$[15]|0;constructor(){super(32)}}var J8=V0(()=>new $8,J0(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q$=BigInt(0),J$=BigInt(1),h$=BigInt(2),X8=BigInt(3),Y8=BigInt(4),Z8=BigInt(5),KQ=BigInt(7),U8=BigInt(8),WQ=BigInt(9),G8=BigInt(16);function h($,J){let Q=$%J;return Q>=Q$?Q:J+Q}function N$($,J,Q){let q=$;while(J-- >Q$)q*=q,q%=Q;return q}function Q8($,J){if($===Q$)throw new Error("invert: expected non-zero number");if(J<=Q$)throw new Error("invert: expected positive modulus, got "+J);let Q=h($,J),q=J,X=Q$,Y=J$,Z=J$,G=Q$;while(Q!==Q$){let K=q/Q,D=q%Q,I=X-Z*K,H=Y-G*K;q=Q,Q=D,X=Z,Y=G,Z=I,G=H}if(q!==J$)throw new Error("invert: does not exist");return h(X,J)}function s0($,J,Q){if(!$.eql($.sqr(J),Q))throw new Error("Cannot find square root")}function D8($,J){let Q=($.ORDER+J$)/Y8,q=$.pow(J,Q);return s0($,q,J),q}function NQ($,J){let Q=($.ORDER-Z8)/U8,q=$.mul(J,h$),X=$.pow(q,Q),Y=$.mul(J,X),Z=$.mul($.mul(Y,h$),X),G=$.mul(Y,$.sub(Z,$.ONE));return s0($,G,J),G}function VQ($){let J=w0($),Q=z8($),q=Q(J,J.neg(J.ONE)),X=Q(J,q),Y=Q(J,J.neg(q)),Z=($+KQ)/G8;return(G,U)=>{let K=G.pow(U,Z),D=G.mul(K,q),I=G.mul(K,X),H=G.mul(K,Y),S=G.eql(G.sqr(D),U),E=G.eql(G.sqr(I),U);K=G.cmov(K,D,S),D=G.cmov(H,I,E);let x=G.eql(G.sqr(D),U),O=G.cmov(K,D,x);return s0(G,O,U),O}}function z8($){if($<X8)throw new Error("sqrt is not defined for small field");let J=$-J$,Q=0;while(J%h$===Q$)J/=h$,Q++;let q=h$,X=w0($);while(q8(X,q)===1)if(q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(Q===1)return D8;let Y=X.pow(q,J),Z=(J+J$)/h$;return function G(U,K){if(U.is0(K))return K;if(q8(U,K)!==1)throw new Error("Cannot find square root");let D=Q,I=U.mul(U.ONE,Y),H=U.pow(K,J),S=U.pow(K,Z);while(!U.eql(H,U.ONE)){if(U.is0(H))return U.ZERO;let E=1,x=U.sqr(H);while(!U.eql(x,U.ONE))if(E++,x=U.sqr(x),E===D)throw new Error("Cannot find square root");let O=J$<<BigInt(D-E-1),C=U.pow(I,O);D=E,I=U.sqr(C),H=U.mul(H,I),S=U.mul(S,C)}return S}}function OQ($){if($%Y8===X8)return D8;if($%U8===Z8)return NQ;if($%G8===WQ)return VQ($);return z8($)}var K8=($,J)=>(h($,J)&J$)===J$,MQ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function W8($){let J={ORDER:"bigint",BYTES:"number",BITS:"number"},Q=MQ.reduce((q,X)=>{return q[X]="function",q},J);return Q0($,Q),$}function IQ($,J,Q){if(Q<Q$)throw new Error("invalid exponent, negatives unsupported");if(Q===Q$)return $.ONE;if(Q===J$)return J;let q=$.ONE,X=J;while(Q>Q$){if(Q&J$)q=$.mul(q,X);X=$.sqr(X),Q>>=J$}return q}function S0($,J,Q=!1){let q=new Array(J.length).fill(Q?$.ZERO:void 0),X=J.reduce((Z,G,U)=>{if($.is0(G))return Z;return q[U]=Z,$.mul(Z,G)},$.ONE),Y=$.inv(X);return J.reduceRight((Z,G,U)=>{if($.is0(G))return Z;return q[U]=$.mul(Z,q[U]),$.mul(Z,G)},Y),q}function q8($,J){let Q=($.ORDER-J$)/h$,q=$.pow(J,Q),X=$.eql(q,$.ONE),Y=$.eql(q,$.ZERO),Z=$.eql(q,$.neg($.ONE));if(!X&&!Y&&!Z)throw new Error("invalid Legendre symbol result");return X?1:Y?0:-1}function RQ($,J){if(J!==void 0)H$(J);let Q=J!==void 0?J:$.toString(2).length,q=Math.ceil(Q/8);return{nBitLength:Q,nByteLength:q}}class N8{ORDER;BITS;BYTES;isLE;ZERO=Q$;ONE=J$;_lengths;_sqrt;_mod;constructor($,J={}){if($<=Q$)throw new Error("invalid field: expected ORDER > 0, got "+$);let Q=void 0;if(this.isLE=!1,J!=null&&typeof J==="object"){if(typeof J.BITS==="number")Q=J.BITS;if(typeof J.sqrt==="function")this.sqrt=J.sqrt;if(typeof J.isLE==="boolean")this.isLE=J.isLE;if(J.allowedLengths)this._lengths=J.allowedLengths?.slice();if(typeof J.modFromBytes==="boolean")this._mod=J.modFromBytes}let{nBitLength:q,nByteLength:X}=RQ($,Q);if(X>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=$,this.BITS=q,this.BYTES=X,this._sqrt=void 0,Object.preventExtensions(this)}create($){return h($,this.ORDER)}isValid($){if(typeof $!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof $);return Q$<=$&&$<this.ORDER}is0($){return $===Q$}isValidNot0($){return!this.is0($)&&this.isValid($)}isOdd($){return($&J$)===J$}neg($){return h(-$,this.ORDER)}eql($,J){return $===J}sqr($){return h($*$,this.ORDER)}add($,J){return h($+J,this.ORDER)}sub($,J){return h($-J,this.ORDER)}mul($,J){return h($*J,this.ORDER)}pow($,J){return IQ(this,$,J)}div($,J){return h($*Q8(J,this.ORDER),this.ORDER)}sqrN($){return $*$}addN($,J){return $+J}subN($,J){return $-J}mulN($,J){return $*J}inv($){return Q8($,this.ORDER)}sqrt($){if(!this._sqrt)this._sqrt=OQ(this.ORDER);return this._sqrt(this,$)}toBytes($){return this.isLE?jJ($,this.BYTES):x0($,this.BYTES)}fromBytes($,J=!1){v($);let{_lengths:Q,BYTES:q,isLE:X,ORDER:Y,_mod:Z}=this;if(Q){if(!Q.includes($.length)||$.length>q)throw new Error("Field.fromBytes: expected "+Q+" bytes, got "+$.length);let U=new Uint8Array(q);U.set($,X?0:U.length-$.length),$=U}if($.length!==q)throw new Error("Field.fromBytes: expected "+q+" bytes, got "+$.length);let G=X?i$($):RJ($);if(Z)G=h(G,Y);if(!J){if(!this.isValid(G))throw new Error("invalid field element: outside of range 0..ORDER")}return G}invertBatch($){return S0(this,$)}cmov($,J,Q){return Q?J:$}}function w0($,J={}){return new N8($,J)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var L0=BigInt(0),QJ=BigInt(1);function V8($,J){let Q=J.negate();return $?Q:J}function P0($,J){let Q=S0($.Fp,J.map((q)=>q.Z));return J.map((q,X)=>$.fromAffine(q.toAffine(Q[X])))}function R8($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)}function e0($,J){R8($,J);let Q=Math.ceil(J/$)+1,q=2**($-1),X=2**$,Y=CJ($),Z=BigInt($);return{windows:Q,windowSize:q,mask:Y,maxNumber:X,shiftBy:Z}}function O8($,J,Q){let{windowSize:q,mask:X,maxNumber:Y,shiftBy:Z}=Q,G=Number($&X),U=$>>Z;if(G>q)G-=Y,U+=QJ;let K=J*q,D=K+Math.abs(G)-1,I=G===0,H=G<0,S=J%2!==0;return{nextN:U,offset:D,isZero:I,isNeg:H,isNegF:S,offsetF:K}}var $J=new WeakMap,j8=new WeakMap;function JJ($){return j8.get($)||1}function M8($){if($!==L0)throw new Error("invalid wNAF")}class qJ{BASE;ZERO;Fn;bits;constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,Q=this.ZERO){let q=$;while(J>L0){if(J&QJ)Q=Q.add(q);q=q.double(),J>>=QJ}return Q}precomputeWindow($,J){let{windows:Q,windowSize:q}=e0(J,this.bits),X=[],Y=$,Z=Y;for(let G=0;G<Q;G++){Z=Y,X.push(Z);for(let U=1;U<q;U++)Z=Z.add(Y),X.push(Z);Y=Z.double()}return X}wNAF($,J,Q){if(!this.Fn.isValid(Q))throw new Error("invalid scalar");let q=this.ZERO,X=this.BASE,Y=e0($,this.bits);for(let Z=0;Z<Y.windows;Z++){let{nextN:G,offset:U,isZero:K,isNeg:D,isNegF:I,offsetF:H}=O8(Q,Z,Y);if(Q=G,K)X=X.add(V8(I,J[H]));else q=q.add(V8(D,J[U]))}return M8(Q),{p:q,f:X}}wNAFUnsafe($,J,Q,q=this.ZERO){let X=e0($,this.bits);for(let Y=0;Y<X.windows;Y++){if(Q===L0)break;let{nextN:Z,offset:G,isZero:U,isNeg:K}=O8(Q,Y,X);if(Q=Z,U)continue;else{let D=J[G];q=q.add(K?D.negate():D)}}return M8(Q),q}getPrecomputes($,J,Q){let q=$J.get(J);if(!q){if(q=this.precomputeWindow(J,$),$!==1){if(typeof Q==="function")q=Q(q);$J.set(J,q)}}return q}cached($,J,Q){let q=JJ($);return this.wNAF(q,this.getPrecomputes(q,$,Q),J)}unsafe($,J,Q,q){let X=JJ($);if(X===1)return this._unsafeLadder($,J,q);return this.wNAFUnsafe(X,this.getPrecomputes(X,$,Q),J,q)}createCache($,J){R8(J,this.bits),j8.set($,J),$J.delete($)}hasCache($){return JJ($)!==1}}function I8($,J,Q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return W8(J),J}else return w0($,{isLE:Q})}function C8($,J,Q={},q){if(q===void 0)q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let U of["p","n","h"]){let K=J[U];if(!(typeof K==="bigint"&&K>L0))throw new Error(`CURVE.${U} must be positive bigint`)}let X=I8(J.p,Q.Fp,q),Y=I8(J.n,Q.Fn,q),G=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let U of G)if(!X.isValid(J[U]))throw new Error(`CURVE.${U} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:X,Fn:Y}}function E8($,J){return function Q(q){let X=$(q);return{secretKey:X,publicKey:J(X)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var f$=BigInt(0),r=BigInt(1),XJ=BigInt(2),jQ=BigInt(8);function CQ($,J,Q,q){let X=$.sqr(Q),Y=$.sqr(q),Z=$.add($.mul(J.a,X),Y),G=$.add($.ONE,$.mul(J.d,$.mul(X,Y)));return $.eql(Z,G)}function k8($,J={}){let Q=C8("edwards",$,J,J.FpFnLE),{Fp:q,Fn:X}=Q,Y=Q.CURVE,{h:Z}=Y;Q0(J,{},{uvRatio:"function"});let G=XJ<<BigInt(X.BYTES*8)-r,U=(O)=>q.create(O),K=J.uvRatio||((O,C)=>{try{return{isValid:!0,value:q.sqrt(q.div(O,C))}}catch(z){return{isValid:!1,value:f$}}});if(!CQ(q,Y,Y.Gx,Y.Gy))throw new Error("bad curve params: generator point");function D(O,C,z=!1){let V=z?r:f$;return g0("coordinate "+O,C,V,G),C}function I(O){if(!(O instanceof E))throw new Error("EdwardsPoint expected")}let H=f0((O,C)=>{let{X:z,Y:V,Z:w}=O,A=O.is0();if(C==null)C=A?jQ:q.inv(w);let f=U(z*C),P=U(V*C),W=q.mul(w,C);if(A)return{x:f$,y:r};if(W!==r)throw new Error("invZ was invalid");return{x:f,y:P}}),S=f0((O)=>{let{a:C,d:z}=Y;if(O.is0())throw new Error("bad point: ZERO");let{X:V,Y:w,Z:A,T:f}=O,P=U(V*V),W=U(w*w),M=U(A*A),T=U(M*M),g=U(P*C),y=U(M*U(g+W)),_=U(T+U(z*U(P*W)));if(y!==_)throw new Error("bad point: equation left != right (1)");let u=U(V*w),c=U(A*f);if(u!==c)throw new Error("bad point: equation left != right (2)");return!0});class E{static BASE=new E(Y.Gx,Y.Gy,r,U(Y.Gx*Y.Gy));static ZERO=new E(f$,r,r,f$);static Fp=q;static Fn=X;X;Y;Z;T;constructor(O,C,z,V){this.X=D("x",O),this.Y=D("y",C),this.Z=D("z",z,!0),this.T=D("t",V),Object.freeze(this)}static CURVE(){return Y}static fromAffine(O){if(O instanceof E)throw new Error("extended point not allowed");let{x:C,y:z}=O||{};return D("x",C),D("y",z),new E(C,z,r,U(C*z))}static fromBytes(O,C=!1){let z=q.BYTES,{a:V,d:w}=Y;O=M0(v(O,z,"point")),n$(C,"zip215");let A=M0(O),f=O[z-1];A[z-1]=f&-129;let P=i$(A),W=C?G:q.ORDER;g0("point.y",P,f$,W);let M=U(P*P),T=U(M-r),g=U(w*M-V),{isValid:y,value:_}=K(T,g);if(!y)throw new Error("bad point: invalid y coordinate");let u=(_&r)===r,c=(f&128)!==0;if(!C&&_===f$&&c)throw new Error("bad point: x=0 and x_0=1");if(c!==u)_=U(-_);return E.fromAffine({x:_,y:P})}static fromHex(O,C=!1){return E.fromBytes(e$(O),C)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(O=8,C=!0){if(x.createCache(this,O),!C)this.multiply(XJ);return this}assertValidity(){S(this)}equals(O){I(O);let{X:C,Y:z,Z:V}=this,{X:w,Y:A,Z:f}=O,P=U(C*f),W=U(w*V),M=U(z*f),T=U(A*V);return P===W&&M===T}is0(){return this.equals(E.ZERO)}negate(){return new E(U(-this.X),this.Y,this.Z,U(-this.T))}double(){let{a:O}=Y,{X:C,Y:z,Z:V}=this,w=U(C*C),A=U(z*z),f=U(XJ*U(V*V)),P=U(O*w),W=C+z,M=U(U(W*W)-w-A),T=P+A,g=T-f,y=P-A,_=U(M*g),u=U(T*y),c=U(M*y),K$=U(g*T);return new E(_,u,K$,c)}add(O){I(O);let{a:C,d:z}=Y,{X:V,Y:w,Z:A,T:f}=this,{X:P,Y:W,Z:M,T}=O,g=U(V*P),y=U(w*W),_=U(f*z*T),u=U(A*M),c=U((V+w)*(P+W)-g-y),K$=u-_,V$=u+_,G$=U(y-C*g),F$=U(c*K$),c$=U(V$*G$),d$=U(c*G$),o$=U(K$*V$);return new E(F$,c$,o$,d$)}subtract(O){return this.add(O.negate())}multiply(O){if(!X.isValidNot0(O))throw new Error("invalid scalar: expected 1 <= sc < curve.n");let{p:C,f:z}=x.cached(this,O,(V)=>P0(E,V));return P0(E,[C,z])[0]}multiplyUnsafe(O,C=E.ZERO){if(!X.isValid(O))throw new Error("invalid scalar: expected 0 <= sc < curve.n");if(O===f$)return E.ZERO;if(this.is0()||O===r)return this;return x.unsafe(this,O,(z)=>P0(E,z),C)}isSmallOrder(){return this.multiplyUnsafe(Z).is0()}isTorsionFree(){return x.unsafe(this,Y.n).is0()}toAffine(O){return H(this,O)}clearCofactor(){if(Z===r)return this;return this.multiplyUnsafe(Z)}toBytes(){let{x:O,y:C}=this.toAffine(),z=q.toBytes(C);return z[z.length-1]|=O&r?128:0,z}toHex(){return a$(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}let x=new qJ(E,X.BITS);return E.BASE.precompute(8),E}function H8($,J,Q={}){if(typeof J!=="function")throw new Error('"hash" function param is required');Q0(Q,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});let{prehash:q}=Q,{BASE:X,Fp:Y,Fn:Z}=$,G=Q.randomBytes||$0,U=Q.adjustScalarBytes||((W)=>W),K=Q.domain||((W,M,T)=>{if(n$(T,"phflag"),M.length||T)throw new Error("Contexts/pre-hash are not supported");return W});function D(W){return Z.create(i$(W))}function I(W){let M=V.secretKey;v(W,V.secretKey,"secretKey");let T=v(J(W),2*M,"hashedSecretKey"),g=U(T.slice(0,M)),y=T.slice(M,2*M),_=D(g);return{head:g,prefix:y,scalar:_}}function H(W){let{head:M,prefix:T,scalar:g}=I(W),y=X.multiply(g),_=y.toBytes();return{head:M,prefix:T,scalar:g,point:y,pointBytes:_}}function S(W){return H(W).pointBytes}function E(W=Uint8Array.of(),...M){let T=w$(...M);return D(J(K(T,v(W,void 0,"context"),!!q)))}function x(W,M,T={}){if(W=v(W,void 0,"message"),q)W=q(W);let{prefix:g,scalar:y,pointBytes:_}=H(M),u=E(T.context,g,W),c=X.multiply(u).toBytes(),K$=E(T.context,c,_,W),V$=Z.create(u+K$*y);if(!Z.isValid(V$))throw new Error("sign failed: invalid s");let G$=w$(c,Z.toBytes(V$));return v(G$,V.signature,"result")}let O={zip215:!0};function C(W,M,T,g=O){let{context:y,zip215:_}=g,u=V.signature;if(W=v(W,u,"signature"),M=v(M,void 0,"message"),T=v(T,V.publicKey,"publicKey"),_!==void 0)n$(_,"zip215");if(q)M=q(M);let c=u/2,K$=W.subarray(0,c),V$=i$(W.subarray(c,u)),G$,F$,c$;try{G$=$.fromBytes(T,_),F$=$.fromBytes(K$,_),c$=X.multiplyUnsafe(V$)}catch(D$){return!1}if(!_&&G$.isSmallOrder())return!1;let d$=E(y,F$.toBytes(),G$.toBytes(),M);return F$.add(G$.multiplyUnsafe(d$)).subtract(c$).clearCofactor().is0()}let z=Y.BYTES,V={secretKey:z,publicKey:z,signature:2*z,seed:z};function w(W=G(V.seed)){return v(W,V.seed,"seed")}function A(W){return l$(W)&&W.length===Z.BYTES}function f(W,M){try{return!!$.fromBytes(W,M)}catch(T){return!1}}let P={getExtendedPublicKey:H,randomSecretKey:w,isValidSecretKey:A,isValidPublicKey:f,toMontgomery(W){let{y:M}=$.fromBytes(W),T=V.publicKey,g=T===32;if(!g&&T!==57)throw new Error("only defined for 25519 and 448");let y=g?Y.div(r+M,r-M):Y.div(M-r,M+r);return Y.toBytes(y)},toMontgomerySecret(W){let M=V.secretKey;v(W,M);let T=J(W.subarray(0,M));return U(T).subarray(0,M)}};return Object.freeze({keygen:E8(w,S),getPublicKey:S,sign:x,verify:C,utils:P,Point:$,lengths:V})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var EQ=BigInt(1),T8=BigInt(2);var kQ=BigInt(5),HQ=BigInt(8),YJ=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),TQ=(()=>({p:YJ,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:HQ,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function BQ($){let J=BigInt(10),Q=BigInt(20),q=BigInt(40),X=BigInt(80),Y=YJ,G=$*$%Y*$%Y,U=N$(G,T8,Y)*G%Y,K=N$(U,EQ,Y)*$%Y,D=N$(K,kQ,Y)*K%Y,I=N$(D,J,Y)*D%Y,H=N$(I,Q,Y)*I%Y,S=N$(H,q,Y)*H%Y,E=N$(S,X,Y)*S%Y,x=N$(E,X,Y)*S%Y,O=N$(x,J,Y)*D%Y;return{pow_p_5_8:N$(O,T8,Y)*$%Y,b2:G}}function SQ($){return $[0]&=248,$[31]&=127,$[31]|=64,$}var B8=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function wQ($,J){let Q=YJ,q=h(J*J*J,Q),X=h(q*q*J,Q),Y=BQ($*X).pow_p_5_8,Z=h($*q*Y,Q),G=h(J*Z*Z,Q),U=Z,K=h(Z*B8,Q),D=G===$,I=G===h(-$,Q),H=G===h(-$*B8,Q);if(D)Z=U;if(I||H)Z=K;if(K8(Z,Q))Z=h(-Z,Q);return{isValid:D||I,value:Z}}var LQ=k8(TQ,{uvRatio:wQ});function PQ($){return H8(LQ,J8,Object.assign({adjustScalarBytes:SQ},$))}var S8=PQ({});async function L8($){try{let J=$.proof;if(!Array.isArray(J))throw new Error("VC has no proofs or invalid format.");let Q={...$};delete Q.proof;let q=w8.default(Q);if(!q)throw new Error("Canonicalization failed during verification");let X=new TextEncoder().encode(q),Y=J.find((U)=>U.type==="Ed25519Signature2020"),Z=J.find((U)=>U.cryptosuite==="ml-dsa-44-2025"),G={ed25519:!1,pqc:!1};if(Y){let K=(Y.verificationMethod||"").split("#")[1],D=Y.proofValue;if(K&&D)G.ed25519=S8.verify(D,X,K)}if(Z){let K=(Z.verificationMethod||"").split("#")[1],D=Z.proofValue;if(K&&D){let I=Uint8Array.from(Buffer.from(D,"hex")),H=Uint8Array.from(Buffer.from(K,"hex"));G.pqc=oJ.verify(I,X,H)}}return{isValid:G.ed25519&&G.pqc,checks:G,decoded:Q}}catch(J){return{isValid:!1,checks:{ed25519:!1,pqc:!1},error:J.message}}}document.addEventListener("DOMContentLoaded",()=>{let $=document.getElementById("drop-zone"),J=document.getElementById("result-area");if(!$||!J)return;$.addEventListener("dragover",(Y)=>{Y.preventDefault(),$.classList.add("active")}),$.addEventListener("dragleave",()=>{$.classList.remove("active")}),$.addEventListener("drop",async(Y)=>{Y.preventDefault(),$.classList.remove("active");let Z=Y.dataTransfer?.files[0];if(Z)await q(Z)});let Q=document.getElementById("file-input");if(Q)Q.addEventListener("change",async(Y)=>{let Z=Y.target.files[0];if(Z)await q(Z)});async function q(Y){J.innerHTML='<div class="scanning">Reading VC file...</div>';try{let Z=await Y.text(),G=JSON.parse(Z);J.innerHTML='<div class="scanning">Verifying Signatures (Ed25519 + ML-DSA-44)...</div>',await new Promise((K)=>setTimeout(K,800));let U=await L8(G);X(U,G)}catch(Z){J.innerHTML=`<div class="error">Failed to parse VC: ${Z.message}</div>`}}function X(Y,Z){let G=Y.isValid,U=G?"#27ae60":"#c0392b",D=`
            <div style="border: 2px solid ${U}; padding: 2rem; border-radius: 8px; background: #fff;">
                <h2 style="color: ${U}; margin-top: 0; font-size: 2rem;">${G?"\uD83D\uDEE1️ VALID":"⚠️ INVALID"}</h2>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0;">
                    <div class="check-item ${Y.checks.ed25519?"pass":"fail"}">
                        <strong>Ed25519 (Classic)</strong>
                        <span>${Y.checks.ed25519?"P-256 Signature Verified":"Verification Failed"}</span>
                    </div>
                    <div class="check-item ${Y.checks.pqc?"pass":"fail"}">
                        <strong>ML-DSA-44 (Post-Quantum)</strong>
                        <span>${Y.checks.pqc?"Lattice-based Signature Verified":"Verification Failed"}</span>
                    </div>
                </div>

                <details style="margin-top: 1rem; border-top: 1px solid #eee; padding-top: 1rem;">
                    <summary style="cursor: pointer; color: #666;">View Raw VC Payload</summary>
                    <pre style="background: #f8f8f8; padding: 1rem; overflow: auto; text-align: left; font-size: 0.8rem;">${JSON.stringify(Z,null,2)}</pre>
                </details>
            </div>
        `;J.innerHTML=D}});
