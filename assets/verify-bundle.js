var v8=Object.create;var{getPrototypeOf:A8,defineProperty:DJ,getOwnPropertyNames:g8}=Object;var x8=Object.prototype.hasOwnProperty;var f8=($,J,Q)=>{Q=$!=null?v8(A8($)):{};let q=J||!$||!$.__esModule?DJ(Q,"default",{value:$,enumerable:!0}):Q;for(let X of g8($))if(!x8.call(q,X))DJ(q,X,{get:()=>$[X],enumerable:!0});return q};var F8=($,J)=>()=>(J||$((J={exports:{}}).exports,J),J.exports);var KJ=F8((AQ,zJ)=>{zJ.exports=function $(J){if(typeof J==="number"&&isNaN(J))throw new Error("NaN is not allowed");if(typeof J==="number"&&!isFinite(J))throw new Error("Infinity is not allowed");if(J===null||typeof J!=="object")return JSON.stringify(J);if(J.toJSON instanceof Function)return $(J.toJSON());if(Array.isArray(J))return`[${J.reduce((X,Y,Z)=>{return`${X}${Z===0?"":","}${$(Y===void 0||typeof Y==="symbol"?null:Y)}`},"")}]`;return`{${Object.keys(J).sort().reduce((q,X)=>{if(J[X]===void 0||typeof J[X]==="symbol")return q;let Y=q.length===0?"":",";return`${q}${Y}${$(X)}:${$(J[X])}`},"")}}`}});var w8=f8(KJ(),1);/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function l$($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function H$($,J=""){if(!Number.isSafeInteger($)||$<0){let Q=J&&`"${J}" `;throw new Error(`${Q}expected integer >= 0, got ${$}`)}}function v($,J,Q=""){let q=l$($),X=$?.length,Y=J!==void 0;if(!q||Y&&X!==J){let Z=Q&&`"${Q}" `,U=Y?` of length ${J}`:"",G=q?`length=${X}`:`type=${typeof $}`;throw new Error(Z+"expected Uint8Array"+U+", got "+G)}return $}function r$($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function W0($,J){v($,void 0,"digestInto() output");let Q=J.outputLen;if($.length<Q)throw new Error('"digestInto() output" expected to be of length >='+Q)}function NJ($){return new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4))}function R$(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function N0($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function W$($,J){return $<<32-J|$>>>J}var _8=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function y8($){return $<<24&4278190080|$<<8&16711680|$>>>8&65280|$>>>24&255}function m8($){for(let J=0;J<$.length;J++)$[J]=y8($[J]);return $}var A0=_8?($)=>$:m8,OJ=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),b8=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0"));function a$($){if(v($),OJ)return $.toHex();let J="";for(let Q=0;Q<$.length;Q++)J+=b8[$[Q]];return J}var k$={_0:48,_9:57,A:65,F:70,a:97,f:102};function WJ($){if($>=k$._0&&$<=k$._9)return $-k$._0;if($>=k$.A&&$<=k$.F)return $-(k$.A-10);if($>=k$.a&&$<=k$.f)return $-(k$.a-10);return}function e$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(OJ)return Uint8Array.fromHex($);let J=$.length,Q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);let q=new Uint8Array(Q);for(let X=0,Y=0;X<Q;X++,Y+=2){let Z=WJ($.charCodeAt(Y)),U=WJ($.charCodeAt(Y+1));if(Z===void 0||U===void 0){let G=$[Y]+$[Y+1];throw new Error('hex string expected, got non-hex character "'+G+'" at index '+Y)}q[X]=Z*16+U}return q}function w$(...$){let J=0;for(let q=0;q<$.length;q++){let X=$[q];v(X),J+=X.length}let Q=new Uint8Array(J);for(let q=0,X=0;q<$.length;q++){let Y=$[q];Q.set(Y,X),X+=Y.length}return Q}function O0($,J={}){let Q=(X,Y)=>$(Y).update(X).digest(),q=$(void 0);return Q.outputLen=q.outputLen,Q.blockLen=q.blockLen,Q.create=(X)=>$(X),Object.assign(Q,J),Object.freeze(Q)}function $0($=32){let J=typeof globalThis==="object"?globalThis.crypto:null;if(typeof J?.getRandomValues!=="function")throw new Error("crypto.getRandomValues must be defined");return J.getRandomValues(new Uint8Array($))}var J0=($)=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,$])});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var MJ=BigInt(0),VJ=BigInt(1);function n$($,J=""){if(typeof $!=="boolean"){let Q=J&&`"${J}" `;throw new Error(Q+"expected boolean, got type="+typeof $)}return $}function u8($){if(typeof $==="bigint"){if(!V0($))throw new Error("positive bigint expected, got "+$)}else H$($);return $}function RJ($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?MJ:BigInt("0x"+$)}function IJ($){return RJ(a$($))}function i$($){return RJ(a$(M0(v($)).reverse()))}function g0($,J){H$(J),$=u8($);let Q=e$($.toString(16).padStart(J*2,"0"));if(Q.length!==J)throw new Error("number too large");return Q}function jJ($,J){return g0($,J).reverse()}function M0($){return Uint8Array.from($)}var V0=($)=>typeof $==="bigint"&&MJ<=$;function h8($,J,Q){return V0($)&&V0(J)&&V0(Q)&&J<=$&&$<Q}function x0($,J,Q,q){if(!h8(J,Q,q))throw new Error("expected valid "+$+": "+Q+" <= n < "+q+", got "+J)}var CJ=($)=>(VJ<<BigInt($))-VJ;function Q0($,J={},Q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function q(Y,Z,U){let G=$[Y];if(U&&G===void 0)return;let K=typeof G;if(K!==Z||G===null)throw new Error(`param "${Y}" is invalid: expected ${Z}, got ${K}`)}let X=(Y,Z)=>Object.entries(Y).forEach(([U,G])=>q(U,G,Z));X(J,!1),X(Q,!0)}function f0($){let J=new WeakMap;return(Q,...q)=>{let X=J.get(Q);if(X!==void 0)return X;let Y=$(Q,...q);return J.set(Q,Y),Y}}var R0=BigInt(4294967295),EJ=BigInt(32);function c8($,J=!1){if(J)return{h:Number($&R0),l:Number($>>EJ&R0)};return{h:Number($>>EJ&R0)|0,l:Number($&R0)|0}}function I0($,J=!1){let Q=$.length,q=new Uint32Array(Q),X=new Uint32Array(Q);for(let Y=0;Y<Q;Y++){let{h:Z,l:U}=c8($[Y],J);[q[Y],X[Y]]=[Z,U]}return[q,X]}var F0=($,J,Q)=>$>>>Q,_0=($,J,Q)=>$<<32-Q|J>>>Q,_$=($,J,Q)=>$>>>Q|J<<32-Q,y$=($,J,Q)=>$<<32-Q|J>>>Q,q0=($,J,Q)=>$<<64-Q|J>>>Q-32,X0=($,J,Q)=>$>>>Q-32|J<<64-Q;var kJ=($,J,Q)=>$<<Q|J>>>32-Q,HJ=($,J,Q)=>J<<Q|$>>>32-Q,TJ=($,J,Q)=>J<<Q-32|$>>>64-Q,BJ=($,J,Q)=>$<<Q-32|J>>>64-Q;function I$($,J,Q,q){let X=(J>>>0)+(q>>>0);return{h:$+Q+(X/4294967296|0)|0,l:X|0}}var SJ=($,J,Q)=>($>>>0)+(J>>>0)+(Q>>>0),wJ=($,J,Q,q)=>J+Q+q+($/4294967296|0)|0,LJ=($,J,Q,q)=>($>>>0)+(J>>>0)+(Q>>>0)+(q>>>0),PJ=($,J,Q,q,X)=>J+Q+q+X+($/4294967296|0)|0,vJ=($,J,Q,q,X)=>($>>>0)+(J>>>0)+(Q>>>0)+(q>>>0)+(X>>>0),AJ=($,J,Q,q,X,Y)=>J+Q+q+X+Y+($/4294967296|0)|0;var p8=BigInt(0),Y0=BigInt(1),l8=BigInt(2),r8=BigInt(7),a8=BigInt(256),n8=BigInt(113),fJ=[],FJ=[],_J=[];for(let $=0,J=Y0,Q=1,q=0;$<24;$++){[Q,q]=[q,(2*Q+3*q)%5],fJ.push(2*(5*q+Q)),FJ.push(($+1)*($+2)/2%64);let X=p8;for(let Y=0;Y<7;Y++)if(J=(J<<Y0^(J>>r8)*n8)%a8,J&l8)X^=Y0<<(Y0<<BigInt(Y))-Y0;_J.push(X)}var yJ=I0(_J,!0),i8=yJ[0],o8=yJ[1],gJ=($,J,Q)=>Q>32?TJ($,J,Q):kJ($,J,Q),xJ=($,J,Q)=>Q>32?BJ($,J,Q):HJ($,J,Q);function t8($,J=24){let Q=new Uint32Array(10);for(let q=24-J;q<24;q++){for(let Z=0;Z<10;Z++)Q[Z]=$[Z]^$[Z+10]^$[Z+20]^$[Z+30]^$[Z+40];for(let Z=0;Z<10;Z+=2){let U=(Z+8)%10,G=(Z+2)%10,K=Q[G],D=Q[G+1],V=gJ(K,D,1)^Q[U],k=xJ(K,D,1)^Q[U+1];for(let S=0;S<50;S+=10)$[Z+S]^=V,$[Z+S+1]^=k}let X=$[2],Y=$[3];for(let Z=0;Z<24;Z++){let U=FJ[Z],G=gJ(X,Y,U),K=xJ(X,Y,U),D=fJ[Z];X=$[D],Y=$[D+1],$[D]=G,$[D+1]=K}for(let Z=0;Z<50;Z+=10){for(let U=0;U<10;U++)Q[U]=$[Z+U];for(let U=0;U<10;U++)$[Z+U]^=~Q[(U+2)%10]&Q[(U+4)%10]}$[0]^=i8[q],$[1]^=o8[q]}R$(Q)}class y0{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor($,J,Q,q=!1,X=24){if(this.blockLen=$,this.suffix=J,this.outputLen=Q,this.enableXOF=q,this.rounds=X,H$(Q,"outputLen"),!(0<$&&$<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=NJ(this.state)}clone(){return this._cloneInto()}keccak(){A0(this.state32),t8(this.state32,this.rounds),A0(this.state32),this.posOut=0,this.pos=0}update($){r$(this),v($);let{blockLen:J,state:Q}=this,q=$.length;for(let X=0;X<q;){let Y=Math.min(J-this.pos,q-X);for(let Z=0;Z<Y;Z++)Q[this.pos++]^=$[X++];if(this.pos===J)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:$,suffix:J,pos:Q,blockLen:q}=this;if($[Q]^=J,(J&128)!==0&&Q===q-1)this.keccak();$[q-1]^=128,this.keccak()}writeInto($){r$(this,!1),v($),this.finish();let J=this.state,{blockLen:Q}=this;for(let q=0,X=$.length;q<X;){if(this.posOut>=Q)this.keccak();let Y=Math.min(Q-this.posOut,X-q);$.set(J.subarray(this.posOut,this.posOut+Y),q),this.posOut+=Y,q+=Y}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return H$($),this.xofInto(new Uint8Array($))}digestInto($){if(W0($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,R$(this.state)}_cloneInto($){let{blockLen:J,suffix:Q,outputLen:q,rounds:X,enableXOF:Y}=this;return $||=new y0(J,Q,q,Y,X),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=X,$.suffix=Q,$.outputLen=q,$.enableXOF=Y,$.destroyed=this.destroyed,$}}var mJ=($,J,Q,q={})=>O0((X={})=>new y0(J,$,X.dkLen===void 0?Q:X.dkLen,!0),q),bJ=mJ(31,168,16,J0(11)),X$=mJ(31,136,32,J0(12));function m0($){if(!Number.isSafeInteger($)||$<0||$>4294967295)throw new Error("wrong u32 integer:"+$);return $}function hJ($){return m0($),($&$-1)===0&&$!==0}function b0($,J){m0($);let Q=0;for(let q=0;q<J;q++,$>>>=1)Q=Q<<1|$&1;return Q}function cJ($){return m0($),31-Math.clz32($)}function uJ($){let J=$.length;if(J<2||!hJ(J))throw new Error("n must be a power of 2 and greater than 1. Got "+J);let Q=cJ(J);for(let q=0;q<J;q++){let X=b0(q,Q);if(q<X){let Y=$[q];$[q]=$[X],$[X]=Y}}return $}var u0=($,J)=>{let{N:Q,roots:q,dit:X,invertButterflies:Y=!1,skipStages:Z=0,brp:U=!0}=J,G=cJ(Q);if(!hJ(Q))throw new Error("FFT: Polynomial size should be power of two");let K=X!==Y;return(D)=>{if(D.length!==Q)throw new Error("FFT: wrong Polynomial length");if(X&&U)uJ(D);for(let V=0,k=1;V<G-Z;V++){let S=X?V+1+Z:G-V,E=1<<S,g=E>>1,M=Q>>S;for(let C=0;C<Q;C+=E)for(let z=0,O=k++;z<g;z++){let w=Y?X?Q-O:O:z*M,A=C+z,f=C+z+g,P=q[w],W=D[f],R=D[A];if(K){let T=$.mul(W,P);D[A]=$.add(R,T),D[f]=$.sub(R,T)}else if(Y)D[A]=$.add(W,R),D[f]=$.mul($.sub(W,R),P);else D[A]=$.add(R,W),D[f]=$.mul($.sub(R,W),P)}}if(!X&&U)uJ(D);return D}};/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */var h0=$0;function c0($,J){if($.length!==J.length)return!1;let Q=0;for(let q=0;q<$.length;q++)Q|=$[q]^J[q];return Q===0}function d0($){if(typeof $!=="object"||$===null||l$($))throw new Error("expected opts to be an object")}function j0($){if(d0($),$.context!==void 0)v($.context,void 0,"opts.context")}function C0($){if(j0($),$.extraEntropy!==!1&&$.extraEntropy!==void 0)v($.extraEntropy,void 0,"opts.extraEntropy")}function Z0($,...J){let Q=(X)=>typeof X==="number"?X:X.bytesLen,q=J.reduce((X,Y)=>X+Q(Y),0);return{bytesLen:q,encode:(X)=>{let Y=new Uint8Array(q);for(let Z=0,U=0;Z<J.length;Z++){let G=J[Z],K=Q(G),D=typeof G==="number"?X[Z]:G.encode(X[Z]);if(v(D,K,$),Y.set(D,U),typeof G!=="number")D.fill(0);U+=K}return Y},decode:(X)=>{v(X,q,$);let Y=[];for(let Z of J){let U=Q(Z),G=X.subarray(0,U);Y.push(typeof Z==="number"?G:Z.decode(G)),X=X.subarray(U)}return Y}}}function m$($,J){let Q=J*$.bytesLen;return{bytesLen:Q,encode:(q)=>{if(q.length!==J)throw new Error(`vecCoder.encode: wrong length=${q.length}. Expected: ${J}`);let X=new Uint8Array(Q);for(let Y=0,Z=0;Y<q.length;Y++){let U=$.encode(q[Y]);X.set(U,Z),U.fill(0),Z+=U.length}return X},decode:(q)=>{v(q,Q);let X=[];for(let Y=0;Y<q.length;Y+=$.bytesLen)X.push($.decode(q.subarray(Y,Y+$.bytesLen)));return X}}}function j$(...$){for(let J of $)if(Array.isArray(J))for(let Q of J)Q.fill(0);else J.fill(0)}function p0($){return(1<<$)-1}var dJ=Uint8Array.of();function l0($,J=dJ){if(v($),v(J),J.length>255)throw new Error("context should be less than 255 bytes");return w$(new Uint8Array([0,J.length]),J,$)}var s8=Uint8Array.from([6,9,96,134,72,1,101,3,4,2]);function pJ($,J=0){if(!$.oid||!c0($.oid.subarray(0,10),s8))throw new Error("hash.oid is invalid: expected NIST hash");let Q=$.outputLen*8/2;if(J>Q)throw new Error("Pre-hash security strength too low: "+Q+", required: "+J)}function r0($,J,Q=dJ){if(v(J),v(Q),Q.length>255)throw new Error("context should be less than 255 bytes");let q=$(J);return w$(new Uint8Array([1,Q.length]),Q,$.oid,q)}/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */var lJ=($)=>{let{newPoly:J,N:Q,Q:q,F:X,ROOT_OF_UNITY:Y,brvBits:Z,isKyber:U}=$,G=(z,O=q)=>{let w=z%O|0;return(w>=0?w|0:O+w|0)|0},K=(z,O=q)=>{let w=G(z,O)|0;return(w>O>>1?w-O|0:w)|0};function D(){let z=J(Q);for(let O=0;O<Q;O++){let w=b0(O,Z),A=BigInt(Y)**BigInt(w)%BigInt(q);z[O]=Number(A)|0}return z}let V=D(),k={add:(z,O)=>G((z|0)+(O|0))|0,sub:(z,O)=>G((z|0)-(O|0))|0,mul:(z,O)=>G((z|0)*(O|0))|0,inv:(z)=>{throw new Error("not implemented")}},S={N:Q,roots:V,invertButterflies:!0,skipStages:U?1:0,brp:!1},E=u0(k,{dit:!1,...S}),g=u0(k,{dit:!0,...S});return{mod:G,smod:K,nttZetas:V,NTT:{encode:(z)=>{return E(z)},decode:(z)=>{g(z);for(let O=0;O<z.length;O++)z[O]=G(X*z[O]);return z}},bitsCoder:(z,O)=>{let w=p0(z),A=z*(Q/8);return{bytesLen:A,encode:(f)=>{let P=new Uint8Array(A);for(let W=0,R=0,T=0,x=0;W<f.length;W++){R|=(O.encode(f[W])&w)<<T,T+=z;for(;T>=8;T-=8,R>>=8)P[x++]=R&p0(T)}return P},decode:(f)=>{let P=J(Q);for(let W=0,R=0,T=0,x=0;W<f.length;W++){R|=f[W]<<T,T+=8;for(;T>=z;T-=z,R>>=z)P[x++]=O.decode(R&w)}return P}}}}},rJ=($)=>(J,Q)=>{if(!Q)Q=$.blockLen;let q=new Uint8Array(J.length+2);q.set(J);let X=J.length,Y=new Uint8Array(Q),Z=$.create({}),U=0,G=0;return{stats:()=>({calls:U,xofs:G}),get:(K,D)=>{return q[X+0]=K,q[X+1]=D,Z.destroy(),Z=$.create({}).update(q),U++,()=>{return G++,Z.xofInto(Y)}},clean:()=>{Z.destroy(),j$(Y,q)}}},E0=rJ(bJ),k0=rJ(X$);/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */function aJ($){if(d0($),$.externalMu!==void 0)n$($.externalMu,"opts.externalMu")}var b=256,v$=8380417,e8=1753,$Q=8347681,u$=13,a0=Math.floor((v$-1)/88)|0,n0=Math.floor((v$-1)/32)|0,i0={2:{K:4,L:4,D:u$,GAMMA1:131072,GAMMA2:a0,TAU:39,ETA:2,OMEGA:80},3:{K:6,L:5,D:u$,GAMMA1:524288,GAMMA2:n0,TAU:49,ETA:4,OMEGA:55},5:{K:8,L:7,D:u$,GAMMA1:524288,GAMMA2:n0,TAU:60,ETA:2,OMEGA:75}},G$=($)=>new Int32Array($),{mod:b$,smod:T0,NTT:n,bitsCoder:JQ}=lJ({N:b,Q:v$,F:$Q,ROOT_OF_UNITY:e8,newPoly:G$,isKyber:!1,brvBits:8}),nJ=($)=>$,G0=($,J=nJ,Q=nJ)=>JQ($,{encode:(q)=>J(Q(q)),decode:(q)=>Q(J(q))}),L$=($,J)=>{for(let Q=0;Q<$.length;Q++)$[Q]=b$($[Q]+J[Q]);return $},iJ=($,J)=>{for(let Q=0;Q<$.length;Q++)$[Q]=b$($[Q]-J[Q]);return $},QQ=($)=>{for(let J=0;J<b;J++)$[J]<<=u$;return $},U0=($,J)=>{for(let Q=0;Q<b;Q++)if(Math.abs(T0($[Q]))>=J)return!0;return!1},P$=($,J)=>{let Q=G$(b);for(let q=0;q<$.length;q++)Q[q]=b$($[q]*J[q]);return Q};function H0($){let J=G$(b);for(let Q=0;Q<b;){let q=$();if(q.length%3)throw new Error("RejNTTPoly: unaligned block");for(let X=0;Q<b&&X<=q.length-3;X+=3){let Y=(q[X+0]|q[X+1]<<8|q[X+2]<<16)&8388607;if(Y<v$)J[Q++]=Y}}return J}function o0($){let{K:J,L:Q,GAMMA1:q,GAMMA2:X,TAU:Y,ETA:Z,OMEGA:U}=$,{CRH_BYTES:G,TR_BYTES:K,C_TILDE_BYTES:D,XOF128:V,XOF256:k,securityLevel:S}=$;if(![2,4].includes(Z))throw new Error("Wrong ETA");if(![131072,524288].includes(q))throw new Error("Wrong GAMMA1");if(![a0,n0].includes(X))throw new Error("Wrong GAMMA2");let E=Y*Z,g=(N)=>{let H=b$(N),I=T0(H,2*X)|0;if(H-I===v$-1)return{r1:0,r0:I-1|0};return{r1:Math.floor((H-I)/(2*X))|0,r0:I}},M=(N)=>g(N).r1,C=(N)=>g(N).r0,z=(N,H)=>{return N<=X||N>v$-X||N===v$-X&&H===0?0:1},O=(N,H)=>{let I=Math.floor((v$-1)/(2*X)),{r1:j,r0:L}=g(H);if(N===1)return L>0?b$(j+1,I)|0:b$(j-1,I)|0;return j|0},w=(N)=>{let H=b$(N),I=T0(H,2**u$)|0;return{r1:Math.floor((H-I)/2**u$)|0,r0:I}},A={bytesLen:U+J,encode:(N)=>{if(N===!1)throw new Error("hint.encode: hint is false");let H=new Uint8Array(U+J);for(let I=0,j=0;I<J;I++){for(let L=0;L<b;L++)if(N[I][L]!==0)H[j++]=L;H[U+I]=j}return H},decode:(N)=>{let H=[],I=0;for(let j=0;j<J;j++){let L=G$(b);if(N[U+j]<I||N[U+j]>U)return!1;for(let F=I;F<N[U+j];F++){if(F>I&&N[F]<=N[F-1])return!1;L[N[F]]=1}I=N[U+j],H.push(L)}for(let j=I;j<U;j++)if(N[j]!==0)return!1;return H}},f=G0(Z===2?3:4,(N)=>Z-N,(N)=>{if(!(-Z<=N&&N<=Z))throw new Error(`malformed key s1/s3 ${N} outside of ETA range [${-Z}, ${Z}]`);return N}),P=G0(13,(N)=>(1<<u$-1)-N),W=G0(10),R=G0(q===131072?18:20,(N)=>T0(q-N)),T=G0(X===a0?6:4),x=m$(T,J),y=Z0("publicKey",32,m$(W,J)),_=Z0("secretKey",32,32,K,m$(f,Q),m$(f,J),m$(P,J)),u=Z0("signature",D,m$(R,Q),A),c=Z===2?(N)=>N<15?2-N%5:!1:(N)=>N<9?4-N:!1;function K$(N){let H=G$(b);for(let I=0;I<b;){let j=N();for(let L=0;I<b&&L<j.length;L+=1){let F=c(j[L]&15),t=c(j[L]>>4&15);if(F!==!1)H[I++]=F;if(I<b&&t!==!1)H[I++]=t}}return H}let O$=(N)=>{let H=G$(b),I=X$.create({}).update(N),j=new Uint8Array(X$.blockLen);I.xofInto(j);let L=j.slice(0,8);for(let F=b-Y,t=8,q$=0,d=0;F<b;F++){let p=F+1;for(;p>F;){if(p=j[t++],t<X$.blockLen)continue;I.xofInto(j),t=0}if(H[F]=H[p],H[p]=1-((L[q$]>>d++&1)<<1),d>=8)q$++,d=0}return H},U$=(N)=>{let H=G$(b),I=G$(b);for(let j=0;j<N.length;j++){let{r0:L,r1:F}=w(N[j]);H[j]=L,I[j]=F}return{r0:H,r1:I}},F$=(N,H)=>{for(let I=0;I<b;I++)N[I]=O(H[I],N[I]);return N},c$=(N,H)=>{let I=G$(b),j=0;for(let L=0;L<b;L++){let F=z(N[L],H[L]);I[L]=F,j+=F}return{v:I,cnt:j}},d$=32,o$=Z0("seed",32,64,32),D$={info:{type:"internal-ml-dsa"},lengths:{secretKey:_.bytesLen,publicKey:y.bytesLen,seed:32,signature:u.bytesLen,signRand:d$},keygen:(N)=>{let H=new Uint8Array(34),I=N===void 0;if(I)N=h0(32);if(v(N,32,"seed"),H.set(N),I)j$(N);H[32]=J,H[33]=Q;let[j,L,F]=o$.decode(X$(H,{dkLen:o$.bytesLen})),t=k(L),q$=[];for(let B=0;B<Q;B++)q$.push(K$(t.get(B&255,B>>8&255)));let d=[];for(let B=Q;B<Q+J;B++)d.push(K$(t.get(B&255,B>>8&255)));let p=q$.map((B)=>n.encode(B.slice())),l=[],s=[],C$=V(j),a=G$(b);for(let B=0;B<J;B++){j$(a);for(let Z$=0;Z$<Q;Z$++){let M$=H0(C$.get(Z$,B));L$(a,P$(M$,p[Z$]))}n.decode(a);let{r0:z$,r1:Y$}=U$(L$(a,d[B]));l.push(z$),s.push(Y$)}let V$=y.encode([j,s]),E$=X$(V$,{dkLen:K}),p$=_.encode([j,F,E$,q$,d,l]);return C$.clean(),t.clean(),j$(j,L,F,q$,d,p,a,l,s,E$,H),{publicKey:V$,secretKey:p$}},getPublicKey:(N)=>{let[H,I,j,L,F,t]=_.decode(N),q$=V(H),d=L.map((s)=>n.encode(s.slice())),p=[],l=G$(b);for(let s=0;s<J;s++){l.fill(0);for(let a=0;a<Q;a++){let V$=H0(q$.get(a,s));L$(l,P$(V$,d[a]))}n.decode(l),L$(l,F[s]);let{r1:C$}=U$(l);p.push(C$)}return q$.clean(),j$(l,d,t,L,F),y.encode([H,p])},sign:(N,H,I={})=>{C0(I),aJ(I);let{extraEntropy:j,externalMu:L=!1}=I,[F,t,q$,d,p,l]=_.decode(H),s=[],C$=V(F);for(let B=0;B<J;B++){let z$=[];for(let Y$=0;Y$<Q;Y$++)z$.push(H0(C$.get(Y$,B)));s.push(z$)}C$.clean();for(let B=0;B<Q;B++)n.encode(d[B]);for(let B=0;B<J;B++)n.encode(p[B]),n.encode(l[B]);let a=L?N:X$.create({dkLen:G}).update(q$).update(N).digest(),V$=j===!1?new Uint8Array(32):j===void 0?h0(d$):j;v(V$,32,"extraEntropy");let E$=X$.create({dkLen:G}).update(t).update(V$).update(a).digest();v(E$,G);let p$=k(E$,R.bytesLen);$:for(let B=0;;){let z$=[];for(let m=0;m<Q;m++,B++)z$.push(R.decode(p$.get(B&255,B>>8)()));let Y$=z$.map((m)=>n.encode(m.slice())),Z$=[];for(let m=0;m<J;m++){let s$=G$(b);for(let S$=0;S$<Q;S$++)L$(s$,P$(s[m][S$],Y$[S$]));n.decode(s$),Z$.push(s$)}let M$=Z$.map((m)=>m.map(M)),t$=X$.create({dkLen:D}).update(a).update(x.encode(M$)).digest(),z0=n.encode(O$(t$)),K0=d.map((m)=>P$(m,z0));for(let m=0;m<Q;m++)if(L$(n.decode(K0[m]),z$[m]),U0(K0[m],q-E))continue $;let ZJ=0,v0=[];for(let m=0;m<J;m++){let s$=n.decode(P$(p[m],z0)),S$=iJ(Z$[m],s$).map(C);if(U0(S$,X-E))continue $;let GJ=n.decode(P$(l[m],z0));if(U0(GJ,X))continue $;L$(S$,GJ);let UJ=c$(S$,M$[m]);v0.push(UJ.v),ZJ+=UJ.cnt}if(ZJ>U)continue;p$.clean();let P8=u.encode([t$,K0,v0]);return j$(t$,K0,v0,z0,M$,Z$,Y$,z$,E$,a,d,p,l,...s),P8}throw new Error("Unreachable code path reached, report this error")},verify:(N,H,I,j={})=>{aJ(j);let{externalMu:L=!1}=j,[F,t]=y.decode(I),q$=X$(I,{dkLen:K});if(N.length!==u.bytesLen)return!1;let[d,p,l]=u.decode(N);if(l===!1)return!1;for(let B=0;B<Q;B++)if(U0(p[B],q-E))return!1;let s=L?H:X$.create({dkLen:G}).update(q$).update(H).digest(),C$=n.encode(O$(d)),a=p.map((B)=>B.slice());for(let B=0;B<Q;B++)n.encode(a[B]);let V$=[],E$=V(F);for(let B=0;B<J;B++){let z$=P$(n.encode(QQ(t[B])),C$),Y$=G$(b);for(let M$=0;M$<Q;M$++){let t$=H0(E$.get(M$,B));L$(Y$,P$(t$,a[M$]))}let Z$=n.decode(iJ(Y$,z$));V$.push(F$(Z$,l[B]))}E$.clean();let p$=X$.create({dkLen:D}).update(s).update(x.encode(V$)).digest();for(let B of l)if(!(B.reduce((Y$,Z$)=>Y$+Z$,0)<=U))return!1;for(let B of p)if(U0(B,q-E))return!1;return c0(d,p$)}};return{info:{type:"ml-dsa"},internal:D$,securityLevel:S,keygen:D$.keygen,lengths:D$.lengths,getPublicKey:D$.getPublicKey,sign:(N,H,I={})=>{C0(I);let j=l0(N,I.context),L=D$.sign(j,H,I);return j$(j),L},verify:(N,H,I,j={})=>{return j0(j),D$.verify(N,l0(H,j.context),I)},prehash:(N)=>{return pJ(N,S),{info:{type:"hashml-dsa"},securityLevel:S,lengths:D$.lengths,keygen:D$.keygen,getPublicKey:D$.getPublicKey,sign:(H,I,j={})=>{C0(j);let L=r0(N,H,j.context),F=D$.sign(L,I,j);return j$(L),F},verify:(H,I,j,L={})=>{return j0(L),D$.verify(H,r0(N,I,L.context),j)}}}}}var oJ=o0({...i0[2],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:32,XOF128:E0,XOF256:k0,securityLevel:128}),tQ=o0({...i0[3],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:48,XOF128:E0,XOF256:k0,securityLevel:192}),sQ=o0({...i0[5],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:64,XOF128:E0,XOF256:k0,securityLevel:256});function tJ($,J,Q){return $&J^~$&Q}function sJ($,J,Q){return $&J^$&Q^J&Q}class B0{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor($,J,Q,q){this.blockLen=$,this.outputLen=J,this.padOffset=Q,this.isLE=q,this.buffer=new Uint8Array($),this.view=N0(this.buffer)}update($){r$(this),v($);let{view:J,buffer:Q,blockLen:q}=this,X=$.length;for(let Y=0;Y<X;){let Z=Math.min(q-this.pos,X-Y);if(Z===q){let U=N0($);for(;q<=X-Y;Y+=q)this.process(U,Y);continue}if(Q.set($.subarray(Y,Y+Z),this.pos),this.pos+=Z,Y+=Z,this.pos===q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){r$(this),W0($,this),this.finished=!0;let{buffer:J,view:Q,blockLen:q,isLE:X}=this,{pos:Y}=this;if(J[Y++]=128,R$(this.buffer.subarray(Y)),this.padOffset>q-Y)this.process(Q,0),Y=0;for(let D=Y;D<q;D++)J[D]=0;Q.setBigUint64(q-8,BigInt(this.length*8),X),this.process(Q,0);let Z=N0($),U=this.outputLen;if(U%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let G=U/4,K=this.get();if(G>K.length)throw new Error("_sha2: outputLen bigger than state");for(let D=0;D<G;D++)Z.setUint32(4*D,K[D],X)}digest(){let{buffer:$,outputLen:J}=this;this.digestInto($);let Q=$.slice(0,J);return this.destroy(),Q}_cloneInto($){$||=new this.constructor,$.set(...this.get());let{blockLen:J,buffer:Q,length:q,finished:X,destroyed:Y,pos:Z}=this;if($.destroyed=Y,$.finished=X,$.length=q,$.pos=Z,q%J)$.buffer.set(Q);return $}clone(){return this._cloneInto()}}var T$=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),B$=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),i=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),o=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]);var qQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),A$=new Uint32Array(64);class t0 extends B0{constructor($){super(64,$,8,!1)}get(){let{A:$,B:J,C:Q,D:q,E:X,F:Y,G:Z,H:U}=this;return[$,J,Q,q,X,Y,Z,U]}set($,J,Q,q,X,Y,Z,U){this.A=$|0,this.B=J|0,this.C=Q|0,this.D=q|0,this.E=X|0,this.F=Y|0,this.G=Z|0,this.H=U|0}process($,J){for(let D=0;D<16;D++,J+=4)A$[D]=$.getUint32(J,!1);for(let D=16;D<64;D++){let V=A$[D-15],k=A$[D-2],S=W$(V,7)^W$(V,18)^V>>>3,E=W$(k,17)^W$(k,19)^k>>>10;A$[D]=E+A$[D-7]+S+A$[D-16]|0}let{A:Q,B:q,C:X,D:Y,E:Z,F:U,G,H:K}=this;for(let D=0;D<64;D++){let V=W$(Z,6)^W$(Z,11)^W$(Z,25),k=K+V+tJ(Z,U,G)+qQ[D]+A$[D]|0,E=(W$(Q,2)^W$(Q,13)^W$(Q,22))+sJ(Q,q,X)|0;K=G,G=U,U=Z,Z=Y+k|0,Y=X,X=q,q=Q,Q=k+E|0}Q=Q+this.A|0,q=q+this.B|0,X=X+this.C|0,Y=Y+this.D|0,Z=Z+this.E|0,U=U+this.F|0,G=G+this.G|0,K=K+this.H|0,this.set(Q,q,X,Y,Z,U,G,K)}roundClean(){R$(A$)}destroy(){this.set(0,0,0,0,0,0,0,0),R$(this.buffer)}}class XQ extends t0{A=T$[0]|0;B=T$[1]|0;C=T$[2]|0;D=T$[3]|0;E=T$[4]|0;F=T$[5]|0;G=T$[6]|0;H=T$[7]|0;constructor(){super(32)}}class YQ extends t0{A=B$[0]|0;B=B$[1]|0;C=B$[2]|0;D=B$[3]|0;E=B$[4]|0;F=B$[5]|0;G=B$[6]|0;H=B$[7]|0;constructor(){super(28)}}var eJ=(()=>I0(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(($)=>BigInt($))))(),ZQ=(()=>eJ[0])(),GQ=(()=>eJ[1])(),g$=new Uint32Array(80),x$=new Uint32Array(80);class D0 extends B0{constructor($){super(128,$,16,!1)}get(){let{Ah:$,Al:J,Bh:Q,Bl:q,Ch:X,Cl:Y,Dh:Z,Dl:U,Eh:G,El:K,Fh:D,Fl:V,Gh:k,Gl:S,Hh:E,Hl:g}=this;return[$,J,Q,q,X,Y,Z,U,G,K,D,V,k,S,E,g]}set($,J,Q,q,X,Y,Z,U,G,K,D,V,k,S,E,g){this.Ah=$|0,this.Al=J|0,this.Bh=Q|0,this.Bl=q|0,this.Ch=X|0,this.Cl=Y|0,this.Dh=Z|0,this.Dl=U|0,this.Eh=G|0,this.El=K|0,this.Fh=D|0,this.Fl=V|0,this.Gh=k|0,this.Gl=S|0,this.Hh=E|0,this.Hl=g|0}process($,J){for(let z=0;z<16;z++,J+=4)g$[z]=$.getUint32(J),x$[z]=$.getUint32(J+=4);for(let z=16;z<80;z++){let O=g$[z-15]|0,w=x$[z-15]|0,A=_$(O,w,1)^_$(O,w,8)^F0(O,w,7),f=y$(O,w,1)^y$(O,w,8)^_0(O,w,7),P=g$[z-2]|0,W=x$[z-2]|0,R=_$(P,W,19)^q0(P,W,61)^F0(P,W,6),T=y$(P,W,19)^X0(P,W,61)^_0(P,W,6),x=LJ(f,T,x$[z-7],x$[z-16]),y=PJ(x,A,R,g$[z-7],g$[z-16]);g$[z]=y|0,x$[z]=x|0}let{Ah:Q,Al:q,Bh:X,Bl:Y,Ch:Z,Cl:U,Dh:G,Dl:K,Eh:D,El:V,Fh:k,Fl:S,Gh:E,Gl:g,Hh:M,Hl:C}=this;for(let z=0;z<80;z++){let O=_$(D,V,14)^_$(D,V,18)^q0(D,V,41),w=y$(D,V,14)^y$(D,V,18)^X0(D,V,41),A=D&k^~D&E,f=V&S^~V&g,P=vJ(C,w,f,GQ[z],x$[z]),W=AJ(P,M,O,A,ZQ[z],g$[z]),R=P|0,T=_$(Q,q,28)^q0(Q,q,34)^q0(Q,q,39),x=y$(Q,q,28)^X0(Q,q,34)^X0(Q,q,39),y=Q&X^Q&Z^X&Z,_=q&Y^q&U^Y&U;M=E|0,C=g|0,E=k|0,g=S|0,k=D|0,S=V|0,{h:D,l:V}=I$(G|0,K|0,W|0,R|0),G=Z|0,K=U|0,Z=X|0,U=Y|0,X=Q|0,Y=q|0;let u=SJ(R,x,_);Q=wJ(u,W,T,y),q=u|0}({h:Q,l:q}=I$(this.Ah|0,this.Al|0,Q|0,q|0)),{h:X,l:Y}=I$(this.Bh|0,this.Bl|0,X|0,Y|0),{h:Z,l:U}=I$(this.Ch|0,this.Cl|0,Z|0,U|0),{h:G,l:K}=I$(this.Dh|0,this.Dl|0,G|0,K|0),{h:D,l:V}=I$(this.Eh|0,this.El|0,D|0,V|0),{h:k,l:S}=I$(this.Fh|0,this.Fl|0,k|0,S|0),{h:E,l:g}=I$(this.Gh|0,this.Gl|0,E|0,g|0),{h:M,l:C}=I$(this.Hh|0,this.Hl|0,M|0,C|0),this.set(Q,q,X,Y,Z,U,G,K,D,V,k,S,E,g,M,C)}roundClean(){R$(g$,x$)}destroy(){R$(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class $8 extends D0{Ah=o[0]|0;Al=o[1]|0;Bh=o[2]|0;Bl=o[3]|0;Ch=o[4]|0;Cl=o[5]|0;Dh=o[6]|0;Dl=o[7]|0;Eh=o[8]|0;El=o[9]|0;Fh=o[10]|0;Fl=o[11]|0;Gh=o[12]|0;Gl=o[13]|0;Hh=o[14]|0;Hl=o[15]|0;constructor(){super(64)}}class UQ extends D0{Ah=i[0]|0;Al=i[1]|0;Bh=i[2]|0;Bl=i[3]|0;Ch=i[4]|0;Cl=i[5]|0;Dh=i[6]|0;Dl=i[7]|0;Eh=i[8]|0;El=i[9]|0;Fh=i[10]|0;Fl=i[11]|0;Gh=i[12]|0;Gl=i[13]|0;Hh=i[14]|0;Hl=i[15]|0;constructor(){super(48)}}var e=Uint32Array.from([2352822216,424955298,1944164710,2312950998,502970286,855612546,1738396948,1479516111,258812777,2077511080,2011393907,79989058,1067287976,1780299464,286451373,2446758561]),$$=Uint32Array.from([573645204,4230739756,2673172387,3360449730,596883563,1867755857,2520282905,1497426621,2519219938,2827943907,3193839141,1401305490,721525244,746961066,246885852,2177182882]);class DQ extends D0{Ah=e[0]|0;Al=e[1]|0;Bh=e[2]|0;Bl=e[3]|0;Ch=e[4]|0;Cl=e[5]|0;Dh=e[6]|0;Dl=e[7]|0;Eh=e[8]|0;El=e[9]|0;Fh=e[10]|0;Fl=e[11]|0;Gh=e[12]|0;Gl=e[13]|0;Hh=e[14]|0;Hl=e[15]|0;constructor(){super(28)}}class zQ extends D0{Ah=$$[0]|0;Al=$$[1]|0;Bh=$$[2]|0;Bl=$$[3]|0;Ch=$$[4]|0;Cl=$$[5]|0;Dh=$$[6]|0;Dl=$$[7]|0;Eh=$$[8]|0;El=$$[9]|0;Fh=$$[10]|0;Fl=$$[11]|0;Gh=$$[12]|0;Gl=$$[13]|0;Hh=$$[14]|0;Hl=$$[15]|0;constructor(){super(32)}}var J8=O0(()=>new $8,J0(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q$=BigInt(0),J$=BigInt(1),h$=BigInt(2),X8=BigInt(3),Y8=BigInt(4),Z8=BigInt(5),KQ=BigInt(7),G8=BigInt(8),WQ=BigInt(9),U8=BigInt(16);function h($,J){let Q=$%J;return Q>=Q$?Q:J+Q}function N$($,J,Q){let q=$;while(J-- >Q$)q*=q,q%=Q;return q}function Q8($,J){if($===Q$)throw new Error("invert: expected non-zero number");if(J<=Q$)throw new Error("invert: expected positive modulus, got "+J);let Q=h($,J),q=J,X=Q$,Y=J$,Z=J$,U=Q$;while(Q!==Q$){let K=q/Q,D=q%Q,V=X-Z*K,k=Y-U*K;q=Q,Q=D,X=Z,Y=U,Z=V,U=k}if(q!==J$)throw new Error("invert: does not exist");return h(X,J)}function s0($,J,Q){if(!$.eql($.sqr(J),Q))throw new Error("Cannot find square root")}function D8($,J){let Q=($.ORDER+J$)/Y8,q=$.pow(J,Q);return s0($,q,J),q}function NQ($,J){let Q=($.ORDER-Z8)/G8,q=$.mul(J,h$),X=$.pow(q,Q),Y=$.mul(J,X),Z=$.mul($.mul(Y,h$),X),U=$.mul(Y,$.sub(Z,$.ONE));return s0($,U,J),U}function OQ($){let J=w0($),Q=z8($),q=Q(J,J.neg(J.ONE)),X=Q(J,q),Y=Q(J,J.neg(q)),Z=($+KQ)/U8;return(U,G)=>{let K=U.pow(G,Z),D=U.mul(K,q),V=U.mul(K,X),k=U.mul(K,Y),S=U.eql(U.sqr(D),G),E=U.eql(U.sqr(V),G);K=U.cmov(K,D,S),D=U.cmov(k,V,E);let g=U.eql(U.sqr(D),G),M=U.cmov(K,D,g);return s0(U,M,G),M}}function z8($){if($<X8)throw new Error("sqrt is not defined for small field");let J=$-J$,Q=0;while(J%h$===Q$)J/=h$,Q++;let q=h$,X=w0($);while(q8(X,q)===1)if(q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(Q===1)return D8;let Y=X.pow(q,J),Z=(J+J$)/h$;return function U(G,K){if(G.is0(K))return K;if(q8(G,K)!==1)throw new Error("Cannot find square root");let D=Q,V=G.mul(G.ONE,Y),k=G.pow(K,J),S=G.pow(K,Z);while(!G.eql(k,G.ONE)){if(G.is0(k))return G.ZERO;let E=1,g=G.sqr(k);while(!G.eql(g,G.ONE))if(E++,g=G.sqr(g),E===D)throw new Error("Cannot find square root");let M=J$<<BigInt(D-E-1),C=G.pow(V,M);D=E,V=G.sqr(C),k=G.mul(k,V),S=G.mul(S,C)}return S}}function VQ($){if($%Y8===X8)return D8;if($%G8===Z8)return NQ;if($%U8===WQ)return OQ($);return z8($)}var K8=($,J)=>(h($,J)&J$)===J$,MQ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function W8($){let J={ORDER:"bigint",BYTES:"number",BITS:"number"},Q=MQ.reduce((q,X)=>{return q[X]="function",q},J);return Q0($,Q),$}function RQ($,J,Q){if(Q<Q$)throw new Error("invalid exponent, negatives unsupported");if(Q===Q$)return $.ONE;if(Q===J$)return J;let q=$.ONE,X=J;while(Q>Q$){if(Q&J$)q=$.mul(q,X);X=$.sqr(X),Q>>=J$}return q}function S0($,J,Q=!1){let q=new Array(J.length).fill(Q?$.ZERO:void 0),X=J.reduce((Z,U,G)=>{if($.is0(U))return Z;return q[G]=Z,$.mul(Z,U)},$.ONE),Y=$.inv(X);return J.reduceRight((Z,U,G)=>{if($.is0(U))return Z;return q[G]=$.mul(Z,q[G]),$.mul(Z,U)},Y),q}function q8($,J){let Q=($.ORDER-J$)/h$,q=$.pow(J,Q),X=$.eql(q,$.ONE),Y=$.eql(q,$.ZERO),Z=$.eql(q,$.neg($.ONE));if(!X&&!Y&&!Z)throw new Error("invalid Legendre symbol result");return X?1:Y?0:-1}function IQ($,J){if(J!==void 0)H$(J);let Q=J!==void 0?J:$.toString(2).length,q=Math.ceil(Q/8);return{nBitLength:Q,nByteLength:q}}class N8{ORDER;BITS;BYTES;isLE;ZERO=Q$;ONE=J$;_lengths;_sqrt;_mod;constructor($,J={}){if($<=Q$)throw new Error("invalid field: expected ORDER > 0, got "+$);let Q=void 0;if(this.isLE=!1,J!=null&&typeof J==="object"){if(typeof J.BITS==="number")Q=J.BITS;if(typeof J.sqrt==="function")this.sqrt=J.sqrt;if(typeof J.isLE==="boolean")this.isLE=J.isLE;if(J.allowedLengths)this._lengths=J.allowedLengths?.slice();if(typeof J.modFromBytes==="boolean")this._mod=J.modFromBytes}let{nBitLength:q,nByteLength:X}=IQ($,Q);if(X>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=$,this.BITS=q,this.BYTES=X,this._sqrt=void 0,Object.preventExtensions(this)}create($){return h($,this.ORDER)}isValid($){if(typeof $!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof $);return Q$<=$&&$<this.ORDER}is0($){return $===Q$}isValidNot0($){return!this.is0($)&&this.isValid($)}isOdd($){return($&J$)===J$}neg($){return h(-$,this.ORDER)}eql($,J){return $===J}sqr($){return h($*$,this.ORDER)}add($,J){return h($+J,this.ORDER)}sub($,J){return h($-J,this.ORDER)}mul($,J){return h($*J,this.ORDER)}pow($,J){return RQ(this,$,J)}div($,J){return h($*Q8(J,this.ORDER),this.ORDER)}sqrN($){return $*$}addN($,J){return $+J}subN($,J){return $-J}mulN($,J){return $*J}inv($){return Q8($,this.ORDER)}sqrt($){if(!this._sqrt)this._sqrt=VQ(this.ORDER);return this._sqrt(this,$)}toBytes($){return this.isLE?jJ($,this.BYTES):g0($,this.BYTES)}fromBytes($,J=!1){v($);let{_lengths:Q,BYTES:q,isLE:X,ORDER:Y,_mod:Z}=this;if(Q){if(!Q.includes($.length)||$.length>q)throw new Error("Field.fromBytes: expected "+Q+" bytes, got "+$.length);let G=new Uint8Array(q);G.set($,X?0:G.length-$.length),$=G}if($.length!==q)throw new Error("Field.fromBytes: expected "+q+" bytes, got "+$.length);let U=X?i$($):IJ($);if(Z)U=h(U,Y);if(!J){if(!this.isValid(U))throw new Error("invalid field element: outside of range 0..ORDER")}return U}invertBatch($){return S0(this,$)}cmov($,J,Q){return Q?J:$}}function w0($,J={}){return new N8($,J)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var L0=BigInt(0),QJ=BigInt(1);function O8($,J){let Q=J.negate();return $?Q:J}function P0($,J){let Q=S0($.Fp,J.map((q)=>q.Z));return J.map((q,X)=>$.fromAffine(q.toAffine(Q[X])))}function I8($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)}function e0($,J){I8($,J);let Q=Math.ceil(J/$)+1,q=2**($-1),X=2**$,Y=CJ($),Z=BigInt($);return{windows:Q,windowSize:q,mask:Y,maxNumber:X,shiftBy:Z}}function V8($,J,Q){let{windowSize:q,mask:X,maxNumber:Y,shiftBy:Z}=Q,U=Number($&X),G=$>>Z;if(U>q)U-=Y,G+=QJ;let K=J*q,D=K+Math.abs(U)-1,V=U===0,k=U<0,S=J%2!==0;return{nextN:G,offset:D,isZero:V,isNeg:k,isNegF:S,offsetF:K}}var $J=new WeakMap,j8=new WeakMap;function JJ($){return j8.get($)||1}function M8($){if($!==L0)throw new Error("invalid wNAF")}class qJ{BASE;ZERO;Fn;bits;constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,Q=this.ZERO){let q=$;while(J>L0){if(J&QJ)Q=Q.add(q);q=q.double(),J>>=QJ}return Q}precomputeWindow($,J){let{windows:Q,windowSize:q}=e0(J,this.bits),X=[],Y=$,Z=Y;for(let U=0;U<Q;U++){Z=Y,X.push(Z);for(let G=1;G<q;G++)Z=Z.add(Y),X.push(Z);Y=Z.double()}return X}wNAF($,J,Q){if(!this.Fn.isValid(Q))throw new Error("invalid scalar");let q=this.ZERO,X=this.BASE,Y=e0($,this.bits);for(let Z=0;Z<Y.windows;Z++){let{nextN:U,offset:G,isZero:K,isNeg:D,isNegF:V,offsetF:k}=V8(Q,Z,Y);if(Q=U,K)X=X.add(O8(V,J[k]));else q=q.add(O8(D,J[G]))}return M8(Q),{p:q,f:X}}wNAFUnsafe($,J,Q,q=this.ZERO){let X=e0($,this.bits);for(let Y=0;Y<X.windows;Y++){if(Q===L0)break;let{nextN:Z,offset:U,isZero:G,isNeg:K}=V8(Q,Y,X);if(Q=Z,G)continue;else{let D=J[U];q=q.add(K?D.negate():D)}}return M8(Q),q}getPrecomputes($,J,Q){let q=$J.get(J);if(!q){if(q=this.precomputeWindow(J,$),$!==1){if(typeof Q==="function")q=Q(q);$J.set(J,q)}}return q}cached($,J,Q){let q=JJ($);return this.wNAF(q,this.getPrecomputes(q,$,Q),J)}unsafe($,J,Q,q){let X=JJ($);if(X===1)return this._unsafeLadder($,J,q);return this.wNAFUnsafe(X,this.getPrecomputes(X,$,Q),J,q)}createCache($,J){I8(J,this.bits),j8.set($,J),$J.delete($)}hasCache($){return JJ($)!==1}}function R8($,J,Q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return W8(J),J}else return w0($,{isLE:Q})}function C8($,J,Q={},q){if(q===void 0)q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let G of["p","n","h"]){let K=J[G];if(!(typeof K==="bigint"&&K>L0))throw new Error(`CURVE.${G} must be positive bigint`)}let X=R8(J.p,Q.Fp,q),Y=R8(J.n,Q.Fn,q),U=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let G of U)if(!X.isValid(J[G]))throw new Error(`CURVE.${G} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:X,Fn:Y}}function E8($,J){return function Q(q){let X=$(q);return{secretKey:X,publicKey:J(X)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var f$=BigInt(0),r=BigInt(1),XJ=BigInt(2),jQ=BigInt(8);function CQ($,J,Q,q){let X=$.sqr(Q),Y=$.sqr(q),Z=$.add($.mul(J.a,X),Y),U=$.add($.ONE,$.mul(J.d,$.mul(X,Y)));return $.eql(Z,U)}function k8($,J={}){let Q=C8("edwards",$,J,J.FpFnLE),{Fp:q,Fn:X}=Q,Y=Q.CURVE,{h:Z}=Y;Q0(J,{},{uvRatio:"function"});let U=XJ<<BigInt(X.BYTES*8)-r,G=(M)=>q.create(M),K=J.uvRatio||((M,C)=>{try{return{isValid:!0,value:q.sqrt(q.div(M,C))}}catch(z){return{isValid:!1,value:f$}}});if(!CQ(q,Y,Y.Gx,Y.Gy))throw new Error("bad curve params: generator point");function D(M,C,z=!1){let O=z?r:f$;return x0("coordinate "+M,C,O,U),C}function V(M){if(!(M instanceof E))throw new Error("EdwardsPoint expected")}let k=f0((M,C)=>{let{X:z,Y:O,Z:w}=M,A=M.is0();if(C==null)C=A?jQ:q.inv(w);let f=G(z*C),P=G(O*C),W=q.mul(w,C);if(A)return{x:f$,y:r};if(W!==r)throw new Error("invZ was invalid");return{x:f,y:P}}),S=f0((M)=>{let{a:C,d:z}=Y;if(M.is0())throw new Error("bad point: ZERO");let{X:O,Y:w,Z:A,T:f}=M,P=G(O*O),W=G(w*w),R=G(A*A),T=G(R*R),x=G(P*C),y=G(R*G(x+W)),_=G(T+G(z*G(P*W)));if(y!==_)throw new Error("bad point: equation left != right (1)");let u=G(O*w),c=G(A*f);if(u!==c)throw new Error("bad point: equation left != right (2)");return!0});class E{static BASE=new E(Y.Gx,Y.Gy,r,G(Y.Gx*Y.Gy));static ZERO=new E(f$,r,r,f$);static Fp=q;static Fn=X;X;Y;Z;T;constructor(M,C,z,O){this.X=D("x",M),this.Y=D("y",C),this.Z=D("z",z,!0),this.T=D("t",O),Object.freeze(this)}static CURVE(){return Y}static fromAffine(M){if(M instanceof E)throw new Error("extended point not allowed");let{x:C,y:z}=M||{};return D("x",C),D("y",z),new E(C,z,r,G(C*z))}static fromBytes(M,C=!1){let z=q.BYTES,{a:O,d:w}=Y;M=M0(v(M,z,"point")),n$(C,"zip215");let A=M0(M),f=M[z-1];A[z-1]=f&-129;let P=i$(A),W=C?U:q.ORDER;x0("point.y",P,f$,W);let R=G(P*P),T=G(R-r),x=G(w*R-O),{isValid:y,value:_}=K(T,x);if(!y)throw new Error("bad point: invalid y coordinate");let u=(_&r)===r,c=(f&128)!==0;if(!C&&_===f$&&c)throw new Error("bad point: x=0 and x_0=1");if(c!==u)_=G(-_);return E.fromAffine({x:_,y:P})}static fromHex(M,C=!1){return E.fromBytes(e$(M),C)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(M=8,C=!0){if(g.createCache(this,M),!C)this.multiply(XJ);return this}assertValidity(){S(this)}equals(M){V(M);let{X:C,Y:z,Z:O}=this,{X:w,Y:A,Z:f}=M,P=G(C*f),W=G(w*O),R=G(z*f),T=G(A*O);return P===W&&R===T}is0(){return this.equals(E.ZERO)}negate(){return new E(G(-this.X),this.Y,this.Z,G(-this.T))}double(){let{a:M}=Y,{X:C,Y:z,Z:O}=this,w=G(C*C),A=G(z*z),f=G(XJ*G(O*O)),P=G(M*w),W=C+z,R=G(G(W*W)-w-A),T=P+A,x=T-f,y=P-A,_=G(R*x),u=G(T*y),c=G(R*y),K$=G(x*T);return new E(_,u,K$,c)}add(M){V(M);let{a:C,d:z}=Y,{X:O,Y:w,Z:A,T:f}=this,{X:P,Y:W,Z:R,T}=M,x=G(O*P),y=G(w*W),_=G(f*z*T),u=G(A*R),c=G((O+w)*(P+W)-x-y),K$=u-_,O$=u+_,U$=G(y-C*x),F$=G(c*K$),c$=G(O$*U$),d$=G(c*U$),o$=G(K$*O$);return new E(F$,c$,o$,d$)}subtract(M){return this.add(M.negate())}multiply(M){if(!X.isValidNot0(M))throw new Error("invalid scalar: expected 1 <= sc < curve.n");let{p:C,f:z}=g.cached(this,M,(O)=>P0(E,O));return P0(E,[C,z])[0]}multiplyUnsafe(M,C=E.ZERO){if(!X.isValid(M))throw new Error("invalid scalar: expected 0 <= sc < curve.n");if(M===f$)return E.ZERO;if(this.is0()||M===r)return this;return g.unsafe(this,M,(z)=>P0(E,z),C)}isSmallOrder(){return this.multiplyUnsafe(Z).is0()}isTorsionFree(){return g.unsafe(this,Y.n).is0()}toAffine(M){return k(this,M)}clearCofactor(){if(Z===r)return this;return this.multiplyUnsafe(Z)}toBytes(){let{x:M,y:C}=this.toAffine(),z=q.toBytes(C);return z[z.length-1]|=M&r?128:0,z}toHex(){return a$(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}let g=new qJ(E,X.BITS);return E.BASE.precompute(8),E}function H8($,J,Q={}){if(typeof J!=="function")throw new Error('"hash" function param is required');Q0(Q,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});let{prehash:q}=Q,{BASE:X,Fp:Y,Fn:Z}=$,U=Q.randomBytes||$0,G=Q.adjustScalarBytes||((W)=>W),K=Q.domain||((W,R,T)=>{if(n$(T,"phflag"),R.length||T)throw new Error("Contexts/pre-hash are not supported");return W});function D(W){return Z.create(i$(W))}function V(W){let R=O.secretKey;v(W,O.secretKey,"secretKey");let T=v(J(W),2*R,"hashedSecretKey"),x=G(T.slice(0,R)),y=T.slice(R,2*R),_=D(x);return{head:x,prefix:y,scalar:_}}function k(W){let{head:R,prefix:T,scalar:x}=V(W),y=X.multiply(x),_=y.toBytes();return{head:R,prefix:T,scalar:x,point:y,pointBytes:_}}function S(W){return k(W).pointBytes}function E(W=Uint8Array.of(),...R){let T=w$(...R);return D(J(K(T,v(W,void 0,"context"),!!q)))}function g(W,R,T={}){if(W=v(W,void 0,"message"),q)W=q(W);let{prefix:x,scalar:y,pointBytes:_}=k(R),u=E(T.context,x,W),c=X.multiply(u).toBytes(),K$=E(T.context,c,_,W),O$=Z.create(u+K$*y);if(!Z.isValid(O$))throw new Error("sign failed: invalid s");let U$=w$(c,Z.toBytes(O$));return v(U$,O.signature,"result")}let M={zip215:!0};function C(W,R,T,x=M){let{context:y,zip215:_}=x,u=O.signature;if(W=v(W,u,"signature"),R=v(R,void 0,"message"),T=v(T,O.publicKey,"publicKey"),_!==void 0)n$(_,"zip215");if(q)R=q(R);let c=u/2,K$=W.subarray(0,c),O$=i$(W.subarray(c,u)),U$,F$,c$;try{U$=$.fromBytes(T,_),F$=$.fromBytes(K$,_),c$=X.multiplyUnsafe(O$)}catch(D$){return!1}if(!_&&U$.isSmallOrder())return!1;let d$=E(y,F$.toBytes(),U$.toBytes(),R);return F$.add(U$.multiplyUnsafe(d$)).subtract(c$).clearCofactor().is0()}let z=Y.BYTES,O={secretKey:z,publicKey:z,signature:2*z,seed:z};function w(W=U(O.seed)){return v(W,O.seed,"seed")}function A(W){return l$(W)&&W.length===Z.BYTES}function f(W,R){try{return!!$.fromBytes(W,R)}catch(T){return!1}}let P={getExtendedPublicKey:k,randomSecretKey:w,isValidSecretKey:A,isValidPublicKey:f,toMontgomery(W){let{y:R}=$.fromBytes(W),T=O.publicKey,x=T===32;if(!x&&T!==57)throw new Error("only defined for 25519 and 448");let y=x?Y.div(r+R,r-R):Y.div(R-r,R+r);return Y.toBytes(y)},toMontgomerySecret(W){let R=O.secretKey;v(W,R);let T=J(W.subarray(0,R));return G(T).subarray(0,R)}};return Object.freeze({keygen:E8(w,S),getPublicKey:S,sign:g,verify:C,utils:P,Point:$,lengths:O})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var EQ=BigInt(1),T8=BigInt(2);var kQ=BigInt(5),HQ=BigInt(8),YJ=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),TQ=(()=>({p:YJ,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:HQ,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function BQ($){let J=BigInt(10),Q=BigInt(20),q=BigInt(40),X=BigInt(80),Y=YJ,U=$*$%Y*$%Y,G=N$(U,T8,Y)*U%Y,K=N$(G,EQ,Y)*$%Y,D=N$(K,kQ,Y)*K%Y,V=N$(D,J,Y)*D%Y,k=N$(V,Q,Y)*V%Y,S=N$(k,q,Y)*k%Y,E=N$(S,X,Y)*S%Y,g=N$(E,X,Y)*S%Y,M=N$(g,J,Y)*D%Y;return{pow_p_5_8:N$(M,T8,Y)*$%Y,b2:U}}function SQ($){return $[0]&=248,$[31]&=127,$[31]|=64,$}var B8=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function wQ($,J){let Q=YJ,q=h(J*J*J,Q),X=h(q*q*J,Q),Y=BQ($*X).pow_p_5_8,Z=h($*q*Y,Q),U=h(J*Z*Z,Q),G=Z,K=h(Z*B8,Q),D=U===$,V=U===h(-$,Q),k=U===h(-$*B8,Q);if(D)Z=G;if(V||k)Z=K;if(K8(Z,Q))Z=h(-Z,Q);return{isValid:D||V,value:Z}}var LQ=k8(TQ,{uvRatio:wQ});function PQ($){return H8(LQ,J8,Object.assign({adjustScalarBytes:SQ},$))}var S8=PQ({});async function L8($){try{let J=$.proof;if(!Array.isArray(J))throw new Error("VC has no proofs or invalid format.");let Q={...$};delete Q.proof;let q=w8.default(Q);if(!q)throw new Error("Canonicalization failed during verification");let X=new TextEncoder().encode(q),Y=J.find((G)=>G.type==="Ed25519Signature2020"),Z=J.find((G)=>G.cryptosuite==="ml-dsa-44-2025"),U={ed25519:!1,pqc:!1};if(Y){let G=Y.verificationMethod||"",K="";if(G.includes("ed25519"))K=G.split("#")[1]||"";else K=G.split("#")[1]||"";let D=Y.proofValue;if(K&&D){let V=Uint8Array.from(Buffer.from(K,"hex"));U.ed25519=S8.verify(D,X,V)}}if(Z){let K=(Z.verificationMethod||"").split("#")[1],D=Z.proofValue;if(K&&D){let V=Uint8Array.from(Buffer.from(D,"hex")),k=Uint8Array.from(Buffer.from(K,"hex"));U.pqc=oJ.verify(V,X,k)}}return{isValid:U.ed25519&&U.pqc,checks:U,decoded:Q}}catch(J){return{isValid:!1,checks:{ed25519:!1,pqc:!1},error:J.message}}}document.addEventListener("DOMContentLoaded",()=>{let $=document.getElementById("drop-zone"),J=document.getElementById("result-area");if(!$||!J)return;$.addEventListener("dragover",(Y)=>{Y.preventDefault(),$.classList.add("active")}),$.addEventListener("dragleave",()=>{$.classList.remove("active")}),$.addEventListener("drop",async(Y)=>{Y.preventDefault(),$.classList.remove("active");let Z=Y.dataTransfer?.files[0];if(Z)await q(Z)});let Q=document.getElementById("file-input");if(Q)Q.addEventListener("change",async(Y)=>{let Z=Y.target.files[0];if(Z)await q(Z)});async function q(Y){J.innerHTML='<div class="scanning">Reading VC file...</div>';try{let Z=await Y.text(),U=JSON.parse(Z);J.innerHTML='<div class="scanning">Verifying Signatures (Ed25519 + ML-DSA-44)...</div>',await new Promise((K)=>setTimeout(K,600));let G=await L8(U);if(G.isValid){J.innerHTML='<div class="scanning">Checking Revocation Status...</div>';try{let D=await fetch("status-list.json");if(D.ok){let k=(await D.json()).credentialSubject?.["srn:revokedBuildIds"]||[],S=U.credentialSubject?.["srn:buildId"];if(S&&k.includes(S))G.isValid=!1,G.revocationError=`REVOKED: Build ID '${S}' is in the revocation list.`}else console.warn("Could not fetch status list")}catch(K){console.warn("Revocation check failed (Network error?)",K)}}X(G,U)}catch(Z){J.innerHTML=`<div class="error">Failed to parse VC: ${Z.message}</div>`}}function X(Y,Z){let U=Y.isValid,G=U?"#27ae60":"#c0392b",K=U?"\uD83D\uDEE1️ VALID":"⚠️ INVALID",D="";if(Y.revocationError)U=!1,G="#d32f2f",K="❌ REVOKED",D=`<div style="background: #ffebee; color: #c62828; padding: 1rem; border-radius: 4px; margin: 1rem 0; font-weight: bold;">
                ${Y.revocationError}
            </div>`;let V=`
            <div style="border: 2px solid ${G}; padding: 2rem; border-radius: 8px; background: #fff;">
                <h2 style="color: ${G}; margin-top: 0; font-size: 2rem;">${K}</h2>
                ${D}
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0;">
                    <div class="check-item ${Y.checks.ed25519?"pass":"fail"}">
                        <strong>Ed25519 (Classic)</strong>
                        <span>${Y.checks.ed25519?"P-256 Signature Verified":"Verification Failed"}</span>
                    </div>
                    <div class="check-item ${Y.checks.pqc?"pass":"fail"}">
                        <strong>ML-DSA-44 (Post-Quantum)</strong>
                        <span>${Y.checks.pqc?"Lattice-based Signature Verified":"Verification Failed"}</span>
                    </div>
                </div>

                <details style="margin-top: 1rem; border-top: 1px solid #eee; padding-top: 1rem;">
                    <summary style="cursor: pointer; color: #666;">View Raw VC Payload</summary>
                    <pre style="background: #f8f8f8; padding: 1rem; overflow: auto; text-align: left; font-size: 0.8rem;">${JSON.stringify(Z,null,2)}</pre>
                </details>
            </div>
        `;J.innerHTML=V}});
