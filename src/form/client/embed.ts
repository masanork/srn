// Auto-generated by scripts/build_weba_client.ts
export const CLIENT_BUNDLE = "var __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target;\n  for (let key of __getOwnPropNames(mod))\n    if (!__hasOwnProp.call(to, key))\n      __defProp(to, key, {\n        get: () => mod[key],\n        enumerable: true\n      });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\n\n// node_modules/canonicalize/lib/canonicalize.js\nvar require_canonicalize = __commonJS((exports, module) => {\n  module.exports = function serialize(object) {\n    if (typeof object === \"number\" && isNaN(object)) {\n      throw new Error(\"NaN is not allowed\");\n    }\n    if (typeof object === \"number\" && !isFinite(object)) {\n      throw new Error(\"Infinity is not allowed\");\n    }\n    if (object === null || typeof object !== \"object\") {\n      return JSON.stringify(object);\n    }\n    if (object.toJSON instanceof Function) {\n      return serialize(object.toJSON());\n    }\n    if (Array.isArray(object)) {\n      const values2 = object.reduce((t, cv, ci) => {\n        const comma = ci === 0 ? \"\" : \",\";\n        const value = cv === undefined || typeof cv === \"symbol\" ? null : cv;\n        return `${t}${comma}${serialize(value)}`;\n      }, \"\");\n      return `[${values2}]`;\n    }\n    const values = Object.keys(object).sort().reduce((t, cv) => {\n      if (object[cv] === undefined || typeof object[cv] === \"symbol\") {\n        return t;\n      }\n      const comma = t.length === 0 ? \"\" : \",\";\n      return `${t}${comma}${serialize(cv)}:${serialize(object[cv])}`;\n    }, \"\");\n    return `{${values}}`;\n  };\n});\n\n// src/form/client/calculator.ts\nclass Calculator {\n  runAutoCopy() {\n    document.querySelectorAll(\"[data-copy-from]\").forEach((dest) => {\n      if (!dest.dataset.dirty) {\n        const srcKey = dest.dataset.copyFrom;\n        if (srcKey) {\n          const row = dest.closest(\"tr\");\n          const scope = row || document;\n          const src = scope.querySelector(`[data-base-key=\"${srcKey}\"], [data-json-path=\"${srcKey}\"]`);\n          if (src && src.value !== dest.value) {\n            dest.value = src.value;\n            dest.dispatchEvent(new Event(\"input\", { bubbles: true }));\n          }\n        }\n      }\n    });\n  }\n  recalculate() {\n    document.querySelectorAll(\"[data-formula]\").forEach((calcField) => {\n      const formula = calcField.dataset.formula;\n      if (!formula)\n        return;\n      const row = calcField.closest(\"tr\");\n      const table = calcField.closest(\"table\");\n      const getValue = (varName) => {\n        let val = 0;\n        let foundSource = \"none\";\n        if (row) {\n          const selector = `[data-base-key=\"${varName}\"], [data-json-path=\"${varName}\"]`;\n          const input = row.querySelector(selector);\n          if (input) {\n            foundSource = \"row-input\";\n            if (input.value !== \"\")\n              val = parseFloat(input.value);\n          }\n        }\n        if (foundSource === \"none\") {\n          const staticInput = document.querySelector(`[data-json-path=\"${varName}\"]`);\n          if (staticInput) {\n            foundSource = \"static-input\";\n            if (staticInput.value !== \"\")\n              val = parseFloat(staticInput.value);\n          }\n        }\n        return val;\n      };\n      let evalStr = formula.replace(/SUM\\(([a-zA-Z0-9_\\-\\u0080-\\uFFFF]+)\\)/g, (_, key) => {\n        let sum = 0;\n        const scope = table || document;\n        let inputs = scope.querySelectorAll(`[data-base-key=\"${key}\"], [data-json-path=\"${key}\"]`);\n        if (inputs.length === 0 && scope !== document) {\n          inputs = document.querySelectorAll(`[data-base-key=\"${key}\"], [data-json-path=\"${key}\"]`);\n        }\n        inputs.forEach((inp) => {\n          const val = parseFloat(inp.value);\n          if (!isNaN(val))\n            sum += val;\n        });\n        return sum;\n      });\n      evalStr = evalStr.replace(/([a-zA-Z_\\u0080-\\uFFFF][a-zA-Z0-9_\\-\\u0080-\\uFFFF]*)/g, (match) => {\n        if ([\"Math\", \"round\", \"floor\", \"ceil\", \"abs\", \"min\", \"max\"].includes(match))\n          return match;\n        return String(getValue(match));\n      });\n      try {\n        const result = new Function(\"return \" + evalStr)();\n        if (typeof result === \"number\" && !isNaN(result)) {\n          calcField.value = Number.isInteger(result) ? result : result.toFixed(0);\n        } else {\n          calcField.value = \"\";\n        }\n      } catch (e) {\n        console.error(\"Calc Error:\", e);\n        calcField.value = \"Err\";\n      }\n    });\n    this.runAutoCopy();\n  }\n}\n\n// node_modules/@noble/hashes/utils.js\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction anumber(n, title = \"\") {\n  if (!Number.isSafeInteger(n) || n < 0) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n  }\n}\nfunction abytes(value, length, title = \"\") {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || needsLen && len !== length) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : \"\";\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + \"expected Uint8Array\" + ofLen + \", got \" + got);\n  }\n  return value;\n}\nfunction ahash(h) {\n  if (typeof h !== \"function\" || typeof h.create !== \"function\")\n    throw new Error(\"Hash must wrapped by utils.createHasher\");\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n  if (instance.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (checkFinished && instance.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction aoutput(out, instance) {\n  abytes(out, undefined, \"digestInto() output\");\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n  }\n}\nfunction clean(...arrays) {\n  for (let i = 0;i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\nfunction createView(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction rotr(word, shift) {\n  return word << 32 - shift | word >>> shift;\n}\nvar hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\nvar hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(bytes) {\n  abytes(bytes);\n  if (hasHexBuiltin)\n    return bytes.toHex();\n  let hex = \"\";\n  for (let i = 0;i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nvar asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n  if (ch >= asciis._0 && ch <= asciis._9)\n    return ch - asciis._0;\n  if (ch >= asciis.A && ch <= asciis.F)\n    return ch - (asciis.A - 10);\n  if (ch >= asciis.a && ch <= asciis.f)\n    return ch - (asciis.a - 10);\n  return;\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== \"string\")\n    throw new Error(\"hex string expected, got \" + typeof hex);\n  if (hasHexBuiltin)\n    return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2)\n    throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\nfunction concatBytes(...arrays) {\n  let sum = 0;\n  for (let i = 0;i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0;i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\nfunction createHasher(hashCons, info = {}) {\n  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n  const tmp = hashCons(undefined);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts) => hashCons(opts);\n  Object.assign(hashC, info);\n  return Object.freeze(hashC);\n}\nfunction randomBytes(bytesLength = 32) {\n  const cr = typeof globalThis === \"object\" ? globalThis.crypto : null;\n  if (typeof cr?.getRandomValues !== \"function\")\n    throw new Error(\"crypto.getRandomValues must be defined\");\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\nvar oidNist = (suffix) => ({\n  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])\n});\n\n// node_modules/@noble/hashes/_md.js\nfunction Chi(a, b, c) {\n  return a & b ^ ~a & c;\n}\nfunction Maj(a, b, c) {\n  return a & b ^ a & c ^ b & c;\n}\n\nclass HashMD {\n  blockLen;\n  outputLen;\n  padOffset;\n  isLE;\n  buffer;\n  view;\n  finished = false;\n  length = 0;\n  pos = 0;\n  destroyed = false;\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data) {\n    aexists(this);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0;pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (;blockLen <= len - pos; pos += blockLen)\n          this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    buffer[pos++] = 128;\n    clean(this.buffer.subarray(pos));\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    for (let i = pos;i < blockLen; i++)\n      buffer[i] = 0;\n    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    if (len % 4)\n      throw new Error(\"_sha2: outputLen must be aligned to 32bit\");\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let i = 0;i < outLen; i++)\n      oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to ||= new this.constructor;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen)\n      to.buffer.set(buffer);\n    return to;\n  }\n  clone() {\n    return this._cloneInto();\n  }\n}\nvar SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]);\nvar SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n  3238371032,\n  914150663,\n  812702999,\n  4144912697,\n  4290775857,\n  1750603025,\n  1694076839,\n  3204075428\n]);\nvar SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n  3418070365,\n  3238371032,\n  1654270250,\n  914150663,\n  2438529370,\n  812702999,\n  355462360,\n  4144912697,\n  1731405415,\n  4290775857,\n  2394180231,\n  1750603025,\n  3675008525,\n  1694076839,\n  1203062813,\n  3204075428\n]);\nvar SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n  1779033703,\n  4089235720,\n  3144134277,\n  2227873595,\n  1013904242,\n  4271175723,\n  2773480762,\n  1595750129,\n  1359893119,\n  2917565137,\n  2600822924,\n  725511199,\n  528734635,\n  4215389547,\n  1541459225,\n  327033209\n]);\n\n// node_modules/@noble/hashes/_u64.js\nvar U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nvar _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n  if (le)\n    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };\n  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0;i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\nvar shrSH = (h, _l, s) => h >>> s;\nvar shrSL = (h, l, s) => h << 32 - s | l >>> s;\nvar rotrSH = (h, l, s) => h >>> s | l << 32 - s;\nvar rotrSL = (h, l, s) => h << 32 - s | l >>> s;\nvar rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;\nvar rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;\nfunction add(Ah, Al, Bh, Bl) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };\n}\nvar add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nvar add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nvar add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nvar add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nvar add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nvar add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n\n// node_modules/@noble/hashes/sha2.js\nvar SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]);\nvar SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n\nclass SHA2_32B extends HashMD {\n  constructor(outputLen) {\n    super(64, outputLen, 8, false);\n  }\n  get() {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  set(A, B, C, D, E, F, G, H) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  process(view, offset) {\n    for (let i = 0;i < 16; i++, offset += 4)\n      SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16;i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;\n      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n    }\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0;i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = sigma0 + Maj(A, B, C) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = D + T1 | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = T1 + T2 | 0;\n    }\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    E = E + this.E | 0;\n    F = F + this.F | 0;\n    G = G + this.G | 0;\n    H = H + this.H | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  roundClean() {\n    clean(SHA256_W);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nclass _SHA256 extends SHA2_32B {\n  A = SHA256_IV[0] | 0;\n  B = SHA256_IV[1] | 0;\n  C = SHA256_IV[2] | 0;\n  D = SHA256_IV[3] | 0;\n  E = SHA256_IV[4] | 0;\n  F = SHA256_IV[5] | 0;\n  G = SHA256_IV[6] | 0;\n  H = SHA256_IV[7] | 0;\n  constructor() {\n    super(32);\n  }\n}\n\nclass _SHA224 extends SHA2_32B {\n  A = SHA224_IV[0] | 0;\n  B = SHA224_IV[1] | 0;\n  C = SHA224_IV[2] | 0;\n  D = SHA224_IV[3] | 0;\n  E = SHA224_IV[4] | 0;\n  F = SHA224_IV[5] | 0;\n  G = SHA224_IV[6] | 0;\n  H = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\nvar K512 = /* @__PURE__ */ (() => split([\n  \"0x428a2f98d728ae22\",\n  \"0x7137449123ef65cd\",\n  \"0xb5c0fbcfec4d3b2f\",\n  \"0xe9b5dba58189dbbc\",\n  \"0x3956c25bf348b538\",\n  \"0x59f111f1b605d019\",\n  \"0x923f82a4af194f9b\",\n  \"0xab1c5ed5da6d8118\",\n  \"0xd807aa98a3030242\",\n  \"0x12835b0145706fbe\",\n  \"0x243185be4ee4b28c\",\n  \"0x550c7dc3d5ffb4e2\",\n  \"0x72be5d74f27b896f\",\n  \"0x80deb1fe3b1696b1\",\n  \"0x9bdc06a725c71235\",\n  \"0xc19bf174cf692694\",\n  \"0xe49b69c19ef14ad2\",\n  \"0xefbe4786384f25e3\",\n  \"0x0fc19dc68b8cd5b5\",\n  \"0x240ca1cc77ac9c65\",\n  \"0x2de92c6f592b0275\",\n  \"0x4a7484aa6ea6e483\",\n  \"0x5cb0a9dcbd41fbd4\",\n  \"0x76f988da831153b5\",\n  \"0x983e5152ee66dfab\",\n  \"0xa831c66d2db43210\",\n  \"0xb00327c898fb213f\",\n  \"0xbf597fc7beef0ee4\",\n  \"0xc6e00bf33da88fc2\",\n  \"0xd5a79147930aa725\",\n  \"0x06ca6351e003826f\",\n  \"0x142929670a0e6e70\",\n  \"0x27b70a8546d22ffc\",\n  \"0x2e1b21385c26c926\",\n  \"0x4d2c6dfc5ac42aed\",\n  \"0x53380d139d95b3df\",\n  \"0x650a73548baf63de\",\n  \"0x766a0abb3c77b2a8\",\n  \"0x81c2c92e47edaee6\",\n  \"0x92722c851482353b\",\n  \"0xa2bfe8a14cf10364\",\n  \"0xa81a664bbc423001\",\n  \"0xc24b8b70d0f89791\",\n  \"0xc76c51a30654be30\",\n  \"0xd192e819d6ef5218\",\n  \"0xd69906245565a910\",\n  \"0xf40e35855771202a\",\n  \"0x106aa07032bbd1b8\",\n  \"0x19a4c116b8d2d0c8\",\n  \"0x1e376c085141ab53\",\n  \"0x2748774cdf8eeb99\",\n  \"0x34b0bcb5e19b48a8\",\n  \"0x391c0cb3c5c95a63\",\n  \"0x4ed8aa4ae3418acb\",\n  \"0x5b9cca4f7763e373\",\n  \"0x682e6ff3d6b2b8a3\",\n  \"0x748f82ee5defb2fc\",\n  \"0x78a5636f43172f60\",\n  \"0x84c87814a1f0ab72\",\n  \"0x8cc702081a6439ec\",\n  \"0x90befffa23631e28\",\n  \"0xa4506cebde82bde9\",\n  \"0xbef9a3f7b2c67915\",\n  \"0xc67178f2e372532b\",\n  \"0xca273eceea26619c\",\n  \"0xd186b8c721c0c207\",\n  \"0xeada7dd6cde0eb1e\",\n  \"0xf57d4f7fee6ed178\",\n  \"0x06f067aa72176fba\",\n  \"0x0a637dc5a2c898a6\",\n  \"0x113f9804bef90dae\",\n  \"0x1b710b35131c471b\",\n  \"0x28db77f523047d84\",\n  \"0x32caab7b40c72493\",\n  \"0x3c9ebe0a15c9bebc\",\n  \"0x431d67c49c100d4c\",\n  \"0x4cc5d4becb3e42b6\",\n  \"0x597f299cfc657e2a\",\n  \"0x5fcb6fab3ad6faec\",\n  \"0x6c44198c4a475817\"\n].map((n) => BigInt(n))))();\nvar SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nvar SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\nvar SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nvar SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nclass SHA2_64B extends HashMD {\n  constructor(outputLen) {\n    super(128, outputLen, 16, false);\n  }\n  get() {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  process(view, offset) {\n    for (let i = 0;i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32(offset += 4);\n    }\n    for (let i = 16;i < 80; i++) {\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);\n      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);\n      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);\n      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    for (let i = 0;i < 80; i++) {\n      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);\n      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);\n      const CHIh = Eh & Fh ^ ~Eh & Gh;\n      const CHIl = El & Fl ^ ~El & Gl;\n      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);\n      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);\n      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = add3L(T1l, sigma0l, MAJl);\n      Ah = add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  roundClean() {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy() {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nclass _SHA512 extends SHA2_64B {\n  Ah = SHA512_IV[0] | 0;\n  Al = SHA512_IV[1] | 0;\n  Bh = SHA512_IV[2] | 0;\n  Bl = SHA512_IV[3] | 0;\n  Ch = SHA512_IV[4] | 0;\n  Cl = SHA512_IV[5] | 0;\n  Dh = SHA512_IV[6] | 0;\n  Dl = SHA512_IV[7] | 0;\n  Eh = SHA512_IV[8] | 0;\n  El = SHA512_IV[9] | 0;\n  Fh = SHA512_IV[10] | 0;\n  Fl = SHA512_IV[11] | 0;\n  Gh = SHA512_IV[12] | 0;\n  Gl = SHA512_IV[13] | 0;\n  Hh = SHA512_IV[14] | 0;\n  Hl = SHA512_IV[15] | 0;\n  constructor() {\n    super(64);\n  }\n}\n\nclass _SHA384 extends SHA2_64B {\n  Ah = SHA384_IV[0] | 0;\n  Al = SHA384_IV[1] | 0;\n  Bh = SHA384_IV[2] | 0;\n  Bl = SHA384_IV[3] | 0;\n  Ch = SHA384_IV[4] | 0;\n  Cl = SHA384_IV[5] | 0;\n  Dh = SHA384_IV[6] | 0;\n  Dl = SHA384_IV[7] | 0;\n  Eh = SHA384_IV[8] | 0;\n  El = SHA384_IV[9] | 0;\n  Fh = SHA384_IV[10] | 0;\n  Fl = SHA384_IV[11] | 0;\n  Gh = SHA384_IV[12] | 0;\n  Gl = SHA384_IV[13] | 0;\n  Hh = SHA384_IV[14] | 0;\n  Hl = SHA384_IV[15] | 0;\n  constructor() {\n    super(48);\n  }\n}\nvar T224_IV = /* @__PURE__ */ Uint32Array.from([\n  2352822216,\n  424955298,\n  1944164710,\n  2312950998,\n  502970286,\n  855612546,\n  1738396948,\n  1479516111,\n  258812777,\n  2077511080,\n  2011393907,\n  79989058,\n  1067287976,\n  1780299464,\n  286451373,\n  2446758561\n]);\nvar T256_IV = /* @__PURE__ */ Uint32Array.from([\n  573645204,\n  4230739756,\n  2673172387,\n  3360449730,\n  596883563,\n  1867755857,\n  2520282905,\n  1497426621,\n  2519219938,\n  2827943907,\n  3193839141,\n  1401305490,\n  721525244,\n  746961066,\n  246885852,\n  2177182882\n]);\n\nclass _SHA512_224 extends SHA2_64B {\n  Ah = T224_IV[0] | 0;\n  Al = T224_IV[1] | 0;\n  Bh = T224_IV[2] | 0;\n  Bl = T224_IV[3] | 0;\n  Ch = T224_IV[4] | 0;\n  Cl = T224_IV[5] | 0;\n  Dh = T224_IV[6] | 0;\n  Dl = T224_IV[7] | 0;\n  Eh = T224_IV[8] | 0;\n  El = T224_IV[9] | 0;\n  Fh = T224_IV[10] | 0;\n  Fl = T224_IV[11] | 0;\n  Gh = T224_IV[12] | 0;\n  Gl = T224_IV[13] | 0;\n  Hh = T224_IV[14] | 0;\n  Hl = T224_IV[15] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\nclass _SHA512_256 extends SHA2_64B {\n  Ah = T256_IV[0] | 0;\n  Al = T256_IV[1] | 0;\n  Bh = T256_IV[2] | 0;\n  Bl = T256_IV[3] | 0;\n  Ch = T256_IV[4] | 0;\n  Cl = T256_IV[5] | 0;\n  Dh = T256_IV[6] | 0;\n  Dl = T256_IV[7] | 0;\n  Eh = T256_IV[8] | 0;\n  El = T256_IV[9] | 0;\n  Fh = T256_IV[10] | 0;\n  Fl = T256_IV[11] | 0;\n  Gh = T256_IV[12] | 0;\n  Gl = T256_IV[13] | 0;\n  Hh = T256_IV[14] | 0;\n  Hl = T256_IV[15] | 0;\n  constructor() {\n    super(32);\n  }\n}\nvar sha256 = /* @__PURE__ */ createHasher(() => new _SHA256, /* @__PURE__ */ oidNist(1));\nvar sha512 = /* @__PURE__ */ createHasher(() => new _SHA512, /* @__PURE__ */ oidNist(3));\n\n// node_modules/@noble/curves/utils.js\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _0n = /* @__PURE__ */ BigInt(0);\nvar _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(value, title = \"\") {\n  if (typeof value !== \"boolean\") {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(prefix + \"expected boolean, got type=\" + typeof value);\n  }\n  return value;\n}\nfunction abignumber(n) {\n  if (typeof n === \"bigint\") {\n    if (!isPosBig(n))\n      throw new Error(\"positive bigint expected, got \" + n);\n  } else\n    anumber(n);\n  return n;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== \"string\")\n    throw new Error(\"hex string expected, got \" + typeof hex);\n  return hex === \"\" ? _0n : BigInt(\"0x\" + hex);\n}\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n  return hexToNumber(bytesToHex(copyBytes(abytes(bytes)).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n  anumber(len);\n  n = abignumber(n);\n  const res = hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n  if (res.length !== len)\n    throw new Error(\"number too large\");\n  return res;\n}\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\nfunction copyBytes(bytes) {\n  return Uint8Array.from(bytes);\n}\nvar isPosBig = (n) => typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\nfunction aInRange(title, n, min, max) {\n  if (!inRange(n, min, max))\n    throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\nvar bitMask = (n) => (_1n << BigInt(n)) - _1n;\nfunction validateObject(object, fields = {}, optFields = {}) {\n  if (!object || typeof object !== \"object\")\n    throw new Error(\"expected valid options object\");\n  function checkField(fieldName, expectedType, isOpt) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined)\n      return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n  iter(fields, false);\n  iter(optFields, true);\n}\nfunction memoized(fn) {\n  const map = new WeakMap;\n  return (arg, ...args) => {\n    const val = map.get(arg);\n    if (val !== undefined)\n      return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n\n// node_modules/@noble/curves/abstract/modular.js\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _0n2 = /* @__PURE__ */ BigInt(0);\nvar _1n2 = /* @__PURE__ */ BigInt(1);\nvar _2n = /* @__PURE__ */ BigInt(2);\nvar _3n = /* @__PURE__ */ BigInt(3);\nvar _4n = /* @__PURE__ */ BigInt(4);\nvar _5n = /* @__PURE__ */ BigInt(5);\nvar _7n = /* @__PURE__ */ BigInt(7);\nvar _8n = /* @__PURE__ */ BigInt(8);\nvar _9n = /* @__PURE__ */ BigInt(9);\nvar _16n = /* @__PURE__ */ BigInt(16);\nfunction mod(a, b) {\n  const result = a % b;\n  return result >= _0n2 ? result : b + result;\n}\nfunction pow2(x, power, modulo) {\n  let res = x;\n  while (power-- > _0n2) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\nfunction invert(number, modulo) {\n  if (number === _0n2)\n    throw new Error(\"invert: expected non-zero number\");\n  if (modulo <= _0n2)\n    throw new Error(\"invert: expected positive modulus, got \" + modulo);\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;\n  while (a !== _0n2) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n2)\n    throw new Error(\"invert: does not exist\");\n  return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n  if (!Fp.eql(Fp.sqr(root), n))\n    throw new Error(\"Cannot find square root\");\n}\nfunction sqrt3mod4(Fp, n) {\n  const p1div4 = (Fp.ORDER + _1n2) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\nfunction sqrt5mod8(Fp, n) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\nfunction sqrt9mod16(P) {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));\n  const c2 = tn(Fp_, c1);\n  const c3 = tn(Fp_, Fp_.neg(c1));\n  const c4 = (P + _7n) / _16n;\n  return (Fp, n) => {\n    let tv1 = Fp.pow(n, c4);\n    let tv2 = Fp.mul(tv1, c1);\n    const tv3 = Fp.mul(tv1, c2);\n    const tv4 = Fp.mul(tv1, c3);\n    const e1 = Fp.eql(Fp.sqr(tv2), n);\n    const e2 = Fp.eql(Fp.sqr(tv3), n);\n    tv1 = Fp.cmov(tv1, tv2, e1);\n    tv2 = Fp.cmov(tv4, tv3, e2);\n    const e3 = Fp.eql(Fp.sqr(tv2), n);\n    const root = Fp.cmov(tv1, tv2, e3);\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\nfunction tonelliShanks(P) {\n  if (P < _3n)\n    throw new Error(\"sqrt is not defined for small field\");\n  let Q = P - _1n2;\n  let S = 0;\n  while (Q % _2n === _0n2) {\n    Q /= _2n;\n    S++;\n  }\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    if (Z++ > 1000)\n      throw new Error(\"Cannot find square root: probably non-prime P\");\n  }\n  if (S === 1)\n    return sqrt3mod4;\n  let cc = _Fp.pow(Z, Q);\n  const Q1div2 = (Q + _1n2) / _2n;\n  return function tonelliSlow(Fp, n) {\n    if (Fp.is0(n))\n      return n;\n    if (FpLegendre(Fp, n) !== 1)\n      throw new Error(\"Cannot find square root\");\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc);\n    let t = Fp.pow(n, Q);\n    let R = Fp.pow(n, Q1div2);\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t))\n        return Fp.ZERO;\n      let i = 1;\n      let t_tmp = Fp.sqr(t);\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp);\n        if (i === M)\n          throw new Error(\"Cannot find square root\");\n      }\n      const exponent = _1n2 << BigInt(M - i - 1);\n      const b = Fp.pow(c, exponent);\n      M = i;\n      c = Fp.sqr(b);\n      t = Fp.mul(t, c);\n      R = Fp.mul(R, b);\n    }\n    return R;\n  };\n}\nfunction FpSqrt(P) {\n  if (P % _4n === _3n)\n    return sqrt3mod4;\n  if (P % _8n === _5n)\n    return sqrt5mod8;\n  if (P % _16n === _9n)\n    return sqrt9mod16(P);\n  return tonelliShanks(P);\n}\nvar isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;\nvar FIELD_FIELDS = [\n  \"create\",\n  \"isValid\",\n  \"is0\",\n  \"neg\",\n  \"inv\",\n  \"sqrt\",\n  \"sqr\",\n  \"eql\",\n  \"add\",\n  \"sub\",\n  \"mul\",\n  \"pow\",\n  \"div\",\n  \"addN\",\n  \"subN\",\n  \"mulN\",\n  \"sqrN\"\n];\nfunction validateField(field) {\n  const initial = {\n    ORDER: \"bigint\",\n    BYTES: \"number\",\n    BITS: \"number\"\n  };\n  const opts = FIELD_FIELDS.reduce((map, val) => {\n    map[val] = \"function\";\n    return map;\n  }, initial);\n  validateObject(field, opts);\n  return field;\n}\nfunction FpPow(Fp, num, power) {\n  if (power < _0n2)\n    throw new Error(\"invalid exponent, negatives unsupported\");\n  if (power === _0n2)\n    return Fp.ONE;\n  if (power === _1n2)\n    return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n2) {\n    if (power & _1n2)\n      p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n2;\n  }\n  return p;\n}\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num))\n      return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  const invertedAcc = Fp.inv(multipliedAcc);\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num))\n      return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\nfunction FpLegendre(Fp, n) {\n  const p1mod2 = (Fp.ORDER - _1n2) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no)\n    throw new Error(\"invalid Legendre symbol result\");\n  return yes ? 1 : zero ? 0 : -1;\n}\nfunction nLength(n, nBitLength) {\n  if (nBitLength !== undefined)\n    anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\nclass _Field {\n  ORDER;\n  BITS;\n  BYTES;\n  isLE;\n  ZERO = _0n2;\n  ONE = _1n2;\n  _lengths;\n  _sqrt;\n  _mod;\n  constructor(ORDER, opts = {}) {\n    if (ORDER <= _0n2)\n      throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    let _nbitLength = undefined;\n    this.isLE = false;\n    if (opts != null && typeof opts === \"object\") {\n      if (typeof opts.BITS === \"number\")\n        _nbitLength = opts.BITS;\n      if (typeof opts.sqrt === \"function\")\n        this.sqrt = opts.sqrt;\n      if (typeof opts.isLE === \"boolean\")\n        this.isLE = opts.isLE;\n      if (opts.allowedLengths)\n        this._lengths = opts.allowedLengths?.slice();\n      if (typeof opts.modFromBytes === \"boolean\")\n        this._mod = opts.modFromBytes;\n    }\n    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n    if (nByteLength > 2048)\n      throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    this.ORDER = ORDER;\n    this.BITS = nBitLength;\n    this.BYTES = nByteLength;\n    this._sqrt = undefined;\n    Object.preventExtensions(this);\n  }\n  create(num) {\n    return mod(num, this.ORDER);\n  }\n  isValid(num) {\n    if (typeof num !== \"bigint\")\n      throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n    return _0n2 <= num && num < this.ORDER;\n  }\n  is0(num) {\n    return num === _0n2;\n  }\n  isValidNot0(num) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  isOdd(num) {\n    return (num & _1n2) === _1n2;\n  }\n  neg(num) {\n    return mod(-num, this.ORDER);\n  }\n  eql(lhs, rhs) {\n    return lhs === rhs;\n  }\n  sqr(num) {\n    return mod(num * num, this.ORDER);\n  }\n  add(lhs, rhs) {\n    return mod(lhs + rhs, this.ORDER);\n  }\n  sub(lhs, rhs) {\n    return mod(lhs - rhs, this.ORDER);\n  }\n  mul(lhs, rhs) {\n    return mod(lhs * rhs, this.ORDER);\n  }\n  pow(num, power) {\n    return FpPow(this, num, power);\n  }\n  div(lhs, rhs) {\n    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n  }\n  sqrN(num) {\n    return num * num;\n  }\n  addN(lhs, rhs) {\n    return lhs + rhs;\n  }\n  subN(lhs, rhs) {\n    return lhs - rhs;\n  }\n  mulN(lhs, rhs) {\n    return lhs * rhs;\n  }\n  inv(num) {\n    return invert(num, this.ORDER);\n  }\n  sqrt(num) {\n    if (!this._sqrt)\n      this._sqrt = FpSqrt(this.ORDER);\n    return this._sqrt(this, num);\n  }\n  toBytes(num) {\n    return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n  }\n  fromBytes(bytes, skipValidation = false) {\n    abytes(bytes);\n    const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n    if (allowedLengths) {\n      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n        throw new Error(\"Field.fromBytes: expected \" + allowedLengths + \" bytes, got \" + bytes.length);\n      }\n      const padded = new Uint8Array(BYTES);\n      padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n      bytes = padded;\n    }\n    if (bytes.length !== BYTES)\n      throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n    let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    if (modFromBytes)\n      scalar = mod(scalar, ORDER);\n    if (!skipValidation) {\n      if (!this.isValid(scalar))\n        throw new Error(\"invalid field element: outside of range 0..ORDER\");\n    }\n    return scalar;\n  }\n  invertBatch(lst) {\n    return FpInvertBatch(this, lst);\n  }\n  cmov(a, b, condition) {\n    return condition ? b : a;\n  }\n}\nfunction Field(ORDER, opts = {}) {\n  return new _Field(ORDER, opts);\n}\n\n// node_modules/@noble/curves/abstract/curve.js\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _0n3 = /* @__PURE__ */ BigInt(0);\nvar _1n3 = /* @__PURE__ */ BigInt(1);\nfunction negateCt(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\nfunction normalizeZ(c, points) {\n  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1;\n  const windowSize = 2 ** (W - 1);\n  const maxNumber = 2 ** W;\n  const mask = bitMask(W);\n  const shiftBy = BigInt(W);\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window2, wOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask);\n  let nextN = n >> shiftBy;\n  if (wbits > windowSize) {\n    wbits -= maxNumber;\n    nextN += _1n3;\n  }\n  const offsetStart = window2 * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1;\n  const isZero = wbits === 0;\n  const isNeg = wbits < 0;\n  const isNegF = window2 % 2 !== 0;\n  const offsetF = offsetStart;\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nvar pointPrecomputes = new WeakMap;\nvar pointWindowSizes = new WeakMap;\nfunction getW(P) {\n  return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n  if (n !== _0n3)\n    throw new Error(\"invalid wNAF\");\n}\n\nclass wNAF {\n  BASE;\n  ZERO;\n  Fn;\n  bits;\n  constructor(Point, bits) {\n    this.BASE = Point.BASE;\n    this.ZERO = Point.ZERO;\n    this.Fn = Point.Fn;\n    this.bits = bits;\n  }\n  _unsafeLadder(elm, n, p = this.ZERO) {\n    let d = elm;\n    while (n > _0n3) {\n      if (n & _1n3)\n        p = p.add(d);\n      d = d.double();\n      n >>= _1n3;\n    }\n    return p;\n  }\n  precomputeWindow(point, W) {\n    const { windows, windowSize } = calcWOpts(W, this.bits);\n    const points = [];\n    let p = point;\n    let base = p;\n    for (let window2 = 0;window2 < windows; window2++) {\n      base = p;\n      points.push(base);\n      for (let i = 1;i < windowSize; i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n  wNAF(W, precomputes, n) {\n    if (!this.Fn.isValid(n))\n      throw new Error(\"invalid scalar\");\n    let p = this.ZERO;\n    let f = this.BASE;\n    const wo = calcWOpts(W, this.bits);\n    for (let window2 = 0;window2 < wo.windows; window2++) {\n      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);\n      n = nextN;\n      if (isZero) {\n        f = f.add(negateCt(isNegF, precomputes[offsetF]));\n      } else {\n        p = p.add(negateCt(isNeg, precomputes[offset]));\n      }\n    }\n    assert0(n);\n    return { p, f };\n  }\n  wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n    const wo = calcWOpts(W, this.bits);\n    for (let window2 = 0;window2 < wo.windows; window2++) {\n      if (n === _0n3)\n        break;\n      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);\n      n = nextN;\n      if (isZero) {\n        continue;\n      } else {\n        const item = precomputes[offset];\n        acc = acc.add(isNeg ? item.negate() : item);\n      }\n    }\n    assert0(n);\n    return acc;\n  }\n  getPrecomputes(W, point, transform) {\n    let comp = pointPrecomputes.get(point);\n    if (!comp) {\n      comp = this.precomputeWindow(point, W);\n      if (W !== 1) {\n        if (typeof transform === \"function\")\n          comp = transform(comp);\n        pointPrecomputes.set(point, comp);\n      }\n    }\n    return comp;\n  }\n  cached(point, scalar, transform) {\n    const W = getW(point);\n    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n  }\n  unsafe(point, scalar, transform, prev) {\n    const W = getW(point);\n    if (W === 1)\n      return this._unsafeLadder(point, scalar, prev);\n    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n  }\n  createCache(P, W) {\n    validateW(W, this.bits);\n    pointWindowSizes.set(P, W);\n    pointPrecomputes.delete(P);\n  }\n  hasCache(elm) {\n    return getW(elm) !== 1;\n  }\n}\nfunction createField(order, field, isLE) {\n  if (field) {\n    if (field.ORDER !== order)\n      throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n    validateField(field);\n    return field;\n  } else {\n    return Field(order, { isLE });\n  }\n}\nfunction createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n  if (FpFnLE === undefined)\n    FpFnLE = type === \"edwards\";\n  if (!CURVE || typeof CURVE !== \"object\")\n    throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of [\"p\", \"n\", \"h\"]) {\n    const val = CURVE[p];\n    if (!(typeof val === \"bigint\" && val > _0n3))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n  const _b = type === \"weierstrass\" ? \"b\" : \"d\";\n  const params = [\"Gx\", \"Gy\", \"a\", _b];\n  for (const p of params) {\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  CURVE = Object.freeze(Object.assign({}, CURVE));\n  return { CURVE, Fp, Fn };\n}\nfunction createKeygen(randomSecretKey, getPublicKey) {\n  return function keygen(seed) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  };\n}\n\n// node_modules/@noble/curves/abstract/edwards.js\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _0n4 = BigInt(0);\nvar _1n4 = BigInt(1);\nvar _2n2 = BigInt(2);\nvar _8n2 = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\nfunction edwards(params, extraOpts = {}) {\n  const validated = createCurveFields(\"edwards\", params, extraOpts, extraOpts.FpFnLE);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE;\n  const { h: cofactor } = CURVE;\n  validateObject(extraOpts, {}, { uvRatio: \"function\" });\n  const MASK = _2n2 << BigInt(Fn.BYTES * 8) - _1n4;\n  const modP = (n) => Fp.create(n);\n  const uvRatio = extraOpts.uvRatio || ((u, v) => {\n    try {\n      return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n    } catch (e) {\n      return { isValid: false, value: _0n4 };\n    }\n  });\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error(\"bad curve params: generator point\");\n  function acoord(title, n, banZero = false) {\n    const min = banZero ? _1n4 : _0n4;\n    aInRange(\"coordinate \" + title, n, min, MASK);\n    return n;\n  }\n  function aedpoint(other) {\n    if (!(other instanceof Point))\n      throw new Error(\"EdwardsPoint expected\");\n  }\n  const toAffineMemo = memoized((p, iz) => {\n    const { X, Y, Z } = p;\n    const is0 = p.is0();\n    if (iz == null)\n      iz = is0 ? _8n2 : Fp.inv(Z);\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0)\n      return { x: _0n4, y: _1n4 };\n    if (zz !== _1n4)\n      throw new Error(\"invZ was invalid\");\n    return { x, y };\n  });\n  const assertValidMemo = memoized((p) => {\n    const { a, d } = CURVE;\n    if (p.is0())\n      throw new Error(\"bad point: ZERO\");\n    const { X, Y, Z, T } = p;\n    const X2 = modP(X * X);\n    const Y2 = modP(Y * Y);\n    const Z2 = modP(Z * Z);\n    const Z4 = modP(Z2 * Z2);\n    const aX2 = modP(X2 * a);\n    const left = modP(Z2 * modP(aX2 + Y2));\n    const right = modP(Z4 + modP(d * modP(X2 * Y2)));\n    if (left !== right)\n      throw new Error(\"bad point: equation left != right (1)\");\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT)\n      throw new Error(\"bad point: equation left != right (2)\");\n    return true;\n  });\n\n  class Point {\n    static BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));\n    static ZERO = new Point(_0n4, _1n4, _1n4, _0n4);\n    static Fp = Fp;\n    static Fn = Fn;\n    X;\n    Y;\n    Z;\n    T;\n    constructor(X, Y, Z, T) {\n      this.X = acoord(\"x\", X);\n      this.Y = acoord(\"y\", Y);\n      this.Z = acoord(\"z\", Z, true);\n      this.T = acoord(\"t\", T);\n      Object.freeze(this);\n    }\n    static CURVE() {\n      return CURVE;\n    }\n    static fromAffine(p) {\n      if (p instanceof Point)\n        throw new Error(\"extended point not allowed\");\n      const { x, y } = p || {};\n      acoord(\"x\", x);\n      acoord(\"y\", y);\n      return new Point(x, y, _1n4, modP(x * y));\n    }\n    static fromBytes(bytes, zip215 = false) {\n      const len = Fp.BYTES;\n      const { a, d } = CURVE;\n      bytes = copyBytes(abytes(bytes, len, \"point\"));\n      abool(zip215, \"zip215\");\n      const normed = copyBytes(bytes);\n      const lastByte = bytes[len - 1];\n      normed[len - 1] = lastByte & ~128;\n      const y = bytesToNumberLE(normed);\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange(\"point.y\", y, _0n4, max);\n      const y2 = modP(y * y);\n      const u = modP(y2 - _1n4);\n      const v = modP(d * y2 - a);\n      let { isValid, value: x } = uvRatio(u, v);\n      if (!isValid)\n        throw new Error(\"bad point: invalid y coordinate\");\n      const isXOdd = (x & _1n4) === _1n4;\n      const isLastByteOdd = (lastByte & 128) !== 0;\n      if (!zip215 && x === _0n4 && isLastByteOdd)\n        throw new Error(\"bad point: x=0 and x_0=1\");\n      if (isLastByteOdd !== isXOdd)\n        x = modP(-x);\n      return Point.fromAffine({ x, y });\n    }\n    static fromHex(hex, zip215 = false) {\n      return Point.fromBytes(hexToBytes(hex), zip215);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    precompute(windowSize = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy)\n        this.multiply(_2n2);\n      return this;\n    }\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    equals(other) {\n      aedpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    negate() {\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n    double() {\n      const { a } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const A = modP(X1 * X1);\n      const B = modP(Y1 * Y1);\n      const C = modP(_2n2 * modP(Z1 * Z1));\n      const D = modP(a * A);\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B);\n      const G = D + B;\n      const F = G - C;\n      const H = D - B;\n      const X3 = modP(E * F);\n      const Y3 = modP(G * H);\n      const T3 = modP(E * H);\n      const Z3 = modP(F * G);\n      return new Point(X3, Y3, Z3, T3);\n    }\n    add(other) {\n      aedpoint(other);\n      const { a, d } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n      const A = modP(X1 * X2);\n      const B = modP(Y1 * Y2);\n      const C = modP(T1 * d * T2);\n      const D = modP(Z1 * Z2);\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);\n      const F = D - C;\n      const G = D + C;\n      const H = modP(B - a * A);\n      const X3 = modP(E * F);\n      const Y3 = modP(G * H);\n      const T3 = modP(E * H);\n      const Z3 = modP(F * G);\n      return new Point(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    multiply(scalar) {\n      if (!Fn.isValidNot0(scalar))\n        throw new Error(\"invalid scalar: expected 1 <= sc < curve.n\");\n      const { p, f } = wnaf.cached(this, scalar, (p2) => normalizeZ(Point, p2));\n      return normalizeZ(Point, [p, f])[0];\n    }\n    multiplyUnsafe(scalar, acc = Point.ZERO) {\n      if (!Fn.isValid(scalar))\n        throw new Error(\"invalid scalar: expected 0 <= sc < curve.n\");\n      if (scalar === _0n4)\n        return Point.ZERO;\n      if (this.is0() || scalar === _1n4)\n        return this;\n      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n    }\n    isSmallOrder() {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n    isTorsionFree() {\n      return wnaf.unsafe(this, CURVE.n).is0();\n    }\n    toAffine(invertedZ) {\n      return toAffineMemo(this, invertedZ);\n    }\n    clearCofactor() {\n      if (cofactor === _1n4)\n        return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n    toBytes() {\n      const { x, y } = this.toAffine();\n      const bytes = Fp.toBytes(y);\n      bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;\n      return bytes;\n    }\n    toHex() {\n      return bytesToHex(this.toBytes());\n    }\n    toString() {\n      return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n    }\n  }\n  const wnaf = new wNAF(Point, Fn.BITS);\n  Point.BASE.precompute(8);\n  return Point;\n}\nfunction eddsa(Point, cHash, eddsaOpts = {}) {\n  if (typeof cHash !== \"function\")\n    throw new Error('\"hash\" function param is required');\n  validateObject(eddsaOpts, {}, {\n    adjustScalarBytes: \"function\",\n    randomBytes: \"function\",\n    domain: \"function\",\n    prehash: \"function\",\n    mapToCurve: \"function\"\n  });\n  const { prehash } = eddsaOpts;\n  const { BASE, Fp, Fn } = Point;\n  const randomBytes2 = eddsaOpts.randomBytes || randomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);\n  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {\n    abool(phflag, \"phflag\");\n    if (ctx.length || phflag)\n      throw new Error(\"Contexts/pre-hash are not supported\");\n    return data;\n  });\n  function modN_LE(hash) {\n    return Fn.create(bytesToNumberLE(hash));\n  }\n  function getPrivateScalar(key) {\n    const len = lengths.secretKey;\n    abytes(key, lengths.secretKey, \"secretKey\");\n    const hashed = abytes(cHash(key), 2 * len, \"hashedSecretKey\");\n    const head = adjustScalarBytes(hashed.slice(0, len));\n    const prefix = hashed.slice(len, 2 * len);\n    const scalar = modN_LE(head);\n    return { head, prefix, scalar };\n  }\n  function getExtendedPublicKey(secretKey) {\n    const { head, prefix, scalar } = getPrivateScalar(secretKey);\n    const point = BASE.multiply(scalar);\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n  function getPublicKey(secretKey) {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, abytes(context, undefined, \"context\"), !!prehash)));\n  }\n  function sign(msg, secretKey, options = {}) {\n    msg = abytes(msg, undefined, \"message\");\n    if (prehash)\n      msg = prehash(msg);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg);\n    const R = BASE.multiply(r).toBytes();\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg);\n    const s = Fn.create(r + k * scalar);\n    if (!Fn.isValid(s))\n      throw new Error(\"sign failed: invalid s\");\n    const rs = concatBytes(R, Fn.toBytes(s));\n    return abytes(rs, lengths.signature, \"result\");\n  }\n  const verifyOpts = { zip215: true };\n  function verify(sig, msg, publicKey, options = verifyOpts) {\n    const { context, zip215 } = options;\n    const len = lengths.signature;\n    sig = abytes(sig, len, \"signature\");\n    msg = abytes(msg, undefined, \"message\");\n    publicKey = abytes(publicKey, lengths.publicKey, \"publicKey\");\n    if (zip215 !== undefined)\n      abool(zip215, \"zip215\");\n    if (prehash)\n      msg = prehash(msg);\n    const mid = len / 2;\n    const r = sig.subarray(0, mid);\n    const s = bytesToNumberLE(sig.subarray(mid, len));\n    let A, R, SB;\n    try {\n      A = Point.fromBytes(publicKey, zip215);\n      R = Point.fromBytes(r, zip215);\n      SB = BASE.multiplyUnsafe(s);\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder())\n      return false;\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n  const _size = Fp.BYTES;\n  const lengths = {\n    secretKey: _size,\n    publicKey: _size,\n    signature: 2 * _size,\n    seed: _size\n  };\n  function randomSecretKey(seed = randomBytes2(lengths.seed)) {\n    return abytes(seed, lengths.seed, \"seed\");\n  }\n  function isValidSecretKey(key) {\n    return isBytes(key) && key.length === Fn.BYTES;\n  }\n  function isValidPublicKey(key, zip215) {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n  const utils = {\n    getExtendedPublicKey,\n    randomSecretKey,\n    isValidSecretKey,\n    isValidPublicKey,\n    toMontgomery(publicKey) {\n      const { y } = Point.fromBytes(publicKey);\n      const size = lengths.publicKey;\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57)\n        throw new Error(\"only defined for 25519 and 448\");\n      const u = is25519 ? Fp.div(_1n4 + y, _1n4 - y) : Fp.div(y - _1n4, y + _1n4);\n      return Fp.toBytes(u);\n    },\n    toMontgomerySecret(secretKey) {\n      const size = lengths.secretKey;\n      abytes(secretKey, size);\n      const hashed = cHash(secretKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    }\n  };\n  return Object.freeze({\n    keygen: createKeygen(randomSecretKey, getPublicKey),\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    lengths\n  });\n}\n\n// node_modules/@noble/curves/abstract/montgomery.js\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _0n5 = BigInt(0);\nvar _1n5 = BigInt(1);\nvar _2n3 = BigInt(2);\nfunction validateOpts(curve) {\n  validateObject(curve, {\n    adjustScalarBytes: \"function\",\n    powPminus2: \"function\"\n  });\n  return Object.freeze({ ...curve });\n}\nfunction montgomery(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n  const is25519 = type === \"x25519\";\n  if (!is25519 && type !== \"x448\")\n    throw new Error(\"invalid type\");\n  const randomBytes_ = rand || randomBytes;\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);\n  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;\n  const maxScalar = minScalar + maxAdded + _1n5;\n  const modP = (n) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u) {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u) {\n    const _u = copyBytes(abytes(u, fieldLen, \"uCoordinate\"));\n    if (is25519)\n      _u[31] &= 127;\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar) {\n    return bytesToNumberLE(adjustScalarBytes(copyBytes(abytes(scalar, fieldLen, \"scalar\"))));\n  }\n  function scalarMult(scalar, u) {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    if (pu === _0n5)\n      throw new Error(\"invalid private or public key received\");\n    return encodeU(pu);\n  }\n  function scalarMultBase(scalar) {\n    return scalarMult(scalar, GuBytes);\n  }\n  const getPublicKey = scalarMultBase;\n  const getSharedSecret = scalarMult;\n  function cswap(swap, x_2, x_3) {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return { x_2, x_3 };\n  }\n  function montgomeryLadder(u, scalar) {\n    aInRange(\"u\", u, _0n5, P);\n    aInRange(\"scalar\", scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n5;\n    let z_2 = _0n5;\n    let x_3 = u;\n    let z_3 = _1n5;\n    let swap = _0n5;\n    for (let t = BigInt(montgomeryBits - 1);t >= _0n5; t--) {\n      const k_t = k >> t & _1n5;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2);\n    return modP(x_2 * z2);\n  }\n  const lengths = {\n    secretKey: fieldLen,\n    publicKey: fieldLen,\n    seed: fieldLen\n  };\n  const randomSecretKey = (seed = randomBytes_(fieldLen)) => {\n    abytes(seed, lengths.seed, \"seed\");\n    return seed;\n  };\n  const utils = { randomSecretKey };\n  return Object.freeze({\n    keygen: createKeygen(randomSecretKey, getPublicKey),\n    getSharedSecret,\n    getPublicKey,\n    scalarMult,\n    scalarMultBase,\n    utils,\n    GuBytes: GuBytes.slice(),\n    lengths\n  });\n}\n\n// node_modules/@noble/curves/ed25519.js\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _1n6 = BigInt(1);\nvar _2n4 = BigInt(2);\nvar _3n2 = /* @__PURE__ */ BigInt(3);\nvar _5n2 = BigInt(5);\nvar _8n3 = BigInt(8);\nvar ed25519_CURVE_p = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\");\nvar ed25519_CURVE = /* @__PURE__ */ (() => ({\n  p: ed25519_CURVE_p,\n  n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n  h: _8n3,\n  a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n  d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n  Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n  Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n}))();\nfunction ed25519_pow_2_252_3(x) {\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ed25519_CURVE_p;\n  const x2 = x * x % P;\n  const b2 = x2 * x % P;\n  const b4 = pow2(b2, _2n4, P) * b2 % P;\n  const b5 = pow2(b4, _1n6, P) * x % P;\n  const b10 = pow2(b5, _5n2, P) * b5 % P;\n  const b20 = pow2(b10, _10n, P) * b10 % P;\n  const b40 = pow2(b20, _20n, P) * b20 % P;\n  const b80 = pow2(b40, _40n, P) * b40 % P;\n  const b160 = pow2(b80, _80n, P) * b80 % P;\n  const b240 = pow2(b160, _80n, P) * b80 % P;\n  const b250 = pow2(b240, _10n, P) * b10 % P;\n  const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;\n  return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n  bytes[0] &= 248;\n  bytes[31] &= 127;\n  bytes[31] |= 64;\n  return bytes;\n}\nvar ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\nfunction uvRatio(u, v) {\n  const P = ed25519_CURVE_p;\n  const v3 = mod(v * v * v, P);\n  const v7 = mod(v3 * v3 * v, P);\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P);\n  const vx2 = mod(v * x * x, P);\n  const root1 = x;\n  const root2 = mod(x * ED25519_SQRT_M1, P);\n  const useRoot1 = vx2 === u;\n  const useRoot2 = vx2 === mod(-u, P);\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);\n  if (useRoot1)\n    x = root1;\n  if (useRoot2 || noRoot)\n    x = root2;\n  if (isNegativeLE(x, P))\n    x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\nvar ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });\nfunction ed(opts) {\n  return eddsa(ed25519_Point, sha512, Object.assign({ adjustScalarBytes }, opts));\n}\nvar ed25519 = /* @__PURE__ */ ed({});\nvar x25519 = /* @__PURE__ */ (() => {\n  const P = ed25519_CURVE_p;\n  return montgomery({\n    P,\n    type: \"x25519\",\n    powPminus2: (x) => {\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);\n    },\n    adjustScalarBytes\n  });\n})();\n\n// src/form/client/signer.ts\nvar import_canonicalize = __toESM(require_canonicalize(), 1);\n\n// node_modules/cbor-x/decode.js\nvar decoder;\ntry {\n  decoder = new TextDecoder;\n} catch (error) {}\nvar src;\nvar srcEnd;\nvar position = 0;\nvar EMPTY_ARRAY = [];\nvar LEGACY_RECORD_INLINE_ID = 105;\nvar RECORD_DEFINITIONS_ID = 57342;\nvar RECORD_INLINE_ID = 57343;\nvar BUNDLED_STRINGS_ID = 57337;\nvar PACKED_REFERENCE_TAG_ID = 6;\nvar STOP_CODE = {};\nvar maxArraySize = 112810000;\nvar maxMapSize = 16810000;\nvar strings = EMPTY_ARRAY;\nvar stringPosition = 0;\nvar currentDecoder = {};\nvar currentStructures;\nvar srcString;\nvar srcStringStart = 0;\nvar srcStringEnd = 0;\nvar bundledStrings;\nvar referenceMap;\nvar currentExtensions = [];\nvar currentExtensionRanges = [];\nvar packedValues;\nvar dataView;\nvar restoreMapsAsObject;\nvar defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true\n};\nvar sequentialMode = false;\nvar inlineObjectReadThreshold = 2;\ntry {\n  new Function(\"\");\n} catch (error) {\n  inlineObjectReadThreshold = Infinity;\n}\n\nclass Decoder {\n  constructor(options) {\n    if (options) {\n      if ((options.keyMap || options._keyMap) && !options.useRecords) {\n        options.useRecords = false;\n        options.mapsAsObjects = true;\n      }\n      if (options.useRecords === false && options.mapsAsObjects === undefined)\n        options.mapsAsObjects = true;\n      if (options.getStructures)\n        options.getShared = options.getStructures;\n      if (options.getShared && !options.structures)\n        (options.structures = []).uninitialized = true;\n      if (options.keyMap) {\n        this.mapKey = new Map;\n        for (let [k, v] of Object.entries(options.keyMap))\n          this.mapKey.set(v, k);\n      }\n    }\n    Object.assign(this, options);\n  }\n  decodeKey(key) {\n    return this.keyMap ? this.mapKey.get(key) || key : key;\n  }\n  encodeKey(key) {\n    return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;\n  }\n  encodeKeys(rec) {\n    if (!this._keyMap)\n      return rec;\n    let map = new Map;\n    for (let [k, v] of Object.entries(rec))\n      map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);\n    return map;\n  }\n  decodeKeys(map) {\n    if (!this._keyMap || map.constructor.name != \"Map\")\n      return map;\n    if (!this._mapKey) {\n      this._mapKey = new Map;\n      for (let [k, v] of Object.entries(this._keyMap))\n        this._mapKey.set(v, k);\n    }\n    let res = {};\n    map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);\n    return res;\n  }\n  mapDecode(source, end) {\n    let res = this.decode(source);\n    if (this._keyMap) {\n      switch (res.constructor.name) {\n        case \"Array\":\n          return res.map((r) => this.decodeKeys(r));\n      }\n    }\n    return res;\n  }\n  decode(source, end) {\n    if (src) {\n      return saveState(() => {\n        clearSource();\n        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);\n      });\n    }\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    try {\n      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n    } catch (error) {\n      src = null;\n      if (source instanceof Uint8Array)\n        throw error;\n      throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source == \"object\" ? source.constructor.name : typeof source));\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n      if (this.structures) {\n        currentStructures = this.structures;\n        return checkedRead();\n      } else if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0)\n        currentStructures = [];\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n  decodeMultiple(source, forEach) {\n    let values, lastPosition = 0;\n    try {\n      let size = source.length;\n      sequentialMode = true;\n      let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);\n      if (forEach) {\n        if (forEach(value) === false) {\n          return;\n        }\n        while (position < size) {\n          lastPosition = position;\n          if (forEach(checkedRead()) === false) {\n            return;\n          }\n        }\n      } else {\n        values = [value];\n        while (position < size) {\n          lastPosition = position;\n          values.push(checkedRead());\n        }\n        return values;\n      }\n    } catch (error) {\n      error.lastPosition = lastPosition;\n      error.values = values;\n      throw error;\n    } finally {\n      sequentialMode = false;\n      clearSource();\n    }\n  }\n}\nfunction checkedRead() {\n  try {\n    let result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        let error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n    if (position == srcEnd) {\n      currentStructures = null;\n      src = null;\n      if (referenceMap)\n        referenceMap = null;\n    } else if (position > srcEnd) {\n      let error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else if (!sequentialMode) {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    return result;\n  } catch (error) {\n    clearSource();\n    if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\")) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\nfunction read() {\n  let token = src[position++];\n  let majorType = token >> 5;\n  token = token & 31;\n  if (token > 23) {\n    switch (token) {\n      case 24:\n        token = src[position++];\n        break;\n      case 25:\n        if (majorType == 7) {\n          return getFloat16();\n        }\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 26:\n        if (majorType == 7) {\n          let value = dataView.getFloat32(position);\n          if (currentDecoder.useFloat32 > 2) {\n            let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];\n            position += 4;\n            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n          }\n          position += 4;\n          return value;\n        }\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n      case 27:\n        if (majorType == 7) {\n          let value = dataView.getFloat64(position);\n          position += 8;\n          return value;\n        }\n        if (majorType > 1) {\n          if (dataView.getUint32(position) > 0)\n            throw new Error(\"JavaScript does not support arrays, maps, or strings with length over 4294967295\");\n          token = dataView.getUint32(position + 4);\n        } else if (currentDecoder.int64AsNumber) {\n          token = dataView.getUint32(position) * 4294967296;\n          token += dataView.getUint32(position + 4);\n        } else\n          token = dataView.getBigUint64(position);\n        position += 8;\n        break;\n      case 31:\n        switch (majorType) {\n          case 2:\n          case 3:\n            throw new Error(\"Indefinite length not supported for byte or text strings\");\n          case 4:\n            let array = [];\n            let value, i = 0;\n            while ((value = read()) != STOP_CODE) {\n              if (i >= maxArraySize)\n                throw new Error(`Array length exceeds ${maxArraySize}`);\n              array[i++] = value;\n            }\n            return majorType == 4 ? array : majorType == 3 ? array.join(\"\") : Buffer.concat(array);\n          case 5:\n            let key;\n            if (currentDecoder.mapsAsObjects) {\n              let object = {};\n              let i2 = 0;\n              if (currentDecoder.keyMap) {\n                while ((key = read()) != STOP_CODE) {\n                  if (i2++ >= maxMapSize)\n                    throw new Error(`Property count exceeds ${maxMapSize}`);\n                  object[safeKey(currentDecoder.decodeKey(key))] = read();\n                }\n              } else {\n                while ((key = read()) != STOP_CODE) {\n                  if (i2++ >= maxMapSize)\n                    throw new Error(`Property count exceeds ${maxMapSize}`);\n                  object[safeKey(key)] = read();\n                }\n              }\n              return object;\n            } else {\n              if (restoreMapsAsObject) {\n                currentDecoder.mapsAsObjects = true;\n                restoreMapsAsObject = false;\n              }\n              let map = new Map;\n              if (currentDecoder.keyMap) {\n                let i2 = 0;\n                while ((key = read()) != STOP_CODE) {\n                  if (i2++ >= maxMapSize) {\n                    throw new Error(`Map size exceeds ${maxMapSize}`);\n                  }\n                  map.set(currentDecoder.decodeKey(key), read());\n                }\n              } else {\n                let i2 = 0;\n                while ((key = read()) != STOP_CODE) {\n                  if (i2++ >= maxMapSize) {\n                    throw new Error(`Map size exceeds ${maxMapSize}`);\n                  }\n                  map.set(key, read());\n                }\n              }\n              return map;\n            }\n          case 7:\n            return STOP_CODE;\n          default:\n            throw new Error(\"Invalid major type for indefinite length \" + majorType);\n        }\n      default:\n        throw new Error(\"Unknown token \" + token);\n    }\n  }\n  switch (majorType) {\n    case 0:\n      return token;\n    case 1:\n      return ~token;\n    case 2:\n      return readBin(token);\n    case 3:\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n      }\n      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string != null)\n          return string;\n      }\n      return readFixedString(token);\n    case 4:\n      if (token >= maxArraySize)\n        throw new Error(`Array length exceeds ${maxArraySize}`);\n      let array = new Array(token);\n      for (let i = 0;i < token; i++)\n        array[i] = read();\n      return array;\n    case 5:\n      if (token >= maxMapSize)\n        throw new Error(`Map size exceeds ${maxArraySize}`);\n      if (currentDecoder.mapsAsObjects) {\n        let object = {};\n        if (currentDecoder.keyMap)\n          for (let i = 0;i < token; i++)\n            object[safeKey(currentDecoder.decodeKey(read()))] = read();\n        else\n          for (let i = 0;i < token; i++)\n            object[safeKey(read())] = read();\n        return object;\n      } else {\n        if (restoreMapsAsObject) {\n          currentDecoder.mapsAsObjects = true;\n          restoreMapsAsObject = false;\n        }\n        let map = new Map;\n        if (currentDecoder.keyMap)\n          for (let i = 0;i < token; i++)\n            map.set(currentDecoder.decodeKey(read()), read());\n        else\n          for (let i = 0;i < token; i++)\n            map.set(read(), read());\n        return map;\n      }\n    case 6:\n      if (token >= BUNDLED_STRINGS_ID) {\n        let structure = currentStructures[token & 8191];\n        if (structure) {\n          if (!structure.read)\n            structure.read = createStructureReader(structure);\n          return structure.read();\n        }\n        if (token < 65536) {\n          if (token == RECORD_INLINE_ID) {\n            let length = readJustLength();\n            let id = read();\n            let structure2 = read();\n            recordDefinition(id, structure2);\n            let object = {};\n            if (currentDecoder.keyMap)\n              for (let i = 2;i < length; i++) {\n                let key = currentDecoder.decodeKey(structure2[i - 2]);\n                object[safeKey(key)] = read();\n              }\n            else\n              for (let i = 2;i < length; i++) {\n                let key = structure2[i - 2];\n                object[safeKey(key)] = read();\n              }\n            return object;\n          } else if (token == RECORD_DEFINITIONS_ID) {\n            let length = readJustLength();\n            let id = read();\n            for (let i = 2;i < length; i++) {\n              recordDefinition(id++, read());\n            }\n            return read();\n          } else if (token == BUNDLED_STRINGS_ID) {\n            return readBundleExt();\n          }\n          if (currentDecoder.getShared) {\n            loadShared();\n            structure = currentStructures[token & 8191];\n            if (structure) {\n              if (!structure.read)\n                structure.read = createStructureReader(structure);\n              return structure.read();\n            }\n          }\n        }\n      }\n      let extension = currentExtensions[token];\n      if (extension) {\n        if (extension.handlesRead)\n          return extension(read);\n        else\n          return extension(read());\n      } else {\n        let input = read();\n        for (let i = 0;i < currentExtensionRanges.length; i++) {\n          let value = currentExtensionRanges[i](token, input);\n          if (value !== undefined)\n            return value;\n        }\n        return new Tag(input, token);\n      }\n    case 7:\n      switch (token) {\n        case 20:\n          return false;\n        case 21:\n          return true;\n        case 22:\n          return null;\n        case 23:\n          return;\n        case 31:\n        default:\n          let packedValue = (packedValues || getPackedValues())[token];\n          if (packedValue !== undefined)\n            return packedValue;\n          throw new Error(\"Unknown token \" + token);\n      }\n    default:\n      if (isNaN(token)) {\n        let error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(\"Unknown CBOR token \" + token);\n  }\n}\nvar validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure) {\n  if (!structure)\n    throw new Error(\"Structure is required in record definition\");\n  function readObject() {\n    let length = src[position++];\n    length = length & 31;\n    if (length > 23) {\n      switch (length) {\n        case 24:\n          length = src[position++];\n          break;\n        case 25:\n          length = dataView.getUint16(position);\n          position += 2;\n          break;\n        case 26:\n          length = dataView.getUint32(position);\n          position += 4;\n          break;\n        default:\n          throw new Error(\"Expected array header, but got \" + src[position - 1]);\n      }\n    }\n    let compiledReader = this.compiledReader;\n    while (compiledReader) {\n      if (compiledReader.propertyCount === length)\n        return compiledReader(read);\n      compiledReader = compiledReader.next;\n    }\n    if (this.slowReads++ >= inlineObjectReadThreshold) {\n      let array = this.length == length ? this : this.slice(0, length);\n      compiledReader = currentDecoder.keyMap ? new Function(\"r\", \"return {\" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + \":r()\" : \"[\" + JSON.stringify(k) + \"]:r()\").join(\",\") + \"}\") : new Function(\"r\", \"return {\" + array.map((key) => validName.test(key) ? safeKey(key) + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"}\");\n      if (this.compiledReader)\n        compiledReader.next = this.compiledReader;\n      compiledReader.propertyCount = length;\n      this.compiledReader = compiledReader;\n      return compiledReader(read);\n    }\n    let object = {};\n    if (currentDecoder.keyMap)\n      for (let i = 0;i < length; i++)\n        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();\n    else\n      for (let i = 0;i < length; i++) {\n        object[safeKey(this[i])] = read();\n      }\n    return object;\n  }\n  structure.slowReads = 0;\n  return readObject;\n}\nfunction safeKey(key) {\n  if (typeof key === \"string\")\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  if (typeof key === \"number\" || typeof key === \"boolean\" || typeof key === \"bigint\")\n    return key.toString();\n  if (key == null)\n    return key + \"\";\n  throw new Error(\"Invalid property name type \" + typeof key);\n}\nvar readFixedString = readStringJS;\nfunction readStringJS(length) {\n  let result;\n  if (length < 16) {\n    if (result = shortStringInJS(length))\n      return result;\n  }\n  if (length > 64 && decoder)\n    return decoder.decode(src.subarray(position, position += length));\n  const end = position + length;\n  const units = [];\n  result = \"\";\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 128) === 0) {\n      units.push(byte1);\n    } else if ((byte1 & 224) === 192) {\n      const byte2 = src[position++] & 63;\n      units.push((byte1 & 31) << 6 | byte2);\n    } else if ((byte1 & 240) === 224) {\n      const byte2 = src[position++] & 63;\n      const byte3 = src[position++] & 63;\n      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 248) === 240) {\n      const byte2 = src[position++] & 63;\n      const byte3 = src[position++] & 63;\n      const byte4 = src[position++] & 63;\n      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n      if (unit > 65535) {\n        unit -= 65536;\n        units.push(unit >>> 10 & 1023 | 55296);\n        unit = 56320 | unit & 1023;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= 4096) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n  return result;\n}\nvar fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  let start = position;\n  let bytes = new Array(length);\n  for (let i = 0;i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 128) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0)\n        return \"\";\n      else {\n        let a = src[position++];\n        if ((a & 128) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n      }\n    } else {\n      let a = src[position++];\n      let b = src[position++];\n      if ((a & 128) > 0 || (b & 128) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3)\n        return fromCharCode(a, b);\n      let c = src[position++];\n      if ((c & 128) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n    }\n  } else {\n    let a = src[position++];\n    let b = src[position++];\n    let c = src[position++];\n    let d = src[position++];\n    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4)\n        return fromCharCode(a, b, c, d);\n      else {\n        let e = src[position++];\n        if ((e & 128) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n      }\n    } else if (length < 8) {\n      let e = src[position++];\n      let f = src[position++];\n      if ((e & 128) > 0 || (f & 128) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7)\n        return fromCharCode(a, b, c, d, e, f);\n      let g = src[position++];\n      if ((g & 128) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    } else {\n      let e = src[position++];\n      let f = src[position++];\n      let g = src[position++];\n      let h = src[position++];\n      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8)\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        else {\n          let i = src[position++];\n          if ((i & 128) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n        }\n      } else if (length < 12) {\n        let i = src[position++];\n        let j = src[position++];\n        if ((i & 128) > 0 || (j & 128) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11)\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        let k = src[position++];\n        if ((k & 128) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      } else {\n        let i = src[position++];\n        let j = src[position++];\n        let k = src[position++];\n        let l = src[position++];\n        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12)\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          else {\n            let m = src[position++];\n            if ((m & 128) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n          }\n        } else {\n          let m = src[position++];\n          let n = src[position++];\n          if ((m & 128) > 0 || (n & 128) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15)\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          let o = src[position++];\n          if ((o & 128) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n        }\n      }\n    }\n  }\n}\nfunction readBin(length) {\n  return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nvar f32Array = new Float32Array(1);\nvar u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction getFloat16() {\n  let byte0 = src[position++];\n  let byte1 = src[position++];\n  let exponent = (byte0 & 127) >> 2;\n  if (exponent === 31) {\n    if (byte1 || byte0 & 3)\n      return NaN;\n    return byte0 & 128 ? -Infinity : Infinity;\n  }\n  if (exponent === 0) {\n    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);\n    return byte0 & 128 ? -abs : abs;\n  }\n  u8Array[3] = byte0 & 128 | (exponent >> 1) + 56;\n  u8Array[2] = (byte0 & 7) << 5 | byte1 >> 3;\n  u8Array[1] = byte1 << 5;\n  u8Array[0] = 0;\n  return f32Array[0];\n}\nvar keyCache = new Array(4096);\nclass Tag {\n  constructor(value, tag) {\n    this.value = value;\n    this.tag = tag;\n  }\n}\ncurrentExtensions[0] = (dateString) => {\n  return new Date(dateString);\n};\ncurrentExtensions[1] = (epochSec) => {\n  return new Date(Math.round(epochSec * 1000));\n};\ncurrentExtensions[2] = (buffer) => {\n  let value = BigInt(0);\n  for (let i = 0, l = buffer.byteLength;i < l; i++) {\n    value = BigInt(buffer[i]) + (value << BigInt(8));\n  }\n  return value;\n};\ncurrentExtensions[3] = (buffer) => {\n  return BigInt(-1) - currentExtensions[2](buffer);\n};\ncurrentExtensions[4] = (fraction) => {\n  return +(fraction[1] + \"e\" + fraction[0]);\n};\ncurrentExtensions[5] = (fraction) => {\n  return fraction[1] * Math.exp(fraction[0] * Math.log(2));\n};\nvar recordDefinition = (id, structure) => {\n  id = id - 57344;\n  let existingStructure = currentStructures[id];\n  if (existingStructure && existingStructure.isShared) {\n    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n  }\n  currentStructures[id] = structure;\n  structure.read = createStructureReader(structure);\n};\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n  let length = data.length;\n  let structure = data[1];\n  recordDefinition(data[0], structure);\n  let object = {};\n  for (let i = 2;i < length; i++) {\n    let key = structure[i - 2];\n    object[safeKey(key)] = data[i];\n  }\n  return object;\n};\ncurrentExtensions[14] = (value) => {\n  if (bundledStrings)\n    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);\n  return new Tag(value, 14);\n};\ncurrentExtensions[15] = (value) => {\n  if (bundledStrings)\n    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);\n  return new Tag(value, 15);\n};\nvar glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nvar packedTable = (read2) => {\n  if (src[position++] != 132) {\n    let error = new Error(\"Packed values structure must be followed by a 4 element array\");\n    if (src.length < position)\n      error.incomplete = true;\n    throw error;\n  }\n  let newPackedValues = read2();\n  if (!newPackedValues || !newPackedValues.length) {\n    let error = new Error(\"Packed values structure must be followed by a 4 element array\");\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;\n  packedValues.prefixes = read2();\n  packedValues.suffixes = read2();\n  return read2();\n};\npackedTable.handlesRead = true;\ncurrentExtensions[51] = packedTable;\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {\n  if (!packedValues) {\n    if (currentDecoder.getShared)\n      loadShared();\n    else\n      return new Tag(data, PACKED_REFERENCE_TAG_ID);\n  }\n  if (typeof data == \"number\")\n    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];\n  let error = new Error(\"No support for non-integer packed references yet\");\n  if (data === undefined)\n    error.incomplete = true;\n  throw error;\n};\ncurrentExtensions[28] = (read2) => {\n  if (!referenceMap) {\n    referenceMap = new Map;\n    referenceMap.id = 0;\n  }\n  let id = referenceMap.id++;\n  let startingPosition = position;\n  let token = src[position];\n  let target;\n  if (token >> 5 == 4)\n    target = [];\n  else\n    target = {};\n  let refEntry = { target };\n  referenceMap.set(id, refEntry);\n  let targetProperties = read2();\n  if (refEntry.used) {\n    if (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n      position = startingPosition;\n      target = targetProperties;\n      referenceMap.set(id, { target });\n      targetProperties = read2();\n    }\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties;\n  return targetProperties;\n};\ncurrentExtensions[28].handlesRead = true;\ncurrentExtensions[29] = (id) => {\n  let refEntry = referenceMap.get(id);\n  refEntry.used = true;\n  return refEntry.target;\n};\ncurrentExtensions[258] = (array) => new Set(array);\n(currentExtensions[259] = (read2) => {\n  if (currentDecoder.mapsAsObjects) {\n    currentDecoder.mapsAsObjects = false;\n    restoreMapsAsObject = true;\n  }\n  return read2();\n}).handlesRead = true;\nfunction combine(a, b) {\n  if (typeof a === \"string\")\n    return a + b;\n  if (a instanceof Array)\n    return a.concat(b);\n  return Object.assign({}, a, b);\n}\nfunction getPackedValues() {\n  if (!packedValues) {\n    if (currentDecoder.getShared)\n      loadShared();\n    else\n      throw new Error(\"No packed values available\");\n  }\n  return packedValues;\n}\nvar SHARED_DATA_TAG_ID = 1399353956;\ncurrentExtensionRanges.push((tag, input) => {\n  if (tag >= 225 && tag <= 255)\n    return combine(getPackedValues().prefixes[tag - 224], input);\n  if (tag >= 28704 && tag <= 32767)\n    return combine(getPackedValues().prefixes[tag - 28672], input);\n  if (tag >= 1879052288 && tag <= 2147483647)\n    return combine(getPackedValues().prefixes[tag - 1879048192], input);\n  if (tag >= 216 && tag <= 223)\n    return combine(input, getPackedValues().suffixes[tag - 216]);\n  if (tag >= 27647 && tag <= 28671)\n    return combine(input, getPackedValues().suffixes[tag - 27639]);\n  if (tag >= 1811940352 && tag <= 1879048191)\n    return combine(input, getPackedValues().suffixes[tag - 1811939328]);\n  if (tag == SHARED_DATA_TAG_ID) {\n    return {\n      packedValues,\n      structures: currentStructures.slice(0),\n      version: input\n    };\n  }\n  if (tag == 55799)\n    return input;\n});\nvar isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;\nvar typedArrays = [\n  Uint8Array,\n  Uint8ClampedArray,\n  Uint16Array,\n  Uint32Array,\n  typeof BigUint64Array == \"undefined\" ? { name: \"BigUint64Array\" } : BigUint64Array,\n  Int8Array,\n  Int16Array,\n  Int32Array,\n  typeof BigInt64Array == \"undefined\" ? { name: \"BigInt64Array\" } : BigInt64Array,\n  Float32Array,\n  Float64Array\n];\nvar typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];\nfor (let i = 0;i < typedArrays.length; i++) {\n  registerTypedArray(typedArrays[i], typedArrayTags[i]);\n}\nfunction registerTypedArray(TypedArray, tag) {\n  let dvMethod = \"get\" + TypedArray.name.slice(0, -5);\n  let bytesPerElement;\n  if (typeof TypedArray === \"function\")\n    bytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n  else\n    TypedArray = null;\n  for (let littleEndian = 0;littleEndian < 2; littleEndian++) {\n    if (!littleEndian && bytesPerElement == 1)\n      continue;\n    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0;\n    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer) => {\n      if (!TypedArray)\n        throw new Error(\"Could not find typed array for code \" + tag);\n      if (!currentDecoder.copyBuffers) {\n        if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer.byteOffset & 1) || bytesPerElement === 4 && !(buffer.byteOffset & 3) || bytesPerElement === 8 && !(buffer.byteOffset & 7))\n          return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);\n      }\n      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);\n    } : (buffer) => {\n      if (!TypedArray)\n        throw new Error(\"Could not find typed array for code \" + tag);\n      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      let elements = buffer.length >> sizeShift;\n      let ta = new TypedArray(elements);\n      let method = dv[dvMethod];\n      for (let i = 0;i < elements; i++) {\n        ta[i] = method.call(dv, i << sizeShift, littleEndian);\n      }\n      return ta;\n    };\n  }\n}\nfunction readBundleExt() {\n  let length = readJustLength();\n  let bundlePosition = position + read();\n  for (let i = 2;i < length; i++) {\n    let bundleLength = readJustLength();\n    position += bundleLength;\n  }\n  let dataPosition = position;\n  position = bundlePosition;\n  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];\n  bundledStrings.position0 = 0;\n  bundledStrings.position1 = 0;\n  bundledStrings.postBundlePosition = position;\n  position = dataPosition;\n  return read();\n}\nfunction readJustLength() {\n  let token = src[position++] & 31;\n  if (token > 23) {\n    switch (token) {\n      case 24:\n        token = src[position++];\n        break;\n      case 25:\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 26:\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n    }\n  }\n  return token;\n}\nfunction loadShared() {\n  if (currentDecoder.getShared) {\n    let sharedData = saveState(() => {\n      src = null;\n      return currentDecoder.getShared();\n    }) || {};\n    let updatedStructures = sharedData.structures || [];\n    currentDecoder.sharedVersion = sharedData.version;\n    packedValues = currentDecoder.sharedValues = sharedData.packedValues;\n    if (currentStructures === true)\n      currentDecoder.structures = currentStructures = updatedStructures;\n    else\n      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));\n  }\n}\nfunction saveState(callback) {\n  let savedSrcEnd = srcEnd;\n  let savedPosition = position;\n  let savedStringPosition = stringPosition;\n  let savedSrcStringStart = srcStringStart;\n  let savedSrcStringEnd = srcStringEnd;\n  let savedSrcString = srcString;\n  let savedStrings = strings;\n  let savedReferenceMap = referenceMap;\n  let savedBundledStrings = bundledStrings;\n  let savedSrc = new Uint8Array(src.slice(0, srcEnd));\n  let savedStructures = currentStructures;\n  let savedDecoder = currentDecoder;\n  let savedSequentialMode = sequentialMode;\n  let value = callback();\n  srcEnd = savedSrcEnd;\n  position = savedPosition;\n  stringPosition = savedStringPosition;\n  srcStringStart = savedSrcStringStart;\n  srcStringEnd = savedSrcStringEnd;\n  srcString = savedSrcString;\n  strings = savedStrings;\n  referenceMap = savedReferenceMap;\n  bundledStrings = savedBundledStrings;\n  src = savedSrc;\n  sequentialMode = savedSequentialMode;\n  currentStructures = savedStructures;\n  currentDecoder = savedDecoder;\n  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n  return value;\n}\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\nvar mult10 = new Array(147);\nfor (let i = 0;i < 256; i++) {\n  mult10[i] = +(\"1e\" + Math.floor(45.15 - i * 0.30103));\n}\nvar defaultDecoder = new Decoder({ useRecords: false });\nvar decode = defaultDecoder.decode;\nvar decodeMultiple = defaultDecoder.decodeMultiple;\n// node_modules/cbor-x/encode.js\nvar textEncoder;\ntry {\n  textEncoder = new TextEncoder;\n} catch (error) {}\nvar extensions;\nvar extensionClasses;\nvar Buffer2 = typeof globalThis === \"object\" && globalThis.Buffer;\nvar hasNodeBuffer = typeof Buffer2 !== \"undefined\";\nvar ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;\nvar ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;\nvar MAX_STRUCTURES = 256;\nvar MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;\nvar throwOnIterable;\nvar target;\nvar targetView;\nvar position2 = 0;\nvar safeEnd;\nvar bundledStrings2 = null;\nvar MAX_BUNDLE_SIZE = 61440;\nvar hasNonLatin = /[\\u0080-\\uFFFF]/;\nvar RECORD_SYMBOL = Symbol(\"record-id\");\n\nclass Encoder extends Decoder {\n  constructor(options) {\n    super(options);\n    this.offset = 0;\n    let typeBuffer;\n    let start;\n    let sharedStructures;\n    let hasSharedUpdate;\n    let structures;\n    let referenceMap2;\n    options = options || {};\n    let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position3, maxBytes) {\n      return target.utf8Write(string, position3, maxBytes);\n    } : textEncoder && textEncoder.encodeInto ? function(string, position3) {\n      return textEncoder.encodeInto(string, target.subarray(position3)).written;\n    } : false;\n    let encoder = this;\n    let hasSharedStructures = options.structures || options.saveStructures;\n    let maxSharedStructures = options.maxSharedStructures;\n    if (maxSharedStructures == null)\n      maxSharedStructures = hasSharedStructures ? 128 : 0;\n    if (maxSharedStructures > 8190)\n      throw new Error(\"Maximum maxSharedStructure is 8190\");\n    let isSequential = options.sequential;\n    if (isSequential) {\n      maxSharedStructures = 0;\n    }\n    if (!this.structures)\n      this.structures = [];\n    if (this.saveStructures)\n      this.saveShared = this.saveStructures;\n    let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;\n    let sharedPackedObjectMap2;\n    if (sharedValues) {\n      sharedPackedObjectMap2 = Object.create(null);\n      for (let i = 0, l = sharedValues.length;i < l; i++) {\n        sharedPackedObjectMap2[sharedValues[i]] = i;\n      }\n    }\n    let recordIdsToRemove = [];\n    let transitionsCount = 0;\n    let serializationsSinceTransitionRebuild = 0;\n    this.mapEncode = function(value, encodeOptions) {\n      if (this._keyMap && !this._mapped) {\n        switch (value.constructor.name) {\n          case \"Array\":\n            value = value.map((r) => this.encodeKeys(r));\n            break;\n        }\n      }\n      return this.encode(value, encodeOptions);\n    };\n    this.encode = function(value, encodeOptions) {\n      if (!target) {\n        target = new ByteArrayAllocate(8192);\n        targetView = new DataView(target.buffer, 0, 8192);\n        position2 = 0;\n      }\n      safeEnd = target.length - 10;\n      if (safeEnd - position2 < 2048) {\n        target = new ByteArrayAllocate(target.length);\n        targetView = new DataView(target.buffer, 0, target.length);\n        safeEnd = target.length - 10;\n        position2 = 0;\n      } else if (encodeOptions === REUSE_BUFFER_MODE)\n        position2 = position2 + 7 & 2147483640;\n      start = position2;\n      if (encoder.useSelfDescribedHeader) {\n        targetView.setUint32(position2, 3654940416);\n        position2 += 3;\n      }\n      referenceMap2 = encoder.structuredClone ? new Map : null;\n      if (encoder.bundleStrings && typeof value !== \"string\") {\n        bundledStrings2 = [];\n        bundledStrings2.size = Infinity;\n      } else\n        bundledStrings2 = null;\n      sharedStructures = encoder.structures;\n      if (sharedStructures) {\n        if (sharedStructures.uninitialized) {\n          let sharedData = encoder.getShared() || {};\n          encoder.structures = sharedStructures = sharedData.structures || [];\n          encoder.sharedVersion = sharedData.version;\n          let sharedValues2 = encoder.sharedValues = sharedData.packedValues;\n          if (sharedValues2) {\n            sharedPackedObjectMap2 = {};\n            for (let i = 0, l = sharedValues2.length;i < l; i++)\n              sharedPackedObjectMap2[sharedValues2[i]] = i;\n          }\n        }\n        let sharedStructuresLength = sharedStructures.length;\n        if (sharedStructuresLength > maxSharedStructures && !isSequential)\n          sharedStructuresLength = maxSharedStructures;\n        if (!sharedStructures.transitions) {\n          sharedStructures.transitions = Object.create(null);\n          for (let i = 0;i < sharedStructuresLength; i++) {\n            let keys = sharedStructures[i];\n            if (!keys)\n              continue;\n            let nextTransition, transition = sharedStructures.transitions;\n            for (let j = 0, l = keys.length;j < l; j++) {\n              if (transition[RECORD_SYMBOL] === undefined)\n                transition[RECORD_SYMBOL] = i;\n              let key = keys[j];\n              nextTransition = transition[key];\n              if (!nextTransition) {\n                nextTransition = transition[key] = Object.create(null);\n              }\n              transition = nextTransition;\n            }\n            transition[RECORD_SYMBOL] = i | 1048576;\n          }\n        }\n        if (!isSequential)\n          sharedStructures.nextId = sharedStructuresLength;\n      }\n      if (hasSharedUpdate)\n        hasSharedUpdate = false;\n      structures = sharedStructures || [];\n      packedObjectMap2 = sharedPackedObjectMap2;\n      if (options.pack) {\n        let packedValues2 = new Map;\n        packedValues2.values = [];\n        packedValues2.encoder = encoder;\n        packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);\n        packedValues2.objectMap = sharedPackedObjectMap2 || false;\n        packedValues2.samplingPackedValues = samplingPackedValues;\n        findRepetitiveStrings(value, packedValues2);\n        if (packedValues2.values.length > 0) {\n          target[position2++] = 216;\n          target[position2++] = 51;\n          writeArrayHeader(4);\n          let valuesArray = packedValues2.values;\n          encode(valuesArray);\n          writeArrayHeader(0);\n          writeArrayHeader(0);\n          packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);\n          for (let i = 0, l = valuesArray.length;i < l; i++) {\n            packedObjectMap2[valuesArray[i]] = i;\n          }\n        }\n      }\n      throwOnIterable = encodeOptions & THROW_ON_ITERABLE;\n      try {\n        if (throwOnIterable)\n          return;\n        encode(value);\n        if (bundledStrings2) {\n          writeBundles(start, encode);\n        }\n        encoder.offset = position2;\n        if (referenceMap2 && referenceMap2.idsToInsert) {\n          position2 += referenceMap2.idsToInsert.length * 2;\n          if (position2 > safeEnd)\n            makeRoom(position2);\n          encoder.offset = position2;\n          let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);\n          referenceMap2 = null;\n          return serialized;\n        }\n        if (encodeOptions & REUSE_BUFFER_MODE) {\n          target.start = start;\n          target.end = position2;\n          return target;\n        }\n        return target.subarray(start, position2);\n      } finally {\n        if (sharedStructures) {\n          if (serializationsSinceTransitionRebuild < 10)\n            serializationsSinceTransitionRebuild++;\n          if (sharedStructures.length > maxSharedStructures)\n            sharedStructures.length = maxSharedStructures;\n          if (transitionsCount > 1e4) {\n            sharedStructures.transitions = null;\n            serializationsSinceTransitionRebuild = 0;\n            transitionsCount = 0;\n            if (recordIdsToRemove.length > 0)\n              recordIdsToRemove = [];\n          } else if (recordIdsToRemove.length > 0 && !isSequential) {\n            for (let i = 0, l = recordIdsToRemove.length;i < l; i++) {\n              recordIdsToRemove[i][RECORD_SYMBOL] = undefined;\n            }\n            recordIdsToRemove = [];\n          }\n        }\n        if (hasSharedUpdate && encoder.saveShared) {\n          if (encoder.structures.length > maxSharedStructures) {\n            encoder.structures = encoder.structures.slice(0, maxSharedStructures);\n          }\n          let returnBuffer = target.subarray(start, position2);\n          if (encoder.updateSharedData() === false)\n            return encoder.encode(value);\n          return returnBuffer;\n        }\n        if (encodeOptions & RESET_BUFFER_MODE)\n          position2 = start;\n      }\n    };\n    this.findCommonStringsToPack = () => {\n      samplingPackedValues = new Map;\n      if (!sharedPackedObjectMap2)\n        sharedPackedObjectMap2 = Object.create(null);\n      return (options2) => {\n        let threshold = options2 && options2.threshold || 4;\n        let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;\n        if (!sharedValues)\n          sharedValues = this.sharedValues = [];\n        for (let [key, status] of samplingPackedValues) {\n          if (status.count > threshold) {\n            sharedPackedObjectMap2[key] = position3++;\n            sharedValues.push(key);\n            hasSharedUpdate = true;\n          }\n        }\n        while (this.saveShared && this.updateSharedData() === false) {}\n        samplingPackedValues = null;\n      };\n    };\n    const encode = (value) => {\n      if (position2 > safeEnd)\n        target = makeRoom(position2);\n      var type = typeof value;\n      var length;\n      if (type === \"string\") {\n        if (packedObjectMap2) {\n          let packedPosition = packedObjectMap2[value];\n          if (packedPosition >= 0) {\n            if (packedPosition < 16)\n              target[position2++] = packedPosition + 224;\n            else {\n              target[position2++] = 198;\n              if (packedPosition & 1)\n                encode(15 - packedPosition >> 1);\n              else\n                encode(packedPosition - 16 >> 1);\n            }\n            return;\n          } else if (samplingPackedValues && !options.pack) {\n            let status = samplingPackedValues.get(value);\n            if (status)\n              status.count++;\n            else\n              samplingPackedValues.set(value, {\n                count: 1\n              });\n          }\n        }\n        let strLength = value.length;\n        if (bundledStrings2 && strLength >= 4 && strLength < 1024) {\n          if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {\n            let extStart;\n            let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;\n            if (position2 + maxBytes2 > safeEnd)\n              target = makeRoom(position2 + maxBytes2);\n            target[position2++] = 217;\n            target[position2++] = 223;\n            target[position2++] = 249;\n            target[position2++] = bundledStrings2.position ? 132 : 130;\n            target[position2++] = 26;\n            extStart = position2 - start;\n            position2 += 4;\n            if (bundledStrings2.position) {\n              writeBundles(start, encode);\n            }\n            bundledStrings2 = [\"\", \"\"];\n            bundledStrings2.size = 0;\n            bundledStrings2.position = extStart;\n          }\n          let twoByte = hasNonLatin.test(value);\n          bundledStrings2[twoByte ? 0 : 1] += value;\n          target[position2++] = twoByte ? 206 : 207;\n          encode(strLength);\n          return;\n        }\n        let headerSize;\n        if (strLength < 32) {\n          headerSize = 1;\n        } else if (strLength < 256) {\n          headerSize = 2;\n        } else if (strLength < 65536) {\n          headerSize = 3;\n        } else {\n          headerSize = 5;\n        }\n        let maxBytes = strLength * 3;\n        if (position2 + maxBytes > safeEnd)\n          target = makeRoom(position2 + maxBytes);\n        if (strLength < 64 || !encodeUtf8) {\n          let i, c1, c2, strPosition = position2 + headerSize;\n          for (i = 0;i < strLength; i++) {\n            c1 = value.charCodeAt(i);\n            if (c1 < 128) {\n              target[strPosition++] = c1;\n            } else if (c1 < 2048) {\n              target[strPosition++] = c1 >> 6 | 192;\n              target[strPosition++] = c1 & 63 | 128;\n            } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {\n              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n              i++;\n              target[strPosition++] = c1 >> 18 | 240;\n              target[strPosition++] = c1 >> 12 & 63 | 128;\n              target[strPosition++] = c1 >> 6 & 63 | 128;\n              target[strPosition++] = c1 & 63 | 128;\n            } else {\n              target[strPosition++] = c1 >> 12 | 224;\n              target[strPosition++] = c1 >> 6 & 63 | 128;\n              target[strPosition++] = c1 & 63 | 128;\n            }\n          }\n          length = strPosition - position2 - headerSize;\n        } else {\n          length = encodeUtf8(value, position2 + headerSize, maxBytes);\n        }\n        if (length < 24) {\n          target[position2++] = 96 | length;\n        } else if (length < 256) {\n          if (headerSize < 2) {\n            target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length);\n          }\n          target[position2++] = 120;\n          target[position2++] = length;\n        } else if (length < 65536) {\n          if (headerSize < 3) {\n            target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length);\n          }\n          target[position2++] = 121;\n          target[position2++] = length >> 8;\n          target[position2++] = length & 255;\n        } else {\n          if (headerSize < 5) {\n            target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length);\n          }\n          target[position2++] = 122;\n          targetView.setUint32(position2, length);\n          position2 += 4;\n        }\n        position2 += length;\n      } else if (type === \"number\") {\n        if (!this.alwaysUseFloat && value >>> 0 === value) {\n          if (value < 24) {\n            target[position2++] = value;\n          } else if (value < 256) {\n            target[position2++] = 24;\n            target[position2++] = value;\n          } else if (value < 65536) {\n            target[position2++] = 25;\n            target[position2++] = value >> 8;\n            target[position2++] = value & 255;\n          } else {\n            target[position2++] = 26;\n            targetView.setUint32(position2, value);\n            position2 += 4;\n          }\n        } else if (!this.alwaysUseFloat && value >> 0 === value) {\n          if (value >= -24) {\n            target[position2++] = 31 - value;\n          } else if (value >= -256) {\n            target[position2++] = 56;\n            target[position2++] = ~value;\n          } else if (value >= -65536) {\n            target[position2++] = 57;\n            targetView.setUint16(position2, ~value);\n            position2 += 2;\n          } else {\n            target[position2++] = 58;\n            targetView.setUint32(position2, ~value);\n            position2 += 4;\n          }\n        } else {\n          let useFloat32;\n          if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {\n            target[position2++] = 250;\n            targetView.setFloat32(position2, value);\n            let xShifted;\n            if (useFloat32 < 4 || (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {\n              position2 += 4;\n              return;\n            } else\n              position2--;\n          }\n          target[position2++] = 251;\n          targetView.setFloat64(position2, value);\n          position2 += 8;\n        }\n      } else if (type === \"object\") {\n        if (!value)\n          target[position2++] = 246;\n        else {\n          if (referenceMap2) {\n            let referee = referenceMap2.get(value);\n            if (referee) {\n              target[position2++] = 216;\n              target[position2++] = 29;\n              target[position2++] = 25;\n              if (!referee.references) {\n                let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);\n                referee.references = [];\n                idsToInsert.push(referee);\n              }\n              referee.references.push(position2 - start);\n              position2 += 2;\n              return;\n            } else\n              referenceMap2.set(value, { offset: position2 - start });\n          }\n          let constructor = value.constructor;\n          if (constructor === Object) {\n            writeObject(value);\n          } else if (constructor === Array) {\n            length = value.length;\n            if (length < 24) {\n              target[position2++] = 128 | length;\n            } else {\n              writeArrayHeader(length);\n            }\n            for (let i = 0;i < length; i++) {\n              encode(value[i]);\n            }\n          } else if (constructor === Map) {\n            if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n              target[position2++] = 217;\n              target[position2++] = 1;\n              target[position2++] = 3;\n            }\n            length = value.size;\n            if (length < 24) {\n              target[position2++] = 160 | length;\n            } else if (length < 256) {\n              target[position2++] = 184;\n              target[position2++] = length;\n            } else if (length < 65536) {\n              target[position2++] = 185;\n              target[position2++] = length >> 8;\n              target[position2++] = length & 255;\n            } else {\n              target[position2++] = 186;\n              targetView.setUint32(position2, length);\n              position2 += 4;\n            }\n            if (encoder.keyMap) {\n              for (let [key, entryValue] of value) {\n                encode(encoder.encodeKey(key));\n                encode(entryValue);\n              }\n            } else {\n              for (let [key, entryValue] of value) {\n                encode(key);\n                encode(entryValue);\n              }\n            }\n          } else {\n            for (let i = 0, l = extensions.length;i < l; i++) {\n              let extensionClass = extensionClasses[i];\n              if (value instanceof extensionClass) {\n                let extension = extensions[i];\n                let tag = extension.tag;\n                if (tag == undefined)\n                  tag = extension.getTag && extension.getTag.call(this, value);\n                if (tag < 24) {\n                  target[position2++] = 192 | tag;\n                } else if (tag < 256) {\n                  target[position2++] = 216;\n                  target[position2++] = tag;\n                } else if (tag < 65536) {\n                  target[position2++] = 217;\n                  target[position2++] = tag >> 8;\n                  target[position2++] = tag & 255;\n                } else if (tag > -1) {\n                  target[position2++] = 218;\n                  targetView.setUint32(position2, tag);\n                  position2 += 4;\n                }\n                extension.encode.call(this, value, encode, makeRoom);\n                return;\n              }\n            }\n            if (value[Symbol.iterator]) {\n              if (throwOnIterable) {\n                let error = new Error(\"Iterable should be serialized as iterator\");\n                error.iteratorNotHandled = true;\n                throw error;\n              }\n              target[position2++] = 159;\n              for (let entry of value) {\n                encode(entry);\n              }\n              target[position2++] = 255;\n              return;\n            }\n            if (value[Symbol.asyncIterator] || isBlob(value)) {\n              let error = new Error(\"Iterable/blob should be serialized as iterator\");\n              error.iteratorNotHandled = true;\n              throw error;\n            }\n            if (this.useToJSON && value.toJSON) {\n              const json = value.toJSON();\n              if (json !== value)\n                return encode(json);\n            }\n            writeObject(value);\n          }\n        }\n      } else if (type === \"boolean\") {\n        target[position2++] = value ? 245 : 244;\n      } else if (type === \"bigint\") {\n        if (value < BigInt(1) << BigInt(64) && value >= 0) {\n          target[position2++] = 27;\n          targetView.setBigUint64(position2, value);\n        } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {\n          target[position2++] = 59;\n          targetView.setBigUint64(position2, -value - BigInt(1));\n        } else {\n          if (this.largeBigIntToFloat) {\n            target[position2++] = 251;\n            targetView.setFloat64(position2, Number(value));\n          } else {\n            if (value >= BigInt(0))\n              target[position2++] = 194;\n            else {\n              target[position2++] = 195;\n              value = BigInt(-1) - value;\n            }\n            let bytes = [];\n            while (value) {\n              bytes.push(Number(value & BigInt(255)));\n              value >>= BigInt(8);\n            }\n            writeBuffer(new Uint8Array(bytes.reverse()), makeRoom);\n            return;\n          }\n        }\n        position2 += 8;\n      } else if (type === \"undefined\") {\n        target[position2++] = 247;\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n    };\n    const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n      let keys = Object.keys(object);\n      let vals = Object.values(object);\n      let length = keys.length;\n      if (length < 24) {\n        target[position2++] = 160 | length;\n      } else if (length < 256) {\n        target[position2++] = 184;\n        target[position2++] = length;\n      } else if (length < 65536) {\n        target[position2++] = 185;\n        target[position2++] = length >> 8;\n        target[position2++] = length & 255;\n      } else {\n        target[position2++] = 186;\n        targetView.setUint32(position2, length);\n        position2 += 4;\n      }\n      let key;\n      if (encoder.keyMap) {\n        for (let i = 0;i < length; i++) {\n          encode(encoder.encodeKey(keys[i]));\n          encode(vals[i]);\n        }\n      } else {\n        for (let i = 0;i < length; i++) {\n          encode(keys[i]);\n          encode(vals[i]);\n        }\n      }\n    } : (object) => {\n      target[position2++] = 185;\n      let objectOffset = position2 - start;\n      position2 += 2;\n      let size = 0;\n      if (encoder.keyMap) {\n        for (let key in object)\n          if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n            encode(encoder.encodeKey(key));\n            encode(object[key]);\n            size++;\n          }\n      } else {\n        for (let key in object)\n          if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n            encode(key);\n            encode(object[key]);\n            size++;\n          }\n      }\n      target[objectOffset++ + start] = size >> 8;\n      target[objectOffset + start] = size & 255;\n    } : (object, skipValues) => {\n      let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n      let newTransitions = 0;\n      let length = 0;\n      let parentRecordId;\n      let keys;\n      if (this.keyMap) {\n        keys = Object.keys(object).map((k) => this.encodeKey(k));\n        length = keys.length;\n        for (let i = 0;i < length; i++) {\n          let key = keys[i];\n          nextTransition = transition[key];\n          if (!nextTransition) {\n            nextTransition = transition[key] = Object.create(null);\n            newTransitions++;\n          }\n          transition = nextTransition;\n        }\n      } else {\n        for (let key in object)\n          if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n            nextTransition = transition[key];\n            if (!nextTransition) {\n              if (transition[RECORD_SYMBOL] & 1048576) {\n                parentRecordId = transition[RECORD_SYMBOL] & 65535;\n              }\n              nextTransition = transition[key] = Object.create(null);\n              newTransitions++;\n            }\n            transition = nextTransition;\n            length++;\n          }\n      }\n      let recordId = transition[RECORD_SYMBOL];\n      if (recordId !== undefined) {\n        recordId &= 65535;\n        target[position2++] = 217;\n        target[position2++] = recordId >> 8 | 224;\n        target[position2++] = recordId & 255;\n      } else {\n        if (!keys)\n          keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));\n        if (parentRecordId === undefined) {\n          recordId = structures.nextId++;\n          if (!recordId) {\n            recordId = 0;\n            structures.nextId = 1;\n          }\n          if (recordId >= MAX_STRUCTURES) {\n            structures.nextId = (recordId = maxSharedStructures) + 1;\n          }\n        } else {\n          recordId = parentRecordId;\n        }\n        structures[recordId] = keys;\n        if (recordId < maxSharedStructures) {\n          target[position2++] = 217;\n          target[position2++] = recordId >> 8 | 224;\n          target[position2++] = recordId & 255;\n          transition = structures.transitions;\n          for (let i = 0;i < length; i++) {\n            if (transition[RECORD_SYMBOL] === undefined || transition[RECORD_SYMBOL] & 1048576)\n              transition[RECORD_SYMBOL] = recordId;\n            transition = transition[keys[i]];\n          }\n          transition[RECORD_SYMBOL] = recordId | 1048576;\n          hasSharedUpdate = true;\n        } else {\n          transition[RECORD_SYMBOL] = recordId;\n          targetView.setUint32(position2, 3655335680);\n          position2 += 3;\n          if (newTransitions)\n            transitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n          if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n            recordIdsToRemove.shift()[RECORD_SYMBOL] = undefined;\n          recordIdsToRemove.push(transition);\n          writeArrayHeader(length + 2);\n          encode(57344 + recordId);\n          encode(keys);\n          if (skipValues)\n            return;\n          for (let key in object)\n            if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key))\n              encode(object[key]);\n          return;\n        }\n      }\n      if (length < 24) {\n        target[position2++] = 128 | length;\n      } else {\n        writeArrayHeader(length);\n      }\n      if (skipValues)\n        return;\n      for (let key in object)\n        if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key))\n          encode(object[key]);\n    };\n    const makeRoom = (end) => {\n      let newSize;\n      if (end > 16777216) {\n        if (end - start > MAX_BUFFER_SIZE)\n          throw new Error(\"Encoded buffer would be larger than maximum buffer size\");\n        newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);\n      } else\n        newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;\n      let newBuffer = new ByteArrayAllocate(newSize);\n      targetView = new DataView(newBuffer.buffer, 0, newSize);\n      if (target.copy)\n        target.copy(newBuffer, 0, start, end);\n      else\n        newBuffer.set(target.slice(start, end));\n      position2 -= start;\n      start = 0;\n      safeEnd = newBuffer.length - 10;\n      return target = newBuffer;\n    };\n    let chunkThreshold = 100;\n    let continuedChunkThreshold = 1000;\n    this.encodeAsIterable = function(value, options2) {\n      return startEncoding(value, options2, encodeObjectAsIterable);\n    };\n    this.encodeAsAsyncIterable = function(value, options2) {\n      return startEncoding(value, options2, encodeObjectAsAsyncIterable);\n    };\n    function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n      let constructor = object.constructor;\n      if (constructor === Object) {\n        let useRecords = encoder.useRecords !== false;\n        if (useRecords)\n          writeObject(object, true);\n        else\n          writeEntityLength(Object.keys(object).length, 160);\n        for (let key in object) {\n          let value = object[key];\n          if (!useRecords)\n            encode(key);\n          if (value && typeof value === \"object\") {\n            if (iterateProperties[key])\n              yield* encodeObjectAsIterable(value, iterateProperties[key]);\n            else\n              yield* tryEncode(value, iterateProperties, key);\n          } else\n            encode(value);\n        }\n      } else if (constructor === Array) {\n        let length = object.length;\n        writeArrayHeader(length);\n        for (let i = 0;i < length; i++) {\n          let value = object[i];\n          if (value && (typeof value === \"object\" || position2 - start > chunkThreshold)) {\n            if (iterateProperties.element)\n              yield* encodeObjectAsIterable(value, iterateProperties.element);\n            else\n              yield* tryEncode(value, iterateProperties, \"element\");\n          } else\n            encode(value);\n        }\n      } else if (object[Symbol.iterator] && !object.buffer) {\n        target[position2++] = 159;\n        for (let value of object) {\n          if (value && (typeof value === \"object\" || position2 - start > chunkThreshold)) {\n            if (iterateProperties.element)\n              yield* encodeObjectAsIterable(value, iterateProperties.element);\n            else\n              yield* tryEncode(value, iterateProperties, \"element\");\n          } else\n            encode(value);\n        }\n        target[position2++] = 255;\n      } else if (isBlob(object)) {\n        writeEntityLength(object.size, 64);\n        yield target.subarray(start, position2);\n        yield object;\n        restartEncoding();\n      } else if (object[Symbol.asyncIterator]) {\n        target[position2++] = 159;\n        yield target.subarray(start, position2);\n        yield object;\n        restartEncoding();\n        target[position2++] = 255;\n      } else {\n        encode(object);\n      }\n      if (finalIterable && position2 > start)\n        yield target.subarray(start, position2);\n      else if (position2 - start > chunkThreshold) {\n        yield target.subarray(start, position2);\n        restartEncoding();\n      }\n    }\n    function* tryEncode(value, iterateProperties, key) {\n      let restart = position2 - start;\n      try {\n        encode(value);\n        if (position2 - start > chunkThreshold) {\n          yield target.subarray(start, position2);\n          restartEncoding();\n        }\n      } catch (error) {\n        if (error.iteratorNotHandled) {\n          iterateProperties[key] = {};\n          position2 = start + restart;\n          yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n        } else\n          throw error;\n      }\n    }\n    function restartEncoding() {\n      chunkThreshold = continuedChunkThreshold;\n      encoder.encode(null, THROW_ON_ITERABLE);\n    }\n    function startEncoding(value, options2, encodeIterable) {\n      if (options2 && options2.chunkThreshold)\n        chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;\n      else\n        chunkThreshold = 100;\n      if (value && typeof value === \"object\") {\n        encoder.encode(null, THROW_ON_ITERABLE);\n        return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n      }\n      return [encoder.encode(value)];\n    }\n    async function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n      for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n        let constructor = encodedValue.constructor;\n        if (constructor === ByteArray || constructor === Uint8Array)\n          yield encodedValue;\n        else if (isBlob(encodedValue)) {\n          let reader = encodedValue.stream().getReader();\n          let next;\n          while (!(next = await reader.read()).done) {\n            yield next.value;\n          }\n        } else if (encodedValue[Symbol.asyncIterator]) {\n          for await (let asyncValue of encodedValue) {\n            restartEncoding();\n            if (asyncValue)\n              yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n            else\n              yield encoder.encode(asyncValue);\n          }\n        } else {\n          yield encodedValue;\n        }\n      }\n    }\n  }\n  useBuffer(buffer) {\n    target = buffer;\n    targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);\n    position2 = 0;\n  }\n  clearSharedData() {\n    if (this.structures)\n      this.structures = [];\n    if (this.sharedValues)\n      this.sharedValues = undefined;\n  }\n  updateSharedData() {\n    let lastVersion = this.sharedVersion || 0;\n    this.sharedVersion = lastVersion + 1;\n    let structuresCopy = this.structures.slice(0);\n    let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);\n    let saveResults = this.saveShared(sharedData, (existingShared) => (existingShared && existingShared.version || 0) == lastVersion);\n    if (saveResults === false) {\n      sharedData = this.getShared() || {};\n      this.structures = sharedData.structures || [];\n      this.sharedValues = sharedData.packedValues;\n      this.sharedVersion = sharedData.version;\n      this.structures.nextId = this.structures.length;\n    } else {\n      structuresCopy.forEach((structure, i) => this.structures[i] = structure);\n    }\n    return saveResults;\n  }\n}\nfunction writeEntityLength(length, majorValue) {\n  if (length < 24)\n    target[position2++] = majorValue | length;\n  else if (length < 256) {\n    target[position2++] = majorValue | 24;\n    target[position2++] = length;\n  } else if (length < 65536) {\n    target[position2++] = majorValue | 25;\n    target[position2++] = length >> 8;\n    target[position2++] = length & 255;\n  } else {\n    target[position2++] = majorValue | 26;\n    targetView.setUint32(position2, length);\n    position2 += 4;\n  }\n}\n\nclass SharedData {\n  constructor(structures, values, version) {\n    this.structures = structures;\n    this.packedValues = values;\n    this.version = version;\n  }\n}\nfunction writeArrayHeader(length) {\n  if (length < 24)\n    target[position2++] = 128 | length;\n  else if (length < 256) {\n    target[position2++] = 152;\n    target[position2++] = length;\n  } else if (length < 65536) {\n    target[position2++] = 153;\n    target[position2++] = length >> 8;\n    target[position2++] = length & 255;\n  } else {\n    target[position2++] = 154;\n    targetView.setUint32(position2, length);\n    position2 += 4;\n  }\n}\nvar BlobConstructor = typeof Blob === \"undefined\" ? function() {} : Blob;\nfunction isBlob(object) {\n  if (object instanceof BlobConstructor)\n    return true;\n  let tag = object[Symbol.toStringTag];\n  return tag === \"Blob\" || tag === \"File\";\n}\nfunction findRepetitiveStrings(value, packedValues2) {\n  switch (typeof value) {\n    case \"string\":\n      if (value.length > 3) {\n        if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)\n          return;\n        let packedStatus = packedValues2.get(value);\n        if (packedStatus) {\n          if (++packedStatus.count == 2) {\n            packedValues2.values.push(value);\n          }\n        } else {\n          packedValues2.set(value, {\n            count: 1\n          });\n          if (packedValues2.samplingPackedValues) {\n            let status = packedValues2.samplingPackedValues.get(value);\n            if (status)\n              status.count++;\n            else\n              packedValues2.samplingPackedValues.set(value, {\n                count: 1\n              });\n          }\n        }\n      }\n      break;\n    case \"object\":\n      if (value) {\n        if (value instanceof Array) {\n          for (let i = 0, l = value.length;i < l; i++) {\n            findRepetitiveStrings(value[i], packedValues2);\n          }\n        } else {\n          let includeKeys = !packedValues2.encoder.useRecords;\n          for (var key in value) {\n            if (value.hasOwnProperty(key)) {\n              if (includeKeys)\n                findRepetitiveStrings(key, packedValues2);\n              findRepetitiveStrings(value[key], packedValues2);\n            }\n          }\n        }\n      }\n      break;\n    case \"function\":\n      console.log(value);\n  }\n}\nvar isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;\nextensionClasses = [\n  Date,\n  Set,\n  Error,\n  RegExp,\n  Tag,\n  ArrayBuffer,\n  Uint8Array,\n  Uint8ClampedArray,\n  Uint16Array,\n  Uint32Array,\n  typeof BigUint64Array == \"undefined\" ? function() {} : BigUint64Array,\n  Int8Array,\n  Int16Array,\n  Int32Array,\n  typeof BigInt64Array == \"undefined\" ? function() {} : BigInt64Array,\n  Float32Array,\n  Float64Array,\n  SharedData\n];\nextensions = [\n  {\n    tag: 1,\n    encode(date, encode) {\n      let seconds = date.getTime() / 1000;\n      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {\n        target[position2++] = 26;\n        targetView.setUint32(position2, seconds);\n        position2 += 4;\n      } else {\n        target[position2++] = 251;\n        targetView.setFloat64(position2, seconds);\n        position2 += 8;\n      }\n    }\n  },\n  {\n    tag: 258,\n    encode(set, encode) {\n      let array = Array.from(set);\n      encode(array);\n    }\n  },\n  {\n    tag: 27,\n    encode(error, encode) {\n      encode([error.name, error.message]);\n    }\n  },\n  {\n    tag: 27,\n    encode(regex, encode) {\n      encode([\"RegExp\", regex.source, regex.flags]);\n    }\n  },\n  {\n    getTag(tag) {\n      return tag.tag;\n    },\n    encode(tag, encode) {\n      encode(tag.value);\n    }\n  },\n  {\n    encode(arrayBuffer, encode, makeRoom) {\n      writeBuffer(arrayBuffer, makeRoom);\n    }\n  },\n  {\n    getTag(typedArray) {\n      if (typedArray.constructor === Uint8Array) {\n        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n          return 64;\n      }\n    },\n    encode(typedArray, encode, makeRoom) {\n      writeBuffer(typedArray, makeRoom);\n    }\n  },\n  typedArrayEncoder(68, 1),\n  typedArrayEncoder(69, 2),\n  typedArrayEncoder(70, 4),\n  typedArrayEncoder(71, 8),\n  typedArrayEncoder(72, 1),\n  typedArrayEncoder(77, 2),\n  typedArrayEncoder(78, 4),\n  typedArrayEncoder(79, 8),\n  typedArrayEncoder(85, 4),\n  typedArrayEncoder(86, 8),\n  {\n    encode(sharedData, encode) {\n      let packedValues2 = sharedData.packedValues || [];\n      let sharedStructures = sharedData.structures || [];\n      if (packedValues2.values.length > 0) {\n        target[position2++] = 216;\n        target[position2++] = 51;\n        writeArrayHeader(4);\n        let valuesArray = packedValues2.values;\n        encode(valuesArray);\n        writeArrayHeader(0);\n        writeArrayHeader(0);\n        packedObjectMap = Object.create(sharedPackedObjectMap || null);\n        for (let i = 0, l = valuesArray.length;i < l; i++) {\n          packedObjectMap[valuesArray[i]] = i;\n        }\n      }\n      if (sharedStructures) {\n        targetView.setUint32(position2, 3655335424);\n        position2 += 3;\n        let definitions = sharedStructures.slice(0);\n        definitions.unshift(57344);\n        definitions.push(new Tag(sharedData.version, 1399353956));\n        encode(definitions);\n      } else\n        encode(new Tag(sharedData.version, 1399353956));\n    }\n  }\n];\nfunction typedArrayEncoder(tag, size) {\n  if (!isLittleEndianMachine2 && size > 1)\n    tag -= 4;\n  return {\n    tag,\n    encode: function writeExtBuffer(typedArray, encode) {\n      let length = typedArray.byteLength;\n      let offset = typedArray.byteOffset || 0;\n      let buffer = typedArray.buffer || typedArray;\n      encode(hasNodeBuffer ? Buffer2.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));\n    }\n  };\n}\nfunction writeBuffer(buffer, makeRoom) {\n  let length = buffer.byteLength;\n  if (length < 24) {\n    target[position2++] = 64 + length;\n  } else if (length < 256) {\n    target[position2++] = 88;\n    target[position2++] = length;\n  } else if (length < 65536) {\n    target[position2++] = 89;\n    target[position2++] = length >> 8;\n    target[position2++] = length & 255;\n  } else {\n    target[position2++] = 90;\n    targetView.setUint32(position2, length);\n    position2 += 4;\n  }\n  if (position2 + length >= target.length) {\n    makeRoom(position2 + length);\n  }\n  target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position2);\n  position2 += length;\n}\nfunction insertIds(serialized, idsToInsert) {\n  let nextId;\n  let distanceToMove = idsToInsert.length * 2;\n  let lastEnd = serialized.length - distanceToMove;\n  idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n  for (let id = 0;id < idsToInsert.length; id++) {\n    let referee = idsToInsert[id];\n    referee.id = id;\n    for (let position3 of referee.references) {\n      serialized[position3++] = id >> 8;\n      serialized[position3] = id & 255;\n    }\n  }\n  while (nextId = idsToInsert.pop()) {\n    let offset = nextId.offset;\n    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n    distanceToMove -= 2;\n    let position3 = offset + distanceToMove;\n    serialized[position3++] = 216;\n    serialized[position3++] = 28;\n    lastEnd = offset;\n  }\n  return serialized;\n}\nfunction writeBundles(start, encode) {\n  targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);\n  let writeStrings = bundledStrings2;\n  bundledStrings2 = null;\n  encode(writeStrings[0]);\n  encode(writeStrings[1]);\n}\nvar defaultEncoder = new Encoder({ useRecords: false });\nvar encode = defaultEncoder.encode;\nvar encodeAsIterable = defaultEncoder.encodeAsIterable;\nvar encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;\nvar REUSE_BUFFER_MODE = 512;\nvar RESET_BUFFER_MODE = 1024;\nvar THROW_ON_ITERABLE = 2048;\n// src/form/client/webauthn.ts\nvar bufferToBase64Url = (buffer) => {\n  const bytes = new Uint8Array(buffer);\n  let binary = \"\";\n  for (let i = 0;i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n};\nvar base64UrlToBuffer = (base64) => {\n  const binary = atob(base64.replace(/-/g, \"+\").replace(/_/g, \"/\"));\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0;i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes.buffer;\n};\nasync function registerPasskey(username) {\n  const challenge = crypto.getRandomValues(new Uint8Array(32));\n  const userId = crypto.getRandomValues(new Uint8Array(16));\n  const credential = await navigator.credentials.create({\n    publicKey: {\n      challenge,\n      rp: {\n        name: \"Sorane Web/A Form\"\n      },\n      user: {\n        id: userId,\n        name: username,\n        displayName: username\n      },\n      pubKeyCredParams: [{ alg: -7, type: \"public-key\" }],\n      authenticatorSelection: {\n        authenticatorAttachment: \"platform\",\n        userVerification: \"required\",\n        residentKey: \"preferred\"\n      },\n      timeout: 60000,\n      attestation: \"none\"\n    }\n  });\n  if (!credential)\n    throw new Error(\"Credential creation failed\");\n  return {\n    id: credential.id,\n    rawId: bufferToBase64Url(credential.rawId),\n    response: credential.response\n  };\n}\nasync function signWithPasskey(credentialId, challengeBuffer) {\n  const assertion = await navigator.credentials.get({\n    publicKey: {\n      challenge: challengeBuffer,\n      allowCredentials: [{\n        id: base64UrlToBuffer(credentialId),\n        type: \"public-key\"\n      }],\n      userVerification: \"required\"\n    }\n  });\n  if (!assertion)\n    throw new Error(\"Assertion failed\");\n  const response = assertion.response;\n  return {\n    id: assertion.id,\n    signature: bufferToBase64Url(response.signature),\n    authenticatorData: bufferToBase64Url(response.authenticatorData),\n    clientDataJSON: bufferToBase64Url(response.clientDataJSON)\n  };\n}\nasync function derivePasskeyPrf(credentialId, salt) {\n  const challenge = crypto.getRandomValues(new Uint8Array(32));\n  const assertion = await navigator.credentials.get({\n    publicKey: {\n      challenge,\n      allowCredentials: [{\n        id: base64UrlToBuffer(credentialId),\n        type: \"public-key\"\n      }],\n      userVerification: \"required\",\n      extensions: {\n        prf: {\n          eval: {\n            first: salt\n          }\n        }\n      }\n    }\n  });\n  if (!assertion)\n    throw new Error(\"Assertion failed\");\n  const results = assertion.getClientExtensionResults();\n  const prfOutput = results?.prf?.results?.first;\n  if (!prfOutput) {\n    throw new Error(\"PRF extension not available\");\n  }\n  return new Uint8Array(prfOutput);\n}\n\n// src/form/client/signer.ts\nfunction bytesToHex2(bytes) {\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction hexToBytes2(hex) {\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0;i < bytes.length; i++) {\n    bytes[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);\n  }\n  return bytes;\n}\n\nclass Signer {\n  usePasskey = true;\n  credentialId = null;\n  publicKey = null;\n  publicKeyType = \"ed25519\";\n  edPrivateKey = null;\n  constructor() {\n    this.loadKey();\n  }\n  loadKey() {\n    if (typeof localStorage === \"undefined\")\n      return;\n    const pkId = localStorage.getItem(\"weba_passkey_id\");\n    const pkPub = localStorage.getItem(\"weba_passkey_pub\");\n    if (pkId && pkPub) {\n      this.credentialId = pkId;\n      this.publicKey = hexToBytes2(pkPub);\n      this.publicKeyType = \"p256\";\n      this.usePasskey = true;\n      return;\n    }\n    const edPriv = localStorage.getItem(\"weba_private_key\");\n    if (edPriv) {\n      this.edPrivateKey = hexToBytes2(edPriv);\n      this.publicKey = ed25519.getPublicKey(this.edPrivateKey);\n      this.publicKeyType = \"ed25519\";\n      this.usePasskey = false;\n    }\n  }\n  resetKey() {\n    if (typeof localStorage !== \"undefined\") {\n      localStorage.removeItem(\"weba_passkey_id\");\n      localStorage.removeItem(\"weba_passkey_pub\");\n      localStorage.removeItem(\"weba_private_key\");\n    }\n    this.credentialId = null;\n    this.publicKey = null;\n    this.edPrivateKey = null;\n  }\n  async register() {\n    try {\n      console.log(\"Registering Passkey...\");\n      const result = await registerPasskey(\"User\");\n      const attestationObj = new Uint8Array(result.response.attestationObject);\n      const attStmt = decode(attestationObj);\n      const authData = attStmt.authData;\n      const dataView2 = new DataView(authData.buffer, authData.byteOffset, authData.byteLength);\n      let offset = 32 + 1 + 4 + 16;\n      const credIdLen = dataView2.getUint16(offset);\n      offset += 2;\n      offset += credIdLen;\n      const coseKeyBuffer = authData.slice(offset);\n      const coseKey = decode(coseKeyBuffer);\n      const x = coseKey.get(-2);\n      const y = coseKey.get(-3);\n      if (!x || !y)\n        throw new Error(\"Invalid COSE Key: x or y missing\");\n      const pubKey = new Uint8Array(1 + 32 + 32);\n      pubKey[0] = 4;\n      pubKey.set(x, 1);\n      pubKey.set(y, 33);\n      this.credentialId = result.rawId;\n      this.publicKey = pubKey;\n      this.publicKeyType = \"p256\";\n      this.usePasskey = true;\n      if (typeof localStorage !== \"undefined\") {\n        localStorage.setItem(\"weba_passkey_id\", this.credentialId);\n        localStorage.setItem(\"weba_passkey_pub\", bytesToHex2(this.publicKey));\n      }\n      console.log(\"Passkey Registered:\", this.credentialId);\n      return true;\n    } catch (e) {\n      console.warn(\"Passkey registration failed, falling back to Ed25519\", e);\n      this.generateEdKey();\n      return false;\n    }\n  }\n  generateEdKey() {\n    this.edPrivateKey = ed25519.utils.randomSecretKey();\n    this.publicKey = ed25519.getPublicKey(this.edPrivateKey);\n    this.publicKeyType = \"ed25519\";\n    this.usePasskey = false;\n    if (typeof localStorage !== \"undefined\") {\n      localStorage.setItem(\"weba_private_key\", bytesToHex2(this.edPrivateKey));\n    }\n  }\n  getIssuerDid() {\n    if (!this.publicKey)\n      return \"\";\n    return `did:key:z${bytesToHex2(this.publicKey)}`;\n  }\n  getPublicKey() {\n    return this.publicKey ? bytesToHex2(this.publicKey) : \"\";\n  }\n  async sign(payload, purpose = \"authentication\") {\n    if (!this.publicKey) {\n      await this.register();\n    }\n    const jsonString = import_canonicalize.default(payload);\n    const dataBytes = new TextEncoder().encode(jsonString);\n    if (this.usePasskey && this.credentialId) {\n      const hashBuffer = await crypto.subtle.digest(\"SHA-256\", dataBytes);\n      const sigRes = await signWithPasskey(this.credentialId, hashBuffer);\n      return {\n        ...payload,\n        proof: {\n          type: \"PasskeySignature2025\",\n          created: new Date().toISOString(),\n          verificationMethod: this.getIssuerDid(),\n          proofPurpose: purpose,\n          proofValue: sigRes.signature,\n          \"srn:authenticatorData\": sigRes.authenticatorData,\n          \"srn:clientDataJSON\": sigRes.clientDataJSON,\n          \"srn:credentialId\": sigRes.id\n        }\n      };\n    } else {\n      if (!this.edPrivateKey)\n        this.generateEdKey();\n      const signature = ed25519.sign(dataBytes, this.edPrivateKey);\n      return {\n        ...payload,\n        proof: {\n          type: \"Ed25519Signature2020\",\n          created: new Date().toISOString(),\n          verificationMethod: this.getIssuerDid(),\n          proofPurpose: purpose,\n          proofValue: bytesToHex2(signature)\n        }\n      };\n    }\n  }\n}\nvar globalSigner = new Signer;\n\n// node_modules/@noble/hashes/hmac.js\nclass _HMAC {\n  oHash;\n  iHash;\n  blockLen;\n  outputLen;\n  finished = false;\n  destroyed = false;\n  constructor(hash, key) {\n    ahash(hash);\n    abytes(key, undefined, \"key\");\n    this.iHash = hash.create();\n    if (typeof this.iHash.update !== \"function\")\n      throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0;i < pad.length; i++)\n      pad[i] ^= 54;\n    this.iHash.update(pad);\n    this.oHash = hash.create();\n    for (let i = 0;i < pad.length; i++)\n      pad[i] ^= 54 ^ 92;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf) {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out) {\n    aexists(this);\n    abytes(out, this.outputLen, \"output\");\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to) {\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone() {\n    return this._cloneInto();\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\nvar hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new _HMAC(hash, key);\n\n// node_modules/@noble/hashes/hkdf.js\nfunction extract(hash, ikm, salt) {\n  ahash(hash);\n  if (salt === undefined)\n    salt = new Uint8Array(hash.outputLen);\n  return hmac(hash, salt, ikm);\n}\nvar HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);\nvar EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();\nfunction expand(hash, prk, info, length = 32) {\n  ahash(hash);\n  anumber(length, \"length\");\n  const olen = hash.outputLen;\n  if (length > 255 * olen)\n    throw new Error(\"Length must be <= 255*HashLen\");\n  const blocks = Math.ceil(length / olen);\n  if (info === undefined)\n    info = EMPTY_BUFFER;\n  else\n    abytes(info, undefined, \"info\");\n  const okm = new Uint8Array(blocks * olen);\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0;counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);\n    okm.set(T, olen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  clean(T, HKDF_COUNTER);\n  return okm.slice(0, length);\n}\nvar hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n\n// src/form/client/l2crypto.ts\nvar import_canonicalize2 = __toESM(require_canonicalize(), 1);\nvar L2_SIG_KEY_STORAGE = \"weba_l2_ed25519_sk\";\nfunction b64urlEncode(bytes) {\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(bytes).toString(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n  }\n  let binary = \"\";\n  bytes.forEach((b) => {\n    binary += String.fromCharCode(b);\n  });\n  const base64 = btoa(binary);\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n}\nfunction b64urlDecode(value) {\n  const pad = value.length % 4 === 0 ? \"\" : \"=\".repeat(4 - value.length % 4);\n  const base64 = value.replace(/-/g, \"+\").replace(/_/g, \"/\") + pad;\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  }\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0;i < binary.length; i += 1) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\nfunction canonicalJson(obj) {\n  const result = import_canonicalize2.default(obj);\n  if (result === undefined) {\n    throw new Error(\"Failed to canonicalize JSON\");\n  }\n  return result;\n}\nfunction randomBytes2(len) {\n  const bytes = new Uint8Array(len);\n  crypto.getRandomValues(bytes);\n  return bytes;\n}\nfunction getOrCreateL2SigKey() {\n  const stored = localStorage.getItem(L2_SIG_KEY_STORAGE);\n  if (stored) {\n    return b64urlDecode(stored);\n  }\n  const sk = ed25519.utils.randomSecretKey();\n  localStorage.setItem(L2_SIG_KEY_STORAGE, b64urlEncode(sk));\n  return sk;\n}\nfunction buildAad(layer1Ref, recipientKid, webaVersion) {\n  const aadObj = {\n    layer1_ref: layer1Ref,\n    recipient: recipientKid,\n    weba_version: webaVersion\n  };\n  return new TextEncoder().encode(canonicalJson(aadObj));\n}\nfunction concatBytes2(a, b) {\n  const out = new Uint8Array(a.length + b.length);\n  out.set(a, 0);\n  out.set(b, a.length);\n  return out;\n}\nfunction getPqcProvider() {\n  const w = globalThis;\n  return w.webaPqcKem || null;\n}\nasync function aesGcmEncrypt(plaintext, keyBytes, iv, aad) {\n  const key = await crypto.subtle.importKey(\"raw\", keyBytes, \"AES-GCM\", false, [\"encrypt\"]);\n  const ct = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv, additionalData: aad }, key, plaintext);\n  return new Uint8Array(ct);\n}\nasync function wrapRecipientPrivateKey(params) {\n  const prk = hkdf(sha256, params.prfKey, undefined, undefined, 32);\n  const key = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/kw\"), 32);\n  const iv = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/kw-iv\"), 12);\n  const aad = params.aad ?? new Uint8Array;\n  return aesGcmEncrypt(params.recipientSk, key, iv, aad);\n}\nasync function aesGcmDecrypt(ciphertext, keyBytes, iv, aad) {\n  const key = await crypto.subtle.importKey(\"raw\", keyBytes, \"AES-GCM\", false, [\"decrypt\"]);\n  const pt = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv, additionalData: aad }, key, ciphertext);\n  return new Uint8Array(pt);\n}\nasync function buildLayer2Envelope(params) {\n  const webaVersion = params.config.weba_version ?? \"0.1\";\n  const recipientKid = params.config.recipient_kid;\n  const layer1Ref = params.config.layer1_ref;\n  const userKid = params.user_kid ?? \"user#sig-1\";\n  const userSk = getOrCreateL2SigKey();\n  const plainJson = canonicalJson(params.layer2_plain);\n  const plainBytes = new TextEncoder().encode(plainJson);\n  const sig = ed25519.sign(plainBytes, userSk);\n  const layer2Sig = {\n    alg: \"Ed25519\",\n    kid: userKid,\n    sig: b64urlEncode(sig),\n    created_at: new Date().toISOString()\n  };\n  const payload = {\n    layer2_plain: params.layer2_plain,\n    layer2_sig: layer2Sig\n  };\n  const aadBytes = buildAad(layer1Ref, recipientKid, webaVersion);\n  const payloadBytes = new TextEncoder().encode(canonicalJson(payload));\n  const recipientPub = b64urlDecode(params.config.recipient_x25519);\n  const ephSk = randomBytes2(32);\n  const ephPk = x25519.getPublicKey(ephSk);\n  const ss1 = x25519.getSharedSecret(ephSk, recipientPub);\n  let ikm = ss1;\n  let pqcEncapsulation;\n  let kemId = \"X25519\";\n  if (params.config.recipient_pqc) {\n    const provider = params.pqcProvider ?? getPqcProvider();\n    if (!provider) {\n      throw new Error(\"PQC requested but no provider is available\");\n    }\n    const pqcPub = b64urlDecode(params.config.recipient_pqc);\n    const kemResult = provider.encapsulate(pqcPub);\n    pqcEncapsulation = kemResult.encapsulation;\n    ikm = concatBytes2(ss1, kemResult.sharedSecret);\n    kemId = `X25519+${provider.kemId}`;\n  }\n  const prk = hkdf(sha256, ikm, aadBytes, undefined, 32);\n  const key = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/key\"), 32);\n  const iv = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/iv\"), 12);\n  const ciphertext = await aesGcmEncrypt(payloadBytes, key, iv, aadBytes);\n  return {\n    weba_version: webaVersion,\n    layer1_ref: layer1Ref,\n    layer2: {\n      enc: \"HPKE-v1\",\n      suite: {\n        kem: kemId,\n        kdf: \"HKDF-SHA256\",\n        aead: \"AES-256-GCM\"\n      },\n      recipient: recipientKid,\n      encapsulated: {\n        classical: b64urlEncode(ephPk),\n        ...pqcEncapsulation ? { pqc: b64urlEncode(pqcEncapsulation) } : {}\n      },\n      ciphertext: b64urlEncode(ciphertext),\n      aad: b64urlEncode(aadBytes)\n    },\n    meta: {\n      created_at: new Date().toISOString(),\n      nonce: b64urlEncode(randomBytes2(16))\n    }\n  };\n}\nfunction loadL2Config() {\n  const el = document.getElementById(\"weba-l2-config\");\n  if (!el || !el.textContent)\n    return null;\n  try {\n    return JSON.parse(el.textContent);\n  } catch {\n    return null;\n  }\n}\nasync function decryptLayer2Envelope(envelope, recipientSk, options) {\n  const aadBytes = b64urlDecode(envelope.layer2.aad);\n  const aadObj = {\n    layer1_ref: envelope.layer1_ref,\n    recipient: envelope.layer2.recipient,\n    weba_version: envelope.weba_version\n  };\n  const expectedAad = new TextEncoder().encode(canonicalJson(aadObj));\n  if (b64urlEncode(expectedAad) !== envelope.layer2.aad) {\n    throw new Error(\"AAD mismatch\");\n  }\n  const ephPub = b64urlDecode(envelope.layer2.encapsulated.classical);\n  const ss1 = x25519.getSharedSecret(recipientSk, ephPub);\n  let ikm = ss1;\n  if (envelope.layer2.encapsulated.pqc) {\n    const provider = options?.pqcProvider ?? getPqcProvider();\n    const pqcSk = options?.pqcRecipientSk;\n    if (!provider || !pqcSk) {\n      throw new Error(\"Missing PQC KEM for envelope\");\n    }\n    const pqcEnc = b64urlDecode(envelope.layer2.encapsulated.pqc);\n    const ss2 = provider.decapsulate(pqcSk, pqcEnc);\n    ikm = concatBytes2(ss1, ss2);\n  }\n  const prk = hkdf(sha256, ikm, aadBytes, undefined, 32);\n  const key = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/key\"), 32);\n  const iv = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/iv\"), 12);\n  const ct = b64urlDecode(envelope.layer2.ciphertext);\n  const pt = await aesGcmDecrypt(ct, key, iv, aadBytes);\n  return JSON.parse(new TextDecoder().decode(pt));\n}\nasync function unwrapRecipientPrivateKey(params) {\n  const prk = hkdf(sha256, params.prfKey, undefined, undefined, 32);\n  const key = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/kw\"), 32);\n  const iv = hkdf(sha256, prk, undefined, new TextEncoder().encode(\"weba-l2/kw-iv\"), 12);\n  const aad = params.keywrap.aad ? b64urlDecode(params.keywrap.aad) : new Uint8Array;\n  const wrapped = b64urlDecode(params.keywrap.wrapped_key);\n  return aesGcmDecrypt(wrapped, key, iv, aad);\n}\n\n// src/form/client/data.ts\nclass DataManager {\n  formId;\n  constructor() {\n    this.formId = \"WebA_\" + window.location.pathname;\n  }\n  updateJsonLd() {\n    const w = window;\n    const data = w.generatedJsonStructure || {};\n    document.querySelectorAll(\"[data-json-path]\").forEach((input) => {\n      const key = input.dataset.jsonPath;\n      if (key) {\n        data[key] = input.value;\n      }\n    });\n    document.querySelectorAll('[type=\"radio\"]:checked').forEach((radio) => {\n      data[radio.name] = radio.value;\n    });\n    document.querySelectorAll(\"table.data-table.dynamic\").forEach((table) => {\n      const tableKey = table.dataset.tableKey;\n      if (tableKey) {\n        const rows = [];\n        table.querySelectorAll(\"tbody tr\").forEach((tr) => {\n          const rowData = {};\n          let hasVal = false;\n          tr.querySelectorAll(\"[data-base-key]\").forEach((input) => {\n            if (input.type === \"checkbox\") {\n              rowData[input.dataset.baseKey] = input.checked;\n              if (input.checked)\n                hasVal = true;\n            } else {\n              rowData[input.dataset.baseKey] = input.value;\n              if (input.value)\n                hasVal = true;\n            }\n          });\n          if (hasVal)\n            rows.push(rowData);\n        });\n        data[tableKey] = rows;\n      }\n    });\n    const scriptBlock = document.getElementById(\"json-ld\");\n    if (scriptBlock) {\n      scriptBlock.textContent = JSON.stringify(data, null, 2);\n    }\n    const debugBlock = document.getElementById(\"json-debug\");\n    if (debugBlock) {\n      debugBlock.textContent = JSON.stringify(data, null, 2);\n    }\n    return data;\n  }\n  getL2Config() {\n    const w = window;\n    return w.webaL2Config || null;\n  }\n  async signAndDownload() {\n    const data = this.updateJsonLd();\n    const w = window;\n    const formName = w.generatedJsonStructure && w.generatedJsonStructure.name || \"Response\";\n    const templateId = window.location.href.split(\"#\")[0];\n    const l2Config = this.getL2Config();\n    const l2Toggle = document.getElementById(\"weba-l2-encrypt\");\n    const l2Enabled = !!(l2Config?.enabled && (l2Toggle ? l2Toggle.checked : l2Config.default_enabled));\n    if (l2Enabled) {\n      if (!l2Config?.recipient_kid || !l2Config?.recipient_x25519 || !l2Config?.layer1_ref) {\n        alert(\"L2 encryption config is missing required fields.\");\n        return;\n      }\n      try {\n        const envelope = await buildLayer2Envelope({\n          layer2_plain: data,\n          config: l2Config,\n          user_kid: l2Config.user_kid\n        });\n        this.downloadHtml(\"submit\", true, { l2Envelope: envelope, stripPlaintext: true });\n      } catch (e) {\n        console.error(e);\n        alert(\"L2 encryption failed. Please check your recipient key settings.\");\n      }\n      return;\n    }\n    if (!globalSigner.getPublicKey()) {\n      const success = await globalSigner.register();\n      if (!success) {\n        alert(\"Key registration failed.\");\n        return;\n      }\n    }\n    const payload = {\n      \"@context\": [\"https://www.w3.org/2018/credentials/v1\"],\n      type: [\"VerifiableCredential\", \"WebAFormResponse\"],\n      issuer: globalSigner.getIssuerDid(),\n      issuanceDate: new Date().toISOString(),\n      credentialSubject: {\n        id: `urn:uuid:${crypto.randomUUID()}`,\n        type: \"WebAFormResponse\",\n        templateId,\n        answers: data\n      }\n    };\n    try {\n      const signedVc = await globalSigner.sign(payload);\n      this.downloadHtml(\"submitted\", true, { embeddedVc: signedVc });\n    } catch (e) {\n      console.error(e);\n      alert(\"Signing failed. Please ensure you are in a secure context (HTTPS/localhost).\");\n    }\n  }\n  saveToLS() {\n    const data = this.updateJsonLd();\n    localStorage.setItem(this.formId, JSON.stringify(data));\n  }\n  restoreFromLS() {\n    const c = localStorage.getItem(this.formId);\n    if (!c)\n      return;\n    try {\n      const d = JSON.parse(c);\n      document.querySelectorAll(\"[data-json-path]\").forEach((input) => {\n        const key = input.dataset.jsonPath;\n        if (d[key] !== undefined)\n          input.value = d[key];\n      });\n      document.querySelectorAll(\"table.data-table.dynamic\").forEach((table) => {\n        const tableKey = table.dataset.tableKey;\n        const rowsData = d[tableKey];\n        if (Array.isArray(rowsData)) {\n          const tbody = table.querySelector(\"tbody\");\n          if (!tbody)\n            return;\n          const currentRows = tbody.querySelectorAll(\".template-row\");\n          rowsData.forEach((rowData, idx) => {\n            let row;\n            if (idx === 0) {\n              row = tbody.querySelector(\".template-row\");\n            } else {\n              const tmpl = tbody.querySelector(\".template-row\");\n              if (tmpl) {\n                row = tmpl.cloneNode(true);\n                row.classList.remove(\"template-row\");\n                const rmBtn = row.querySelector(\".remove-row-btn\");\n                if (rmBtn)\n                  rmBtn.style.visibility = \"visible\";\n                tbody.appendChild(row);\n              }\n            }\n            if (row) {\n              row.querySelectorAll(\"input, select\").forEach((input) => {\n                const k = input.dataset.baseKey;\n                if (k && rowData[k] !== undefined) {\n                  if (input.type === \"checkbox\")\n                    input.checked = !!rowData[k];\n                  else\n                    input.value = rowData[k];\n                }\n              });\n            }\n          });\n        }\n      });\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  clearData() {\n    if (confirm(\"Clear all saved data? / \u4fdd\u5b58\u3055\u308c\u305f\u30c7\u30fc\u30bf\u3092\u524a\u9664\u3057\u307e\u3059\u304b\uff1f\")) {\n      localStorage.removeItem(this.formId);\n      window.location.reload();\n    }\n  }\n  bakeValues() {\n    this.updateJsonLd();\n    document.querySelectorAll(\"input, textarea, select\").forEach((el) => {\n      if (el.closest(\".template-row\"))\n        return;\n      if (el.type === \"checkbox\" || el.type === \"radio\") {\n        if (el.checked)\n          el.setAttribute(\"checked\", \"checked\");\n        else\n          el.removeAttribute(\"checked\");\n      } else {\n        el.setAttribute(\"value\", el.value);\n        if (el.tagName === \"TEXTAREA\")\n          el.textContent = el.value;\n      }\n    });\n  }\n  downloadHtml(filenameSuffix, isFinal, options) {\n    const w = window;\n    const parser = new DOMParser;\n    const doc = parser.parseFromString(document.documentElement.outerHTML, \"text/html\");\n    if (options?.stripPlaintext) {\n      doc.querySelectorAll(\"input\").forEach((input) => {\n        if (input.type === \"checkbox\" || input.type === \"radio\") {\n          input.checked = false;\n          input.removeAttribute(\"checked\");\n        } else {\n          input.value = \"\";\n          input.removeAttribute(\"value\");\n        }\n      });\n      doc.querySelectorAll(\"textarea\").forEach((area) => {\n        area.value = \"\";\n        area.textContent = \"\";\n      });\n      doc.querySelectorAll(\"select\").forEach((select) => {\n        select.selectedIndex = -1;\n        select.querySelectorAll(\"option\").forEach((opt) => opt.removeAttribute(\"selected\"));\n      });\n      doc.getElementById(\"json-ld\")?.remove();\n      doc.getElementById(\"data-layer\")?.remove();\n      const debug = doc.getElementById(\"json-debug\");\n      if (debug)\n        debug.textContent = \"\";\n    }\n    if (options?.embeddedVc) {\n      const vcJson = JSON.stringify(options.embeddedVc, null, 2);\n      const vcScript = doc.createElement(\"script\");\n      vcScript.type = \"application/ld+json\";\n      vcScript.id = \"weba-user-vc\";\n      vcScript.textContent = vcJson;\n      doc.body.appendChild(vcScript);\n      const vcViewer = doc.createElement(\"div\");\n      vcViewer.className = \"weba-user-verification no-print\";\n      vcViewer.style.cssText = \"margin-top:2rem;padding:1rem;border:1px solid #10b981;border-radius:8px;background:#f0fdf4;font-size:0.85rem;\";\n      vcViewer.innerHTML = `\n                <details>\n                    <summary style=\"cursor: pointer; display: flex; align-items: center; gap: 0.5rem; color: #047857; font-weight: 600;\">\n                        <span>\u2713</span> \u5229\u7528\u8005\u306b\u3088\u308b\u7f72\u540d\u306e\u8a3c\u660e\n                    </summary>\n                    <div style=\"padding: 1rem 0;\">\n                        <pre style=\"background: #1e1e1e; color: #d4d4d4; padding: 1rem; border-radius: 6px; overflow-x: auto; font-size: 0.8rem; line-height: 1.4;\"></pre>\n                    </div>\n                </details>\n            `;\n      const pre = vcViewer.querySelector(\"pre\");\n      if (pre)\n        pre.textContent = vcJson;\n      doc.body.appendChild(vcViewer);\n    }\n    if (options?.l2Envelope) {\n      const envScript = doc.createElement(\"script\");\n      envScript.id = \"weba-l2-envelope\";\n      envScript.type = \"application/json\";\n      envScript.textContent = JSON.stringify(options.l2Envelope, null, 2);\n      doc.body.appendChild(envScript);\n    }\n    const htmlContent = doc.documentElement.outerHTML;\n    const blob = new Blob([htmlContent], { type: \"text/html\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    const title = w.generatedJsonStructure && w.generatedJsonStructure.name || \"web-a-form\";\n    const now = new Date;\n    const dateStr = now.getFullYear() + (\"0\" + (now.getMonth() + 1)).slice(-2) + (\"0\" + now.getDate()).slice(-2) + \"-\" + (\"0\" + now.getHours()).slice(-2) + (\"0\" + now.getMinutes()).slice(-2);\n    const randomId = Math.random().toString(36).substring(2, 8);\n    const filename = `${title}_${dateStr}_${filenameSuffix}_${randomId}.html`;\n    a.download = filename;\n    a.click();\n    if (isFinal) {\n      setTimeout(() => window.location.reload(), 1000);\n    }\n  }\n  saveDraft() {\n    this.bakeValues();\n    this.downloadHtml(\"draft\", false);\n  }\n  submitDocument() {\n    this.bakeValues();\n    document.querySelectorAll(\".search-suggestions\").forEach((el) => el.remove());\n    this.downloadHtml(\"submit\", true);\n  }\n}\n\n// src/form/client/ui.ts\nclass UIManager {\n  calc;\n  data;\n  constructor(calc, data) {\n    this.calc = calc;\n    this.data = data;\n  }\n  applyI18n() {\n    const RESOURCES = {\n      en: {\n        add_row: \"+ Add Row\",\n        work_save_btn: \"Save Progress\",\n        clear_btn: \"Clear Data\",\n        sign_btn: \"Submit\"\n      },\n      ja: {\n        add_row: \"+ \u884c\u3092\u8ffd\u52a0\",\n        work_save_btn: \"\u4f5c\u696d\u5185\u5bb9\u3092\u4fdd\u5b58\",\n        clear_btn: \"\u30af\u30ea\u30a2\",\n        sign_btn: \"\u63d0\u51fa\u7248\u3092\u4fdd\u5b58\"\n      }\n    };\n    const lang = (navigator.language || \"en\").startsWith(\"ja\") ? \"ja\" : \"en\";\n    const dict = RESOURCES[lang] || RESOURCES[\"en\"];\n    document.querySelectorAll(\"[data-i18n]\").forEach((el) => {\n      const key = el.dataset.i18n;\n      if (dict[key])\n        el.textContent = dict[key];\n    });\n  }\n  initTables() {\n    document.querySelectorAll(\".data-table.dynamic tbody\").forEach((tbody) => {\n      this.renumberRows(tbody);\n    });\n  }\n  renumberRows(tbody) {\n    const rows = Array.from(tbody.querySelectorAll(\"tr\")).filter((row) => {\n      return row.querySelectorAll(\"td\").length > 0;\n    });\n    rows.forEach((row, index) => {\n      const num = index + 1;\n      row.querySelectorAll(\".auto-num\").forEach((input) => {\n        if (input.value != num) {\n          input.value = num.toString();\n          input.dispatchEvent(new Event(\"input\", { bubbles: true }));\n        }\n      });\n    });\n  }\n  removeTableRow(btn) {\n    const tr = btn.closest(\"tr\");\n    const tbody = tr.parentElement;\n    if (tr.classList.contains(\"template-row\")) {\n      tr.querySelectorAll(\"input\").forEach((inp) => {\n        if (inp.type === \"checkbox\")\n          inp.checked = false;\n        else\n          inp.value = \"\";\n      });\n    } else {\n      tr.remove();\n      if (tbody)\n        this.renumberRows(tbody);\n      this.calc.recalculate();\n      this.data.updateJsonLd();\n    }\n  }\n  addTableRow(btn, tableKey) {\n    const table = document.getElementById(\"tbl_\" + tableKey);\n    if (!table)\n      return;\n    const tbody = table.querySelector(\"tbody\");\n    if (!tbody)\n      return;\n    const templateRow = tbody.querySelector(\".template-row\");\n    if (!templateRow)\n      return;\n    const newRow = templateRow.cloneNode(true);\n    newRow.classList.remove(\"template-row\");\n    newRow.querySelectorAll(\"input\").forEach((input) => {\n      if (input.type === \"checkbox\") {\n        input.checked = input.hasAttribute(\"checked\");\n      } else {\n        input.value = input.getAttribute(\"value\") || \"\";\n      }\n    });\n    const rmBtn = newRow.querySelector(\".remove-row-btn\");\n    if (rmBtn)\n      rmBtn.style.visibility = \"visible\";\n    newRow.querySelectorAll(\"[data-copy-from]\").forEach((target2) => {\n      const srcKey = target2.dataset.copyFrom;\n      if (srcKey) {\n        const src2 = newRow.querySelector(`[data-base-key=\"${srcKey}\"]`);\n        if (src2 && src2.value) {\n          target2.value = src2.value;\n        }\n      }\n    });\n    tbody.appendChild(newRow);\n    this.renumberRows(tbody);\n    this.calc.recalculate();\n  }\n  switchTab(btn, tabId) {\n    document.querySelectorAll(\".tab-btn\").forEach((b) => b.classList.remove(\"active\"));\n    document.querySelectorAll(\".tab-content\").forEach((c) => c.classList.remove(\"active\"));\n    btn.classList.add(\"active\");\n    const content = document.getElementById(tabId);\n    if (content)\n      content.classList.add(\"active\");\n  }\n}\n\n// src/form/client/l2viewer.ts\nfunction parseJsonScript(id) {\n  const el = document.getElementById(id);\n  if (!el || !el.textContent)\n    return null;\n  try {\n    return JSON.parse(el.textContent);\n  } catch {\n    return null;\n  }\n}\nfunction initL2Viewer() {\n  const envelope = parseJsonScript(\"weba-l2-envelope\");\n  if (!envelope)\n    return;\n  const keywrap = parseJsonScript(\"weba-l2-keywrap\");\n  const host = document.querySelector(\".weba-form-container\") || document.body;\n  const panel = document.createElement(\"div\");\n  panel.className = \"weba-l2-unlock\";\n  panel.style.cssText = \"margin-top:2rem;padding:1rem;border:1px solid #cbd5f5;border-radius:10px;background:#f8fafc;\";\n  const title = document.createElement(\"div\");\n  title.textContent = \"Encrypted Submission\";\n  title.style.cssText = \"font-weight:600;color:#334155;margin-bottom:0.5rem;\";\n  panel.appendChild(title);\n  const status = document.createElement(\"div\");\n  status.textContent = \"Locked. Unlock with Passkey.\";\n  status.style.cssText = \"color:#64748b;margin-bottom:0.75rem;\";\n  panel.appendChild(status);\n  const button = document.createElement(\"button\");\n  button.textContent = \"Unlock (Passkey)\";\n  button.style.cssText = \"padding:0.5rem 1rem;border:1px solid #94a3b8;border-radius:6px;background:#fff;cursor:pointer;\";\n  panel.appendChild(button);\n  const output = document.createElement(\"pre\");\n  output.style.cssText = \"margin-top:1rem;padding:1rem;background:#0f172a;color:#e2e8f0;border-radius:8px;overflow:auto;font-size:0.85rem;display:none;\";\n  panel.appendChild(output);\n  const sigDetails = document.createElement(\"details\");\n  sigDetails.style.cssText = \"margin-top:0.75rem; display:none;\";\n  sigDetails.innerHTML = `<summary style=\"cursor:pointer;color:#64748b;\">Show signature</summary><pre style=\"margin-top:0.5rem;padding:0.75rem;background:#0b1220;color:#cbd5f5;border-radius:6px;overflow:auto;font-size:0.8rem;\"></pre>`;\n  panel.appendChild(sigDetails);\n  const exportBtn = document.createElement(\"button\");\n  exportBtn.textContent = \"Export JSON\";\n  exportBtn.style.cssText = \"margin-top:0.75rem;padding:0.45rem 0.9rem;border:1px solid #94a3b8;border-radius:6px;background:#fff;cursor:pointer;display:none;\";\n  exportBtn.disabled = true;\n  panel.appendChild(exportBtn);\n  button.addEventListener(\"click\", async () => {\n    if (!keywrap) {\n      status.textContent = \"Key wrap package not found.\";\n      return;\n    }\n    button.disabled = true;\n    status.textContent = \"Waiting for passkey...\";\n    try {\n      const prfSalt = b64urlDecode(keywrap.prf_salt);\n      const prfKey = await derivePasskeyPrf(keywrap.credential_id, prfSalt);\n      const recipientSk = await unwrapRecipientPrivateKey({\n        keywrap,\n        prfKey\n      });\n      const payload = await decryptLayer2Envelope(envelope, recipientSk);\n      applyLayer2Payload(payload.layer2_plain);\n      document.body.classList.add(\"weba-l2-readonly\");\n      output.textContent = JSON.stringify(payload.layer2_plain, null, 2);\n      output.style.display = \"block\";\n      const sigPre = sigDetails.querySelector(\"pre\");\n      if (sigPre) {\n        sigPre.textContent = JSON.stringify(payload.layer2_sig, null, 2);\n      }\n      sigDetails.style.display = \"block\";\n      exportBtn.style.display = \"inline-block\";\n      exportBtn.disabled = false;\n      status.textContent = \"Unlocked.\";\n      exportBtn.onclick = () => {\n        const blob = new Blob([JSON.stringify(payload, null, 2)], {\n          type: \"application/json\"\n        });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"weba-l2-decrypted.json\";\n        a.click();\n      };\n    } catch (e) {\n      console.error(e);\n      status.textContent = \"Unlock failed.\";\n      button.disabled = false;\n    }\n  });\n  host.appendChild(panel);\n}\nfunction applyLayer2Payload(plain) {\n  if (!plain || typeof plain !== \"object\")\n    return;\n  const data = plain;\n  document.querySelectorAll(\"[data-json-path]\").forEach((input) => {\n    const key = input.dataset.jsonPath;\n    if (!key || !(key in data))\n      return;\n    const value = data[key];\n    if (input.type === \"checkbox\") {\n      input.checked = Boolean(value);\n    } else if (input.type === \"radio\") {\n      input.checked = input.value === String(value);\n    } else {\n      input.value = value === null || value === undefined ? \"\" : String(value);\n    }\n  });\n  document.querySelectorAll('input[type=\"radio\"]').forEach((radio) => {\n    const key = radio.name;\n    if (!key || !(key in data))\n      return;\n    const value = data[key];\n    radio.checked = radio.value === String(value);\n  });\n  document.querySelectorAll(\"table.data-table.dynamic\").forEach((table) => {\n    const tableKey = table.dataset.tableKey;\n    if (!tableKey)\n      return;\n    const rowsData = data[tableKey];\n    if (!Array.isArray(rowsData))\n      return;\n    const tbody = table.querySelector(\"tbody\");\n    if (!tbody)\n      return;\n    const templateRow = tbody.querySelector(\"tr.template-row\");\n    if (!templateRow)\n      return;\n    Array.from(tbody.querySelectorAll(\"tr\")).forEach((row) => {\n      if (!row.classList.contains(\"template-row\"))\n        row.remove();\n    });\n    rowsData.forEach((rowData, idx) => {\n      const row = idx === 0 ? templateRow : templateRow.cloneNode(true);\n      if (idx > 0) {\n        row.classList.remove(\"template-row\");\n        const rmBtn = row.querySelector(\".remove-row-btn\");\n        if (rmBtn)\n          rmBtn.style.visibility = \"visible\";\n        tbody.appendChild(row);\n      }\n      if (rowData && typeof rowData === \"object\") {\n        row.querySelectorAll(\"input, select, textarea\").forEach((input) => {\n          const key = input.dataset.baseKey;\n          if (!key)\n            return;\n          const value = rowData[key];\n          if (input.type === \"checkbox\") {\n            input.checked = Boolean(value);\n          } else {\n            input.value = value === null || value === undefined ? \"\" : String(value);\n          }\n        });\n      }\n    });\n  });\n  document.querySelectorAll(\"input\").forEach((input) => {\n    if (input.type === \"checkbox\" || input.type === \"radio\") {\n      input.disabled = true;\n    } else {\n      input.readOnly = true;\n    }\n  });\n  document.querySelectorAll(\"textarea\").forEach((area) => {\n    area.readOnly = true;\n  });\n  document.querySelectorAll(\"select\").forEach((select) => {\n    select.disabled = true;\n  });\n  document.querySelectorAll(\".form-toolbar button, .add-row-btn, .remove-row-btn\").forEach((btn) => {\n    btn.disabled = true;\n  });\n}\n\n// src/form/client/keywrap_tool.ts\nfunction byId(id) {\n  return document.getElementById(id);\n}\nfunction initKeywrapTool() {\n  const host = byId(\"weba-l2-keywrap-tool\");\n  if (!host)\n    return;\n  const recipientInput = byId(\"kwp-recipient-sk\");\n  const credInput = byId(\"kwp-credential-id\");\n  const saltInput = byId(\"kwp-prf-salt\");\n  const aadInput = byId(\"kwp-aad\");\n  const kidInput = byId(\"kwp-kid\");\n  const status = byId(\"kwp-status\");\n  const output = byId(\"kwp-output\");\n  const genSaltBtn = byId(\"kwp-generate-salt\");\n  const wrapBtn = byId(\"kwp-wrap\");\n  if (!recipientInput || !credInput || !saltInput || !status || !output || !wrapBtn) {\n    return;\n  }\n  genSaltBtn?.addEventListener(\"click\", () => {\n    const salt = new Uint8Array(32);\n    crypto.getRandomValues(salt);\n    saltInput.value = b64urlEncode(salt);\n  });\n  wrapBtn.addEventListener(\"click\", async () => {\n    status.textContent = \"Waiting for passkey...\";\n    wrapBtn.disabled = true;\n    try {\n      if (!recipientInput.value || !credInput.value || !saltInput.value) {\n        throw new Error(\"Missing required fields.\");\n      }\n      const recipientSk = b64urlDecode(recipientInput.value.trim());\n      const prfSalt = b64urlDecode(saltInput.value.trim());\n      const prfKey = await derivePasskeyPrf(credInput.value.trim(), prfSalt);\n      const aad = aadInput?.value ? b64urlDecode(aadInput.value.trim()) : undefined;\n      const wrapped = await wrapRecipientPrivateKey({ recipientSk, prfKey, aad });\n      const keywrap = {\n        alg: \"WebAuthn-PRF-AESGCM-v1\",\n        kid: kidInput?.value || \"issuer#passkey-1\",\n        credential_id: credInput.value.trim(),\n        prf_salt: b64urlEncode(prfSalt),\n        wrapped_key: b64urlEncode(wrapped),\n        ...aad ? { aad: b64urlEncode(aad) } : {}\n      };\n      output.textContent = JSON.stringify(keywrap, null, 2);\n      status.textContent = \"Key wrap ready.\";\n    } catch (e) {\n      console.error(e);\n      status.textContent = \"Key wrap failed.\";\n    } finally {\n      wrapBtn.disabled = false;\n    }\n  });\n}\n\n// src/form/client/aggregator_browser.ts\nfunction parseHtml(html) {\n  if (typeof DOMParser !== \"undefined\") {\n    return new DOMParser().parseFromString(html, \"text/html\");\n  }\n  if (typeof document !== \"undefined\") {\n    const doc = document.implementation.createHTMLDocument(\"\");\n    doc.documentElement.innerHTML = html;\n    return doc;\n  }\n  return null;\n}\nfunction extractScriptById(html, id) {\n  const doc = parseHtml(html);\n  if (doc) {\n    const script = doc.getElementById(id);\n    return script?.textContent ?? null;\n  }\n  const re = new RegExp(`<script[^>]*id=[\"']${id}[\"'][^>]*>([\\\\s\\\\S]*?)<\\\\/script>`, \"i\");\n  const match = html.match(re);\n  return match ? match[1] : null;\n}\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction extractScriptByType(html, type) {\n  const doc = parseHtml(html);\n  if (doc) {\n    const script = doc.querySelector(`script[type=\"${type}\"]`);\n    return script?.textContent ?? null;\n  }\n  const re = new RegExp(`<script[^>]*type=[\"']${escapeRegex(type)}[\"'][^>]*>([\\\\s\\\\S]*?)<\\\\/script>`, \"i\");\n  const match = html.match(re);\n  return match ? match[1] : null;\n}\nfunction extractJsonLdFromHtml(html) {\n  const dataLayer = extractScriptById(html, \"data-layer\");\n  if (dataLayer) {\n    try {\n      return JSON.parse(dataLayer);\n    } catch {\n      return null;\n    }\n  }\n  const ldScript = extractScriptByType(html, \"application/ld+json\");\n  if (ldScript) {\n    try {\n      return JSON.parse(ldScript);\n    } catch {\n      return null;\n    }\n  }\n  return null;\n}\nfunction extractL2EnvelopeFromHtml(html) {\n  const script = extractScriptById(html, \"weba-l2-envelope\");\n  if (!script)\n    return null;\n  try {\n    return JSON.parse(script);\n  } catch {\n    return null;\n  }\n}\nfunction parseKeyJson(raw) {\n  if (!raw.trim())\n    return null;\n  try {\n    const parsed = JSON.parse(raw);\n    if (!parsed.recipient_x25519_private)\n      return null;\n    return parsed;\n  } catch {\n    return null;\n  }\n}\nfunction parseKeyScript() {\n  const script = document.getElementById(\"weba-l2-keys\");\n  if (!script?.textContent)\n    return null;\n  return parseKeyJson(script.textContent);\n}\nfunction flattenForCsv(obj) {\n  const out = {};\n  const walk = (value, prefix) => {\n    if (value === null || value === undefined) {\n      out[prefix] = null;\n      return;\n    }\n    if (Array.isArray(value)) {\n      value.forEach((entry, idx) => {\n        walk(entry, prefix ? `${prefix}[${idx}]` : `[${idx}]`);\n      });\n      return;\n    }\n    if (typeof value === \"object\") {\n      Object.entries(value).forEach(([k, v]) => {\n        const next = prefix ? `${prefix}.${k}` : k;\n        walk(v, next);\n      });\n      return;\n    }\n    out[prefix] = value;\n  };\n  walk(obj, \"\");\n  if (\"\" in out)\n    delete out[\"\"];\n  return out;\n}\nfunction buildRowFromPlain(params) {\n  const row = { _filename: params.filename };\n  const keys = new Set([\"_filename\"]);\n  if (params.includeJson) {\n    keys.add(\"_json\");\n    row._json = JSON.stringify(params.plain);\n  }\n  const flat = flattenForCsv(params.plain || {});\n  for (const key of Object.keys(flat)) {\n    if (params.omitKey && params.omitKey(key))\n      continue;\n    keys.add(key);\n    row[key] = flat[key];\n  }\n  if (params.sig) {\n    keys.add(\"_l2_sig\");\n    row._l2_sig = JSON.stringify(params.sig);\n  }\n  return { row, keys };\n}\nasync function extractPlainFromHtml(html, l2Keys) {\n  const l2Envelope = extractL2EnvelopeFromHtml(html);\n  if (l2Envelope && l2Keys) {\n    if (l2Keys.recipient_kid && l2Envelope.layer2?.recipient && l2Keys.recipient_kid !== l2Envelope.layer2.recipient) {\n      throw new Error(`recipient_kid mismatch (${l2Envelope.layer2.recipient})`);\n    }\n    const recipientSk = b64urlDecode(l2Keys.recipient_x25519_private);\n    const pqc = l2Keys.recipient_pqc_private && l2Keys.recipient_pqc_kem === \"ML-KEM-768\" ? {\n      pqcProvider: globalThis.webaPqcKem ?? null,\n      pqcRecipientSk: b64urlDecode(l2Keys.recipient_pqc_private)\n    } : undefined;\n    const payload = await decryptLayer2Envelope(l2Envelope, recipientSk, pqc);\n    return {\n      plain: payload.layer2_plain ?? payload,\n      sig: payload.layer2_sig,\n      source: \"l2\"\n    };\n  }\n  const jsonLd = extractJsonLdFromHtml(html);\n  if (jsonLd)\n    return { plain: jsonLd, source: \"jsonld\" };\n  return { source: null };\n}\nfunction escapeCsv(value) {\n  if (value === null || value === undefined)\n    return \"\";\n  const str = String(value);\n  if (/[\",\\n]/.test(str)) {\n    return `\"${str.replace(/\"/g, '\"\"')}\"`;\n  }\n  return str;\n}\nfunction buildCsv(rows, keys) {\n  const lines = [];\n  lines.push(keys.map(escapeCsv).join(\",\"));\n  rows.forEach((row) => {\n    const line = keys.map((key) => escapeCsv(row[key])).join(\",\");\n    lines.push(line);\n  });\n  return \"\\uFEFF\" + lines.join(`\n`);\n}\nfunction renderTable(root, rows, keys) {\n  if (rows.length === 0) {\n    root.innerHTML = '<div class=\"agg-empty\">No rows to display.</div>';\n    return;\n  }\n  const header = keys.map((key) => `<th>${key}</th>`).join(\"\");\n  const body = rows.slice(0, 20).map((row) => {\n    const cells = keys.map((key) => `<td>${row[key] ?? \"\"}</td>`).join(\"\");\n    return `<tr>${cells}</tr>`;\n  }).join(\"\");\n  root.innerHTML = `<table class=\"agg-table\"><thead><tr>${header}</tr></thead><tbody>${body}</tbody></table>`;\n}\nfunction initAggregatorBrowser() {\n  const root = document.getElementById(\"aggregator-root\");\n  if (!root)\n    return;\n  root.innerHTML = `\n    <div class=\"agg-panel\">\n      <div class=\"agg-row\">\n        <label class=\"agg-label\">Input HTML</label>\n        <input id=\"weba-agg-files\" type=\"file\" accept=\".html\" multiple />\n      </div>\n      <div class=\"agg-row\">\n        <label class=\"agg-label\">L2 Key (embedded)</label>\n        <div id=\"weba-agg-key-status\" class=\"agg-chip\">Not loaded</div>\n        <div class=\"agg-note\">Use <code>&lt;script id=\"weba-l2-keys\"&gt;</code> to embed.</div>\n      </div>\n      <div class=\"agg-row\">\n        <label class=\"agg-label\">Include JSON</label>\n        <input id=\"weba-agg-include-json\" type=\"checkbox\" />\n      </div>\n      <div class=\"agg-row\">\n        <button id=\"weba-agg-run\" class=\"agg-btn\">Decrypt & Aggregate</button>\n        <button id=\"weba-agg-download\" class=\"agg-btn secondary\" disabled>Download CSV</button>\n      </div>\n      <div id=\"weba-agg-status\" class=\"agg-status\">Ready.</div>\n    </div>\n    <div id=\"weba-agg-output\" class=\"agg-output\"></div>\n  `;\n  const fileInput = root.querySelector(\"#weba-agg-files\");\n  const status = root.querySelector(\"#weba-agg-status\");\n  const output = root.querySelector(\"#weba-agg-output\");\n  const includeJson = root.querySelector(\"#weba-agg-include-json\");\n  const runBtn = root.querySelector(\"#weba-agg-run\");\n  const dlBtn = root.querySelector(\"#weba-agg-download\");\n  const keyStatus = root.querySelector(\"#weba-agg-key-status\");\n  let cachedCsv = \"\";\n  const embeddedKey = parseKeyScript();\n  if (keyStatus) {\n    keyStatus.textContent = embeddedKey?.recipient_kid ? `Loaded (${embeddedKey.recipient_kid})` : embeddedKey ? \"Loaded\" : \"Not loaded\";\n    keyStatus.classList.toggle(\"ready\", !!embeddedKey);\n  }\n  const runAggregation = async () => {\n    if (!fileInput?.files || fileInput.files.length === 0) {\n      if (status)\n        status.textContent = \"Select HTML files first.\";\n      return;\n    }\n    if (status)\n      status.textContent = \"Processing...\";\n    if (dlBtn)\n      dlBtn.disabled = true;\n    const rows = [];\n    const keys = new Set([\"_filename\"]);\n    let processed = 0;\n    let errors = 0;\n    const l2Keys = embeddedKey;\n    for (const file of Array.from(fileInput.files)) {\n      try {\n        const html = await file.text();\n        const extracted = await extractPlainFromHtml(html, l2Keys);\n        if (extracted.source === \"l2\" && extracted.plain) {\n          const built = buildRowFromPlain({\n            plain: extracted.plain,\n            filename: file.name,\n            includeJson: includeJson?.checked,\n            sig: extracted.sig\n          });\n          built.keys.forEach((key) => keys.add(key));\n          rows.push(built.row);\n          processed += 1;\n          continue;\n        }\n        if (extracted.source === \"jsonld\" && extracted.plain) {\n          const built = buildRowFromPlain({\n            plain: extracted.plain,\n            filename: file.name,\n            includeJson: includeJson?.checked,\n            omitKey: (key) => key.startsWith(\"@\")\n          });\n          built.keys.forEach((key) => keys.add(key));\n          rows.push(built.row);\n          processed += 1;\n          continue;\n        }\n        errors += 1;\n      } catch (e) {\n        console.error(e);\n        errors += 1;\n      }\n    }\n    const sortedKeys = Array.from(keys).sort((a, b) => {\n      if (a === \"_filename\")\n        return -1;\n      if (b === \"_filename\")\n        return 1;\n      return a.localeCompare(b);\n    });\n    cachedCsv = buildCsv(rows, sortedKeys);\n    if (dlBtn)\n      dlBtn.disabled = rows.length === 0;\n    if (status)\n      status.textContent = `Processed ${processed} files. Errors: ${errors}.`;\n    if (output)\n      renderTable(output, rows, sortedKeys);\n  };\n  runBtn?.addEventListener(\"click\", () => {\n    runAggregation().catch((e) => {\n      if (status)\n        status.textContent = \"Failed to aggregate.\";\n      console.error(e);\n    });\n  });\n  dlBtn?.addEventListener(\"click\", () => {\n    if (!cachedCsv)\n      return;\n    const blob = new Blob([cachedCsv], { type: \"text/csv\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"weba-aggregated.csv\";\n    a.click();\n    URL.revokeObjectURL(url);\n  });\n}\n\n// src/form/client/runtime.ts\nfunction initRuntime() {\n  console.log(\"Web/A Runtime Booting...\");\n  const calc = new Calculator;\n  const data = new DataManager;\n  const ui = new UIManager(calc, data);\n  const w = window;\n  const structureScript = document.getElementById(\"weba-structure\");\n  if (structureScript?.textContent) {\n    try {\n      w.generatedJsonStructure = JSON.parse(structureScript.textContent);\n    } catch (e) {\n      console.warn(\"Failed to parse weba structure JSON\", e);\n    }\n  }\n  const l2Config = loadL2Config();\n  if (l2Config) {\n    w.webaL2Config = l2Config;\n  }\n  w.saveDraft = () => data.saveDraft();\n  w.submitDocument = () => data.submitDocument();\n  w.signAndDownload = () => data.signAndDownload();\n  w.clearData = () => data.clearData();\n  w.removeTableRow = (btn) => ui.removeTableRow(btn);\n  w.addTableRow = (btn, tableKey) => ui.addTableRow(btn, tableKey);\n  w.switchTab = (btn, tabId) => ui.switchTab(btn, tabId);\n  w.recalculate = () => calc.recalculate();\n  w.escapeHtml = (str) => {\n    if (!str)\n      return \"\";\n    const map = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&#39;\"\n    };\n    return str.toString().replace(/[&<>\"']/g, (m) => map[m] || m);\n  };\n  data.restoreFromLS();\n  ui.applyI18n();\n  ui.initTables();\n  calc.recalculate();\n  initL2Viewer();\n  initKeywrapTool();\n  initAggregatorBrowser();\n  let tm;\n  document.addEventListener(\"input\", (e) => {\n    const input = e.target;\n    if (e.isTrusted) {\n      input.dataset.dirty = \"true\";\n    }\n    const key = input.dataset.baseKey || input.dataset.jsonPath;\n    if (key) {\n      const row = input.closest(\"tr\");\n      const scope = row || document;\n      scope.querySelectorAll(`[data-copy-from=\"${key}\"]`).forEach((dest) => {\n        if (!dest.dataset.dirty) {\n          if (dest.value !== input.value) {\n            dest.value = input.value;\n            dest.dispatchEvent(new Event(\"input\"));\n          }\n        }\n      });\n    }\n    calc.recalculate();\n    data.updateJsonLd();\n    clearTimeout(tm);\n    tm = setTimeout(() => data.saveToLS(), 1000);\n  });\n  console.log(\"Web/A Runtime Ready.\");\n}\n\n// src/form/client/search.ts\nclass SearchEngine {\n  suggestionsVisible = false;\n  activeSearchInput = null;\n  globalBox = null;\n  constructor() {}\n  init() {\n    console.log(\"Initializing Search Engine (Bundle)...\");\n    const w = window;\n    if (w.generatedJsonStructure && w.generatedJsonStructure.masterData) {\n      const keys = Object.keys(w.generatedJsonStructure.masterData);\n      console.log(\"Master Data Keys available:\", keys.join(\", \"));\n    }\n    this.setupEventDelegation();\n  }\n  normalize(val) {\n    if (!val)\n      return \"\";\n    let n = val.toString().toLowerCase();\n    n = n.replace(/[\uff21-\uff3a\uff41-\uff5a\uff10-\uff19]/g, (s) => {\n      return String.fromCharCode(s.charCodeAt(0) - 65248);\n    });\n    n = n.replace(/[\uff01-\uff5e]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 65248));\n    return n.trim();\n  }\n  clean(s) {\n    if (!s)\n      return \"\";\n    let n = this.normalize(s);\n    n = n.replace(/(\u682a\u5f0f\u4f1a\u793e|\u6709\u9650\u4f1a\u793e|\u5408\u540c\u4f1a\u793e|\u4e00\u822c\u793e\u56e3\u6cd5\u4eba|\u516c\u76ca\u793e\u56e3\u6cd5\u4eba|npo\u6cd5\u4eba|\u5b66\u6821\u6cd5\u4eba|\u793e\u4f1a\u798f\u7949\u6cd5\u4eba)/g, \"\");\n    n = n.replace(/(\\(\u682a\\)|\\(\u6709\\)|\\(\u540c\\))/g, \"\");\n    return n.trim();\n  }\n  toIndex(raw) {\n    const parsed = parseInt(raw || \"\", 10);\n    return Number.isFinite(parsed) ? parsed - 1 : -1;\n  }\n  getGlobalBox() {\n    if (!this.globalBox) {\n      this.globalBox = document.getElementById(\"web-a-search-suggestions\");\n      if (!this.globalBox) {\n        this.globalBox = document.createElement(\"div\");\n        this.globalBox.id = \"web-a-search-suggestions\";\n        this.globalBox.className = \"search-suggestions\";\n        Object.assign(this.globalBox.style, {\n          display: \"none\",\n          position: \"absolute\",\n          background: \"white\",\n          border: \"1px solid #ccc\",\n          boxShadow: \"0 4px 6px rgba(0,0,0,0.1)\",\n          zIndex: \"9999\",\n          maxHeight: \"200px\",\n          overflowY: \"auto\",\n          borderRadius: \"4px\"\n        });\n        document.body.appendChild(this.globalBox);\n      }\n    }\n    return this.globalBox;\n  }\n  hideSuggestions() {\n    const box = this.getGlobalBox();\n    if (box)\n      box.style.display = \"none\";\n    this.suggestionsVisible = false;\n    this.activeSearchInput = null;\n  }\n  setupEventDelegation() {\n    document.addEventListener(\"click\", (e) => {\n      if (this.suggestionsVisible && !e.target.closest(\"#web-a-search-suggestions\") && e.target !== this.activeSearchInput) {\n        this.hideSuggestions();\n      }\n    });\n    document.addEventListener(\"scroll\", () => {\n      if (this.suggestionsVisible)\n        this.hideSuggestions();\n    }, true);\n    document.body.addEventListener(\"input\", (e) => {\n      if (e.target.classList.contains(\"search-input\")) {\n        this.handleSearchInput(e.target);\n      }\n    });\n    document.body.addEventListener(\"click\", (e) => {\n      if (e.target.classList.contains(\"suggestion-item\")) {\n        this.handleSelection(e.target);\n      }\n    });\n  }\n  handleSearchInput(input) {\n    this.activeSearchInput = input;\n    const w = window;\n    const srcKey = input.dataset.masterSrc;\n    const suggestSource = input.dataset.suggestSource;\n    if (!srcKey && !suggestSource)\n      return;\n    const labelIdx = this.toIndex(input.dataset.masterLabelIndex);\n    const valueIdx = this.toIndex(input.dataset.masterValueIndex);\n    const query = input.value;\n    if (!query) {\n      this.hideSuggestions();\n      return;\n    }\n    const hits = [];\n    const normQuery = this.normalize(query);\n    if (suggestSource === \"column\") {\n      const baseKey = input.dataset.baseKey;\n      const table = input.closest(\"table\");\n      if (table && baseKey) {\n        const seen = new Set;\n        table.querySelectorAll(`[data-base-key=\"${baseKey}\"]`).forEach((inp) => {\n          if (inp === input)\n            return;\n          const v = inp.value;\n          if (v && this.normalize(v).includes(normQuery)) {\n            if (!seen.has(v)) {\n              seen.add(v);\n              hits.push({ val: v, row: [v], label: v, score: 10 });\n            }\n          }\n        });\n      }\n    } else if (srcKey) {\n      const master = w.generatedJsonStructure.masterData;\n      if (!master || !master[srcKey])\n        return;\n      const allRows = master[srcKey];\n      allRows.forEach((row, idx) => {\n        if (idx === 0)\n          return;\n        const match = row.some((col) => this.normalize(col || \"\").includes(normQuery));\n        if (match) {\n          const labelVal = labelIdx >= 0 ? row[labelIdx] || \"\" : \"\";\n          const valueVal = valueIdx >= 0 ? row[valueIdx] || \"\" : \"\";\n          const val = valueIdx >= 0 ? valueVal : labelIdx >= 0 ? labelVal : row[1] || row[0] || \"\";\n          hits.push({ val, row, label: labelVal, score: 10, idx });\n        }\n      });\n    }\n    this.renderSuggestions(input, hits, labelIdx);\n  }\n  renderSuggestions(input, hits, labelIdx) {\n    if (hits.length === 0) {\n      this.hideSuggestions();\n      return;\n    }\n    const w = window;\n    const topHits = hits.slice(0, 10);\n    let html = \"\";\n    topHits.forEach((h) => {\n      const rowJson = w.escapeHtml(JSON.stringify(h.row));\n      const displayLabel = labelIdx >= 0 ? h.label || h.row.join(\" : \") : h.row.join(\" : \");\n      html += `<div class=\"suggestion-item\" data-val=\"${w.escapeHtml(h.val)}\" data-row=\"${rowJson}\" style=\"padding:8px; cursor:pointer; border-bottom:1px solid #eee; font-size:14px; color:#333;\">${w.escapeHtml(displayLabel)}</div>`;\n    });\n    const box = this.getGlobalBox();\n    box.innerHTML = html;\n    const rect = input.getBoundingClientRect();\n    const scrollTop = window.scrollY || document.documentElement.scrollTop;\n    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n    box.style.width = Math.max(rect.width, 200) + \"px\";\n    box.style.left = rect.left + scrollLeft + \"px\";\n    box.style.top = rect.bottom + scrollTop + \"px\";\n    box.querySelectorAll(\".suggestion-item\").forEach((el) => {\n      el.onmouseenter = () => el.style.background = \"#f0f8ff\";\n      el.onmouseleave = () => el.style.background = \"white\";\n    });\n    box.style.display = \"block\";\n    this.suggestionsVisible = true;\n  }\n  handleSelection(item) {\n    if (!this.activeSearchInput)\n      return;\n    const w = window;\n    const input = this.activeSearchInput;\n    const val = item.dataset.val || \"\";\n    const rowJson = item.dataset.row || \"[]\";\n    try {\n      const rowData = JSON.parse(rowJson);\n      const srcKey = input.dataset.masterSrc;\n      const masterHeaders = srcKey ? w.generatedJsonStructure.masterData[srcKey][0] : [];\n      let searchInputFilled = false;\n      if (masterHeaders.length > 0 && rowData.length > 0) {\n        const tr = input.closest(\"tr\");\n        if (tr) {\n          const inputs = Array.from(tr.querySelectorAll(\"input, select, textarea\"));\n          masterHeaders.forEach((header, idx) => {\n            if (!header)\n              return;\n            const targetVal = rowData[idx];\n            this.fillField(inputs, header, targetVal, input, () => {\n              searchInputFilled = true;\n            });\n          });\n        }\n      }\n      if (!searchInputFilled) {\n        input.value = val;\n        input.dispatchEvent(new Event(\"input\", { bubbles: true }));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    this.hideSuggestions();\n  }\n  fillField(inputs, header, value, sourceInput, onSelfFilled) {\n    const normHeader = this.normalize(header);\n    const target2 = inputs.find((inp) => {\n      const k = inp.dataset.baseKey || inp.dataset.jsonPath;\n      const ph = this.normalize(inp.getAttribute(\"placeholder\") || \"\");\n      return k && this.normalize(k) === normHeader || ph === normHeader;\n    });\n    if (target2) {\n      target2.value = value || \"\";\n      target2.dispatchEvent(new Event(\"input\", { bubbles: true }));\n      if (target2 === sourceInput)\n        onSelfFilled();\n    }\n  }\n}\n\n// src/form/client/index.ts\nvar search = new SearchEngine;\nwindow.GlobalSearch = search;\ninitRuntime();\nsearch.init();\n";
